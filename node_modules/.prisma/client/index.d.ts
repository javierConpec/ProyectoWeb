
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model categorias
 * 
 */
export type categorias = $Result.DefaultSelection<Prisma.$categoriasPayload>
/**
 * Model paises
 * 
 */
export type paises = $Result.DefaultSelection<Prisma.$paisesPayload>
/**
 * Model paquetes
 * 
 */
export type paquetes = $Result.DefaultSelection<Prisma.$paquetesPayload>
/**
 * Model roles
 * 
 */
export type roles = $Result.DefaultSelection<Prisma.$rolesPayload>
/**
 * Model destinos
 * 
 */
export type destinos = $Result.DefaultSelection<Prisma.$destinosPayload>
/**
 * Model hospedajes
 * 
 */
export type hospedajes = $Result.DefaultSelection<Prisma.$hospedajesPayload>
/**
 * Model reservas
 * 
 */
export type reservas = $Result.DefaultSelection<Prisma.$reservasPayload>
/**
 * Model usuarios
 * 
 */
export type usuarios = $Result.DefaultSelection<Prisma.$usuariosPayload>
/**
 * Model viajes
 * 
 */
export type viajes = $Result.DefaultSelection<Prisma.$viajesPayload>
/**
 * Model itinerarios
 * 
 */
export type itinerarios = $Result.DefaultSelection<Prisma.$itinerariosPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Categorias
 * const categorias = await prisma.categorias.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Categorias
   * const categorias = await prisma.categorias.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.categorias`: Exposes CRUD operations for the **categorias** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categorias
    * const categorias = await prisma.categorias.findMany()
    * ```
    */
  get categorias(): Prisma.categoriasDelegate<ExtArgs>;

  /**
   * `prisma.paises`: Exposes CRUD operations for the **paises** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Paises
    * const paises = await prisma.paises.findMany()
    * ```
    */
  get paises(): Prisma.paisesDelegate<ExtArgs>;

  /**
   * `prisma.paquetes`: Exposes CRUD operations for the **paquetes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Paquetes
    * const paquetes = await prisma.paquetes.findMany()
    * ```
    */
  get paquetes(): Prisma.paquetesDelegate<ExtArgs>;

  /**
   * `prisma.roles`: Exposes CRUD operations for the **roles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.roles.findMany()
    * ```
    */
  get roles(): Prisma.rolesDelegate<ExtArgs>;

  /**
   * `prisma.destinos`: Exposes CRUD operations for the **destinos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Destinos
    * const destinos = await prisma.destinos.findMany()
    * ```
    */
  get destinos(): Prisma.destinosDelegate<ExtArgs>;

  /**
   * `prisma.hospedajes`: Exposes CRUD operations for the **hospedajes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Hospedajes
    * const hospedajes = await prisma.hospedajes.findMany()
    * ```
    */
  get hospedajes(): Prisma.hospedajesDelegate<ExtArgs>;

  /**
   * `prisma.reservas`: Exposes CRUD operations for the **reservas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reservas
    * const reservas = await prisma.reservas.findMany()
    * ```
    */
  get reservas(): Prisma.reservasDelegate<ExtArgs>;

  /**
   * `prisma.usuarios`: Exposes CRUD operations for the **usuarios** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuarios.findMany()
    * ```
    */
  get usuarios(): Prisma.usuariosDelegate<ExtArgs>;

  /**
   * `prisma.viajes`: Exposes CRUD operations for the **viajes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Viajes
    * const viajes = await prisma.viajes.findMany()
    * ```
    */
  get viajes(): Prisma.viajesDelegate<ExtArgs>;

  /**
   * `prisma.itinerarios`: Exposes CRUD operations for the **itinerarios** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Itinerarios
    * const itinerarios = await prisma.itinerarios.findMany()
    * ```
    */
  get itinerarios(): Prisma.itinerariosDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.16.1
   * Query Engine version: 34ace0eb2704183d2c05b60b52fba5c43c13f303
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    categorias: 'categorias',
    paises: 'paises',
    paquetes: 'paquetes',
    roles: 'roles',
    destinos: 'destinos',
    hospedajes: 'hospedajes',
    reservas: 'reservas',
    usuarios: 'usuarios',
    viajes: 'viajes',
    itinerarios: 'itinerarios'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "categorias" | "paises" | "paquetes" | "roles" | "destinos" | "hospedajes" | "reservas" | "usuarios" | "viajes" | "itinerarios"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      categorias: {
        payload: Prisma.$categoriasPayload<ExtArgs>
        fields: Prisma.categoriasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.categoriasFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.categoriasFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriasPayload>
          }
          findFirst: {
            args: Prisma.categoriasFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.categoriasFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriasPayload>
          }
          findMany: {
            args: Prisma.categoriasFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriasPayload>[]
          }
          create: {
            args: Prisma.categoriasCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriasPayload>
          }
          createMany: {
            args: Prisma.categoriasCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.categoriasCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriasPayload>[]
          }
          delete: {
            args: Prisma.categoriasDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriasPayload>
          }
          update: {
            args: Prisma.categoriasUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriasPayload>
          }
          deleteMany: {
            args: Prisma.categoriasDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.categoriasUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.categoriasUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriasPayload>
          }
          aggregate: {
            args: Prisma.CategoriasAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategorias>
          }
          groupBy: {
            args: Prisma.categoriasGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoriasGroupByOutputType>[]
          }
          count: {
            args: Prisma.categoriasCountArgs<ExtArgs>
            result: $Utils.Optional<CategoriasCountAggregateOutputType> | number
          }
        }
      }
      paises: {
        payload: Prisma.$paisesPayload<ExtArgs>
        fields: Prisma.paisesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.paisesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paisesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.paisesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paisesPayload>
          }
          findFirst: {
            args: Prisma.paisesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paisesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.paisesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paisesPayload>
          }
          findMany: {
            args: Prisma.paisesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paisesPayload>[]
          }
          create: {
            args: Prisma.paisesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paisesPayload>
          }
          createMany: {
            args: Prisma.paisesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.paisesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paisesPayload>[]
          }
          delete: {
            args: Prisma.paisesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paisesPayload>
          }
          update: {
            args: Prisma.paisesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paisesPayload>
          }
          deleteMany: {
            args: Prisma.paisesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.paisesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.paisesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paisesPayload>
          }
          aggregate: {
            args: Prisma.PaisesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaises>
          }
          groupBy: {
            args: Prisma.paisesGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaisesGroupByOutputType>[]
          }
          count: {
            args: Prisma.paisesCountArgs<ExtArgs>
            result: $Utils.Optional<PaisesCountAggregateOutputType> | number
          }
        }
      }
      paquetes: {
        payload: Prisma.$paquetesPayload<ExtArgs>
        fields: Prisma.paquetesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.paquetesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paquetesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.paquetesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paquetesPayload>
          }
          findFirst: {
            args: Prisma.paquetesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paquetesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.paquetesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paquetesPayload>
          }
          findMany: {
            args: Prisma.paquetesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paquetesPayload>[]
          }
          create: {
            args: Prisma.paquetesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paquetesPayload>
          }
          createMany: {
            args: Prisma.paquetesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.paquetesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paquetesPayload>[]
          }
          delete: {
            args: Prisma.paquetesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paquetesPayload>
          }
          update: {
            args: Prisma.paquetesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paquetesPayload>
          }
          deleteMany: {
            args: Prisma.paquetesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.paquetesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.paquetesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paquetesPayload>
          }
          aggregate: {
            args: Prisma.PaquetesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaquetes>
          }
          groupBy: {
            args: Prisma.paquetesGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaquetesGroupByOutputType>[]
          }
          count: {
            args: Prisma.paquetesCountArgs<ExtArgs>
            result: $Utils.Optional<PaquetesCountAggregateOutputType> | number
          }
        }
      }
      roles: {
        payload: Prisma.$rolesPayload<ExtArgs>
        fields: Prisma.rolesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.rolesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.rolesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          findFirst: {
            args: Prisma.rolesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.rolesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          findMany: {
            args: Prisma.rolesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>[]
          }
          create: {
            args: Prisma.rolesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          createMany: {
            args: Prisma.rolesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.rolesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>[]
          }
          delete: {
            args: Prisma.rolesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          update: {
            args: Prisma.rolesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          deleteMany: {
            args: Prisma.rolesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.rolesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.rolesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          aggregate: {
            args: Prisma.RolesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoles>
          }
          groupBy: {
            args: Prisma.rolesGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolesGroupByOutputType>[]
          }
          count: {
            args: Prisma.rolesCountArgs<ExtArgs>
            result: $Utils.Optional<RolesCountAggregateOutputType> | number
          }
        }
      }
      destinos: {
        payload: Prisma.$destinosPayload<ExtArgs>
        fields: Prisma.destinosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.destinosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$destinosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.destinosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$destinosPayload>
          }
          findFirst: {
            args: Prisma.destinosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$destinosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.destinosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$destinosPayload>
          }
          findMany: {
            args: Prisma.destinosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$destinosPayload>[]
          }
          create: {
            args: Prisma.destinosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$destinosPayload>
          }
          createMany: {
            args: Prisma.destinosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.destinosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$destinosPayload>[]
          }
          delete: {
            args: Prisma.destinosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$destinosPayload>
          }
          update: {
            args: Prisma.destinosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$destinosPayload>
          }
          deleteMany: {
            args: Prisma.destinosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.destinosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.destinosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$destinosPayload>
          }
          aggregate: {
            args: Prisma.DestinosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDestinos>
          }
          groupBy: {
            args: Prisma.destinosGroupByArgs<ExtArgs>
            result: $Utils.Optional<DestinosGroupByOutputType>[]
          }
          count: {
            args: Prisma.destinosCountArgs<ExtArgs>
            result: $Utils.Optional<DestinosCountAggregateOutputType> | number
          }
        }
      }
      hospedajes: {
        payload: Prisma.$hospedajesPayload<ExtArgs>
        fields: Prisma.hospedajesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.hospedajesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hospedajesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.hospedajesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hospedajesPayload>
          }
          findFirst: {
            args: Prisma.hospedajesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hospedajesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.hospedajesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hospedajesPayload>
          }
          findMany: {
            args: Prisma.hospedajesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hospedajesPayload>[]
          }
          create: {
            args: Prisma.hospedajesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hospedajesPayload>
          }
          createMany: {
            args: Prisma.hospedajesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.hospedajesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hospedajesPayload>[]
          }
          delete: {
            args: Prisma.hospedajesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hospedajesPayload>
          }
          update: {
            args: Prisma.hospedajesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hospedajesPayload>
          }
          deleteMany: {
            args: Prisma.hospedajesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.hospedajesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.hospedajesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hospedajesPayload>
          }
          aggregate: {
            args: Prisma.HospedajesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHospedajes>
          }
          groupBy: {
            args: Prisma.hospedajesGroupByArgs<ExtArgs>
            result: $Utils.Optional<HospedajesGroupByOutputType>[]
          }
          count: {
            args: Prisma.hospedajesCountArgs<ExtArgs>
            result: $Utils.Optional<HospedajesCountAggregateOutputType> | number
          }
        }
      }
      reservas: {
        payload: Prisma.$reservasPayload<ExtArgs>
        fields: Prisma.reservasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.reservasFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reservasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.reservasFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reservasPayload>
          }
          findFirst: {
            args: Prisma.reservasFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reservasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.reservasFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reservasPayload>
          }
          findMany: {
            args: Prisma.reservasFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reservasPayload>[]
          }
          create: {
            args: Prisma.reservasCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reservasPayload>
          }
          createMany: {
            args: Prisma.reservasCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.reservasCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reservasPayload>[]
          }
          delete: {
            args: Prisma.reservasDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reservasPayload>
          }
          update: {
            args: Prisma.reservasUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reservasPayload>
          }
          deleteMany: {
            args: Prisma.reservasDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.reservasUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.reservasUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reservasPayload>
          }
          aggregate: {
            args: Prisma.ReservasAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReservas>
          }
          groupBy: {
            args: Prisma.reservasGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReservasGroupByOutputType>[]
          }
          count: {
            args: Prisma.reservasCountArgs<ExtArgs>
            result: $Utils.Optional<ReservasCountAggregateOutputType> | number
          }
        }
      }
      usuarios: {
        payload: Prisma.$usuariosPayload<ExtArgs>
        fields: Prisma.usuariosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usuariosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usuariosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosPayload>
          }
          findFirst: {
            args: Prisma.usuariosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usuariosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosPayload>
          }
          findMany: {
            args: Prisma.usuariosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosPayload>[]
          }
          create: {
            args: Prisma.usuariosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosPayload>
          }
          createMany: {
            args: Prisma.usuariosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.usuariosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosPayload>[]
          }
          delete: {
            args: Prisma.usuariosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosPayload>
          }
          update: {
            args: Prisma.usuariosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosPayload>
          }
          deleteMany: {
            args: Prisma.usuariosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usuariosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.usuariosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosPayload>
          }
          aggregate: {
            args: Prisma.UsuariosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsuarios>
          }
          groupBy: {
            args: Prisma.usuariosGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsuariosGroupByOutputType>[]
          }
          count: {
            args: Prisma.usuariosCountArgs<ExtArgs>
            result: $Utils.Optional<UsuariosCountAggregateOutputType> | number
          }
        }
      }
      viajes: {
        payload: Prisma.$viajesPayload<ExtArgs>
        fields: Prisma.viajesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.viajesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viajesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.viajesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viajesPayload>
          }
          findFirst: {
            args: Prisma.viajesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viajesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.viajesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viajesPayload>
          }
          findMany: {
            args: Prisma.viajesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viajesPayload>[]
          }
          create: {
            args: Prisma.viajesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viajesPayload>
          }
          createMany: {
            args: Prisma.viajesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.viajesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viajesPayload>[]
          }
          delete: {
            args: Prisma.viajesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viajesPayload>
          }
          update: {
            args: Prisma.viajesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viajesPayload>
          }
          deleteMany: {
            args: Prisma.viajesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.viajesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.viajesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viajesPayload>
          }
          aggregate: {
            args: Prisma.ViajesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateViajes>
          }
          groupBy: {
            args: Prisma.viajesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ViajesGroupByOutputType>[]
          }
          count: {
            args: Prisma.viajesCountArgs<ExtArgs>
            result: $Utils.Optional<ViajesCountAggregateOutputType> | number
          }
        }
      }
      itinerarios: {
        payload: Prisma.$itinerariosPayload<ExtArgs>
        fields: Prisma.itinerariosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.itinerariosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itinerariosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.itinerariosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itinerariosPayload>
          }
          findFirst: {
            args: Prisma.itinerariosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itinerariosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.itinerariosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itinerariosPayload>
          }
          findMany: {
            args: Prisma.itinerariosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itinerariosPayload>[]
          }
          create: {
            args: Prisma.itinerariosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itinerariosPayload>
          }
          createMany: {
            args: Prisma.itinerariosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.itinerariosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itinerariosPayload>[]
          }
          delete: {
            args: Prisma.itinerariosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itinerariosPayload>
          }
          update: {
            args: Prisma.itinerariosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itinerariosPayload>
          }
          deleteMany: {
            args: Prisma.itinerariosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.itinerariosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.itinerariosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itinerariosPayload>
          }
          aggregate: {
            args: Prisma.ItinerariosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItinerarios>
          }
          groupBy: {
            args: Prisma.itinerariosGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItinerariosGroupByOutputType>[]
          }
          count: {
            args: Prisma.itinerariosCountArgs<ExtArgs>
            result: $Utils.Optional<ItinerariosCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CategoriasCountOutputType
   */

  export type CategoriasCountOutputType = {
    paquetes: number
    viajes: number
  }

  export type CategoriasCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paquetes?: boolean | CategoriasCountOutputTypeCountPaquetesArgs
    viajes?: boolean | CategoriasCountOutputTypeCountViajesArgs
  }

  // Custom InputTypes
  /**
   * CategoriasCountOutputType without action
   */
  export type CategoriasCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriasCountOutputType
     */
    select?: CategoriasCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoriasCountOutputType without action
   */
  export type CategoriasCountOutputTypeCountPaquetesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paquetesWhereInput
  }

  /**
   * CategoriasCountOutputType without action
   */
  export type CategoriasCountOutputTypeCountViajesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: viajesWhereInput
  }


  /**
   * Count Type PaisesCountOutputType
   */

  export type PaisesCountOutputType = {
    destinos: number
  }

  export type PaisesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    destinos?: boolean | PaisesCountOutputTypeCountDestinosArgs
  }

  // Custom InputTypes
  /**
   * PaisesCountOutputType without action
   */
  export type PaisesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaisesCountOutputType
     */
    select?: PaisesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PaisesCountOutputType without action
   */
  export type PaisesCountOutputTypeCountDestinosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: destinosWhereInput
  }


  /**
   * Count Type PaquetesCountOutputType
   */

  export type PaquetesCountOutputType = {
    viajes: number
  }

  export type PaquetesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    viajes?: boolean | PaquetesCountOutputTypeCountViajesArgs
  }

  // Custom InputTypes
  /**
   * PaquetesCountOutputType without action
   */
  export type PaquetesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaquetesCountOutputType
     */
    select?: PaquetesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PaquetesCountOutputType without action
   */
  export type PaquetesCountOutputTypeCountViajesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: viajesWhereInput
  }


  /**
   * Count Type RolesCountOutputType
   */

  export type RolesCountOutputType = {
    usuarios: number
  }

  export type RolesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuarios?: boolean | RolesCountOutputTypeCountUsuariosArgs
  }

  // Custom InputTypes
  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolesCountOutputType
     */
    select?: RolesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeCountUsuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usuariosWhereInput
  }


  /**
   * Count Type DestinosCountOutputType
   */

  export type DestinosCountOutputType = {
    hospedajes: number
    viajes: number
  }

  export type DestinosCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hospedajes?: boolean | DestinosCountOutputTypeCountHospedajesArgs
    viajes?: boolean | DestinosCountOutputTypeCountViajesArgs
  }

  // Custom InputTypes
  /**
   * DestinosCountOutputType without action
   */
  export type DestinosCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DestinosCountOutputType
     */
    select?: DestinosCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DestinosCountOutputType without action
   */
  export type DestinosCountOutputTypeCountHospedajesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: hospedajesWhereInput
  }

  /**
   * DestinosCountOutputType without action
   */
  export type DestinosCountOutputTypeCountViajesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: viajesWhereInput
  }


  /**
   * Count Type HospedajesCountOutputType
   */

  export type HospedajesCountOutputType = {
    paquetes: number
    viajes: number
  }

  export type HospedajesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paquetes?: boolean | HospedajesCountOutputTypeCountPaquetesArgs
    viajes?: boolean | HospedajesCountOutputTypeCountViajesArgs
  }

  // Custom InputTypes
  /**
   * HospedajesCountOutputType without action
   */
  export type HospedajesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HospedajesCountOutputType
     */
    select?: HospedajesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HospedajesCountOutputType without action
   */
  export type HospedajesCountOutputTypeCountPaquetesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paquetesWhereInput
  }

  /**
   * HospedajesCountOutputType without action
   */
  export type HospedajesCountOutputTypeCountViajesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: viajesWhereInput
  }


  /**
   * Count Type UsuariosCountOutputType
   */

  export type UsuariosCountOutputType = {
    reservas: number
  }

  export type UsuariosCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reservas?: boolean | UsuariosCountOutputTypeCountReservasArgs
  }

  // Custom InputTypes
  /**
   * UsuariosCountOutputType without action
   */
  export type UsuariosCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuariosCountOutputType
     */
    select?: UsuariosCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsuariosCountOutputType without action
   */
  export type UsuariosCountOutputTypeCountReservasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reservasWhereInput
  }


  /**
   * Count Type ViajesCountOutputType
   */

  export type ViajesCountOutputType = {
    itinerarios: number
    reservas: number
  }

  export type ViajesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itinerarios?: boolean | ViajesCountOutputTypeCountItinerariosArgs
    reservas?: boolean | ViajesCountOutputTypeCountReservasArgs
  }

  // Custom InputTypes
  /**
   * ViajesCountOutputType without action
   */
  export type ViajesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViajesCountOutputType
     */
    select?: ViajesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ViajesCountOutputType without action
   */
  export type ViajesCountOutputTypeCountItinerariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: itinerariosWhereInput
  }

  /**
   * ViajesCountOutputType without action
   */
  export type ViajesCountOutputTypeCountReservasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reservasWhereInput
  }


  /**
   * Models
   */

  /**
   * Model categorias
   */

  export type AggregateCategorias = {
    _count: CategoriasCountAggregateOutputType | null
    _avg: CategoriasAvgAggregateOutputType | null
    _sum: CategoriasSumAggregateOutputType | null
    _min: CategoriasMinAggregateOutputType | null
    _max: CategoriasMaxAggregateOutputType | null
  }

  export type CategoriasAvgAggregateOutputType = {
    id_categoria: number | null
  }

  export type CategoriasSumAggregateOutputType = {
    id_categoria: number | null
  }

  export type CategoriasMinAggregateOutputType = {
    id_categoria: number | null
    nombre: string | null
    estado_auditoria: string | null
    fecha_creacion: Date | null
    fecha_modificacion: Date | null
  }

  export type CategoriasMaxAggregateOutputType = {
    id_categoria: number | null
    nombre: string | null
    estado_auditoria: string | null
    fecha_creacion: Date | null
    fecha_modificacion: Date | null
  }

  export type CategoriasCountAggregateOutputType = {
    id_categoria: number
    nombre: number
    estado_auditoria: number
    fecha_creacion: number
    fecha_modificacion: number
    _all: number
  }


  export type CategoriasAvgAggregateInputType = {
    id_categoria?: true
  }

  export type CategoriasSumAggregateInputType = {
    id_categoria?: true
  }

  export type CategoriasMinAggregateInputType = {
    id_categoria?: true
    nombre?: true
    estado_auditoria?: true
    fecha_creacion?: true
    fecha_modificacion?: true
  }

  export type CategoriasMaxAggregateInputType = {
    id_categoria?: true
    nombre?: true
    estado_auditoria?: true
    fecha_creacion?: true
    fecha_modificacion?: true
  }

  export type CategoriasCountAggregateInputType = {
    id_categoria?: true
    nombre?: true
    estado_auditoria?: true
    fecha_creacion?: true
    fecha_modificacion?: true
    _all?: true
  }

  export type CategoriasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which categorias to aggregate.
     */
    where?: categoriasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categorias to fetch.
     */
    orderBy?: categoriasOrderByWithRelationInput | categoriasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: categoriasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned categorias
    **/
    _count?: true | CategoriasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoriasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategoriasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoriasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoriasMaxAggregateInputType
  }

  export type GetCategoriasAggregateType<T extends CategoriasAggregateArgs> = {
        [P in keyof T & keyof AggregateCategorias]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategorias[P]>
      : GetScalarType<T[P], AggregateCategorias[P]>
  }




  export type categoriasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: categoriasWhereInput
    orderBy?: categoriasOrderByWithAggregationInput | categoriasOrderByWithAggregationInput[]
    by: CategoriasScalarFieldEnum[] | CategoriasScalarFieldEnum
    having?: categoriasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoriasCountAggregateInputType | true
    _avg?: CategoriasAvgAggregateInputType
    _sum?: CategoriasSumAggregateInputType
    _min?: CategoriasMinAggregateInputType
    _max?: CategoriasMaxAggregateInputType
  }

  export type CategoriasGroupByOutputType = {
    id_categoria: number
    nombre: string
    estado_auditoria: string
    fecha_creacion: Date
    fecha_modificacion: Date | null
    _count: CategoriasCountAggregateOutputType | null
    _avg: CategoriasAvgAggregateOutputType | null
    _sum: CategoriasSumAggregateOutputType | null
    _min: CategoriasMinAggregateOutputType | null
    _max: CategoriasMaxAggregateOutputType | null
  }

  type GetCategoriasGroupByPayload<T extends categoriasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoriasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoriasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoriasGroupByOutputType[P]>
            : GetScalarType<T[P], CategoriasGroupByOutputType[P]>
        }
      >
    >


  export type categoriasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_categoria?: boolean
    nombre?: boolean
    estado_auditoria?: boolean
    fecha_creacion?: boolean
    fecha_modificacion?: boolean
    paquetes?: boolean | categorias$paquetesArgs<ExtArgs>
    viajes?: boolean | categorias$viajesArgs<ExtArgs>
    _count?: boolean | CategoriasCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categorias"]>

  export type categoriasSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_categoria?: boolean
    nombre?: boolean
    estado_auditoria?: boolean
    fecha_creacion?: boolean
    fecha_modificacion?: boolean
  }, ExtArgs["result"]["categorias"]>

  export type categoriasSelectScalar = {
    id_categoria?: boolean
    nombre?: boolean
    estado_auditoria?: boolean
    fecha_creacion?: boolean
    fecha_modificacion?: boolean
  }

  export type categoriasInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paquetes?: boolean | categorias$paquetesArgs<ExtArgs>
    viajes?: boolean | categorias$viajesArgs<ExtArgs>
    _count?: boolean | CategoriasCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type categoriasIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $categoriasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "categorias"
    objects: {
      paquetes: Prisma.$paquetesPayload<ExtArgs>[]
      viajes: Prisma.$viajesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_categoria: number
      nombre: string
      estado_auditoria: string
      fecha_creacion: Date
      fecha_modificacion: Date | null
    }, ExtArgs["result"]["categorias"]>
    composites: {}
  }

  type categoriasGetPayload<S extends boolean | null | undefined | categoriasDefaultArgs> = $Result.GetResult<Prisma.$categoriasPayload, S>

  type categoriasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<categoriasFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CategoriasCountAggregateInputType | true
    }

  export interface categoriasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['categorias'], meta: { name: 'categorias' } }
    /**
     * Find zero or one Categorias that matches the filter.
     * @param {categoriasFindUniqueArgs} args - Arguments to find a Categorias
     * @example
     * // Get one Categorias
     * const categorias = await prisma.categorias.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends categoriasFindUniqueArgs>(args: SelectSubset<T, categoriasFindUniqueArgs<ExtArgs>>): Prisma__categoriasClient<$Result.GetResult<Prisma.$categoriasPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Categorias that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {categoriasFindUniqueOrThrowArgs} args - Arguments to find a Categorias
     * @example
     * // Get one Categorias
     * const categorias = await prisma.categorias.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends categoriasFindUniqueOrThrowArgs>(args: SelectSubset<T, categoriasFindUniqueOrThrowArgs<ExtArgs>>): Prisma__categoriasClient<$Result.GetResult<Prisma.$categoriasPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Categorias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriasFindFirstArgs} args - Arguments to find a Categorias
     * @example
     * // Get one Categorias
     * const categorias = await prisma.categorias.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends categoriasFindFirstArgs>(args?: SelectSubset<T, categoriasFindFirstArgs<ExtArgs>>): Prisma__categoriasClient<$Result.GetResult<Prisma.$categoriasPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Categorias that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriasFindFirstOrThrowArgs} args - Arguments to find a Categorias
     * @example
     * // Get one Categorias
     * const categorias = await prisma.categorias.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends categoriasFindFirstOrThrowArgs>(args?: SelectSubset<T, categoriasFindFirstOrThrowArgs<ExtArgs>>): Prisma__categoriasClient<$Result.GetResult<Prisma.$categoriasPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Categorias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriasFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categorias
     * const categorias = await prisma.categorias.findMany()
     * 
     * // Get first 10 Categorias
     * const categorias = await prisma.categorias.findMany({ take: 10 })
     * 
     * // Only select the `id_categoria`
     * const categoriasWithId_categoriaOnly = await prisma.categorias.findMany({ select: { id_categoria: true } })
     * 
     */
    findMany<T extends categoriasFindManyArgs>(args?: SelectSubset<T, categoriasFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoriasPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Categorias.
     * @param {categoriasCreateArgs} args - Arguments to create a Categorias.
     * @example
     * // Create one Categorias
     * const Categorias = await prisma.categorias.create({
     *   data: {
     *     // ... data to create a Categorias
     *   }
     * })
     * 
     */
    create<T extends categoriasCreateArgs>(args: SelectSubset<T, categoriasCreateArgs<ExtArgs>>): Prisma__categoriasClient<$Result.GetResult<Prisma.$categoriasPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Categorias.
     * @param {categoriasCreateManyArgs} args - Arguments to create many Categorias.
     * @example
     * // Create many Categorias
     * const categorias = await prisma.categorias.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends categoriasCreateManyArgs>(args?: SelectSubset<T, categoriasCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categorias and returns the data saved in the database.
     * @param {categoriasCreateManyAndReturnArgs} args - Arguments to create many Categorias.
     * @example
     * // Create many Categorias
     * const categorias = await prisma.categorias.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categorias and only return the `id_categoria`
     * const categoriasWithId_categoriaOnly = await prisma.categorias.createManyAndReturn({ 
     *   select: { id_categoria: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends categoriasCreateManyAndReturnArgs>(args?: SelectSubset<T, categoriasCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoriasPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Categorias.
     * @param {categoriasDeleteArgs} args - Arguments to delete one Categorias.
     * @example
     * // Delete one Categorias
     * const Categorias = await prisma.categorias.delete({
     *   where: {
     *     // ... filter to delete one Categorias
     *   }
     * })
     * 
     */
    delete<T extends categoriasDeleteArgs>(args: SelectSubset<T, categoriasDeleteArgs<ExtArgs>>): Prisma__categoriasClient<$Result.GetResult<Prisma.$categoriasPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Categorias.
     * @param {categoriasUpdateArgs} args - Arguments to update one Categorias.
     * @example
     * // Update one Categorias
     * const categorias = await prisma.categorias.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends categoriasUpdateArgs>(args: SelectSubset<T, categoriasUpdateArgs<ExtArgs>>): Prisma__categoriasClient<$Result.GetResult<Prisma.$categoriasPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Categorias.
     * @param {categoriasDeleteManyArgs} args - Arguments to filter Categorias to delete.
     * @example
     * // Delete a few Categorias
     * const { count } = await prisma.categorias.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends categoriasDeleteManyArgs>(args?: SelectSubset<T, categoriasDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categorias
     * const categorias = await prisma.categorias.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends categoriasUpdateManyArgs>(args: SelectSubset<T, categoriasUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Categorias.
     * @param {categoriasUpsertArgs} args - Arguments to update or create a Categorias.
     * @example
     * // Update or create a Categorias
     * const categorias = await prisma.categorias.upsert({
     *   create: {
     *     // ... data to create a Categorias
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Categorias we want to update
     *   }
     * })
     */
    upsert<T extends categoriasUpsertArgs>(args: SelectSubset<T, categoriasUpsertArgs<ExtArgs>>): Prisma__categoriasClient<$Result.GetResult<Prisma.$categoriasPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Categorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriasCountArgs} args - Arguments to filter Categorias to count.
     * @example
     * // Count the number of Categorias
     * const count = await prisma.categorias.count({
     *   where: {
     *     // ... the filter for the Categorias we want to count
     *   }
     * })
    **/
    count<T extends categoriasCountArgs>(
      args?: Subset<T, categoriasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoriasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Categorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoriasAggregateArgs>(args: Subset<T, CategoriasAggregateArgs>): Prisma.PrismaPromise<GetCategoriasAggregateType<T>>

    /**
     * Group by Categorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends categoriasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: categoriasGroupByArgs['orderBy'] }
        : { orderBy?: categoriasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, categoriasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoriasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the categorias model
   */
  readonly fields: categoriasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for categorias.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__categoriasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    paquetes<T extends categorias$paquetesArgs<ExtArgs> = {}>(args?: Subset<T, categorias$paquetesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paquetesPayload<ExtArgs>, T, "findMany"> | Null>
    viajes<T extends categorias$viajesArgs<ExtArgs> = {}>(args?: Subset<T, categorias$viajesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$viajesPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the categorias model
   */ 
  interface categoriasFieldRefs {
    readonly id_categoria: FieldRef<"categorias", 'Int'>
    readonly nombre: FieldRef<"categorias", 'String'>
    readonly estado_auditoria: FieldRef<"categorias", 'String'>
    readonly fecha_creacion: FieldRef<"categorias", 'DateTime'>
    readonly fecha_modificacion: FieldRef<"categorias", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * categorias findUnique
   */
  export type categoriasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categorias
     */
    select?: categoriasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriasInclude<ExtArgs> | null
    /**
     * Filter, which categorias to fetch.
     */
    where: categoriasWhereUniqueInput
  }

  /**
   * categorias findUniqueOrThrow
   */
  export type categoriasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categorias
     */
    select?: categoriasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriasInclude<ExtArgs> | null
    /**
     * Filter, which categorias to fetch.
     */
    where: categoriasWhereUniqueInput
  }

  /**
   * categorias findFirst
   */
  export type categoriasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categorias
     */
    select?: categoriasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriasInclude<ExtArgs> | null
    /**
     * Filter, which categorias to fetch.
     */
    where?: categoriasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categorias to fetch.
     */
    orderBy?: categoriasOrderByWithRelationInput | categoriasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categorias.
     */
    cursor?: categoriasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categorias.
     */
    distinct?: CategoriasScalarFieldEnum | CategoriasScalarFieldEnum[]
  }

  /**
   * categorias findFirstOrThrow
   */
  export type categoriasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categorias
     */
    select?: categoriasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriasInclude<ExtArgs> | null
    /**
     * Filter, which categorias to fetch.
     */
    where?: categoriasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categorias to fetch.
     */
    orderBy?: categoriasOrderByWithRelationInput | categoriasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categorias.
     */
    cursor?: categoriasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categorias.
     */
    distinct?: CategoriasScalarFieldEnum | CategoriasScalarFieldEnum[]
  }

  /**
   * categorias findMany
   */
  export type categoriasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categorias
     */
    select?: categoriasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriasInclude<ExtArgs> | null
    /**
     * Filter, which categorias to fetch.
     */
    where?: categoriasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categorias to fetch.
     */
    orderBy?: categoriasOrderByWithRelationInput | categoriasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing categorias.
     */
    cursor?: categoriasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categorias.
     */
    skip?: number
    distinct?: CategoriasScalarFieldEnum | CategoriasScalarFieldEnum[]
  }

  /**
   * categorias create
   */
  export type categoriasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categorias
     */
    select?: categoriasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriasInclude<ExtArgs> | null
    /**
     * The data needed to create a categorias.
     */
    data: XOR<categoriasCreateInput, categoriasUncheckedCreateInput>
  }

  /**
   * categorias createMany
   */
  export type categoriasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many categorias.
     */
    data: categoriasCreateManyInput | categoriasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * categorias createManyAndReturn
   */
  export type categoriasCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categorias
     */
    select?: categoriasSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many categorias.
     */
    data: categoriasCreateManyInput | categoriasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * categorias update
   */
  export type categoriasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categorias
     */
    select?: categoriasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriasInclude<ExtArgs> | null
    /**
     * The data needed to update a categorias.
     */
    data: XOR<categoriasUpdateInput, categoriasUncheckedUpdateInput>
    /**
     * Choose, which categorias to update.
     */
    where: categoriasWhereUniqueInput
  }

  /**
   * categorias updateMany
   */
  export type categoriasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update categorias.
     */
    data: XOR<categoriasUpdateManyMutationInput, categoriasUncheckedUpdateManyInput>
    /**
     * Filter which categorias to update
     */
    where?: categoriasWhereInput
  }

  /**
   * categorias upsert
   */
  export type categoriasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categorias
     */
    select?: categoriasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriasInclude<ExtArgs> | null
    /**
     * The filter to search for the categorias to update in case it exists.
     */
    where: categoriasWhereUniqueInput
    /**
     * In case the categorias found by the `where` argument doesn't exist, create a new categorias with this data.
     */
    create: XOR<categoriasCreateInput, categoriasUncheckedCreateInput>
    /**
     * In case the categorias was found with the provided `where` argument, update it with this data.
     */
    update: XOR<categoriasUpdateInput, categoriasUncheckedUpdateInput>
  }

  /**
   * categorias delete
   */
  export type categoriasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categorias
     */
    select?: categoriasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriasInclude<ExtArgs> | null
    /**
     * Filter which categorias to delete.
     */
    where: categoriasWhereUniqueInput
  }

  /**
   * categorias deleteMany
   */
  export type categoriasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which categorias to delete
     */
    where?: categoriasWhereInput
  }

  /**
   * categorias.paquetes
   */
  export type categorias$paquetesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paquetes
     */
    select?: paquetesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paquetesInclude<ExtArgs> | null
    where?: paquetesWhereInput
    orderBy?: paquetesOrderByWithRelationInput | paquetesOrderByWithRelationInput[]
    cursor?: paquetesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaquetesScalarFieldEnum | PaquetesScalarFieldEnum[]
  }

  /**
   * categorias.viajes
   */
  export type categorias$viajesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viajes
     */
    select?: viajesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: viajesInclude<ExtArgs> | null
    where?: viajesWhereInput
    orderBy?: viajesOrderByWithRelationInput | viajesOrderByWithRelationInput[]
    cursor?: viajesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ViajesScalarFieldEnum | ViajesScalarFieldEnum[]
  }

  /**
   * categorias without action
   */
  export type categoriasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categorias
     */
    select?: categoriasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriasInclude<ExtArgs> | null
  }


  /**
   * Model paises
   */

  export type AggregatePaises = {
    _count: PaisesCountAggregateOutputType | null
    _avg: PaisesAvgAggregateOutputType | null
    _sum: PaisesSumAggregateOutputType | null
    _min: PaisesMinAggregateOutputType | null
    _max: PaisesMaxAggregateOutputType | null
  }

  export type PaisesAvgAggregateOutputType = {
    id_pais: number | null
  }

  export type PaisesSumAggregateOutputType = {
    id_pais: number | null
  }

  export type PaisesMinAggregateOutputType = {
    id_pais: number | null
    nombre: string | null
    estado_auditoria: string | null
    fecha_creacion: Date | null
    fecha_modificacion: Date | null
  }

  export type PaisesMaxAggregateOutputType = {
    id_pais: number | null
    nombre: string | null
    estado_auditoria: string | null
    fecha_creacion: Date | null
    fecha_modificacion: Date | null
  }

  export type PaisesCountAggregateOutputType = {
    id_pais: number
    nombre: number
    estado_auditoria: number
    fecha_creacion: number
    fecha_modificacion: number
    _all: number
  }


  export type PaisesAvgAggregateInputType = {
    id_pais?: true
  }

  export type PaisesSumAggregateInputType = {
    id_pais?: true
  }

  export type PaisesMinAggregateInputType = {
    id_pais?: true
    nombre?: true
    estado_auditoria?: true
    fecha_creacion?: true
    fecha_modificacion?: true
  }

  export type PaisesMaxAggregateInputType = {
    id_pais?: true
    nombre?: true
    estado_auditoria?: true
    fecha_creacion?: true
    fecha_modificacion?: true
  }

  export type PaisesCountAggregateInputType = {
    id_pais?: true
    nombre?: true
    estado_auditoria?: true
    fecha_creacion?: true
    fecha_modificacion?: true
    _all?: true
  }

  export type PaisesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which paises to aggregate.
     */
    where?: paisesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of paises to fetch.
     */
    orderBy?: paisesOrderByWithRelationInput | paisesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: paisesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` paises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` paises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned paises
    **/
    _count?: true | PaisesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaisesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaisesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaisesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaisesMaxAggregateInputType
  }

  export type GetPaisesAggregateType<T extends PaisesAggregateArgs> = {
        [P in keyof T & keyof AggregatePaises]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaises[P]>
      : GetScalarType<T[P], AggregatePaises[P]>
  }




  export type paisesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paisesWhereInput
    orderBy?: paisesOrderByWithAggregationInput | paisesOrderByWithAggregationInput[]
    by: PaisesScalarFieldEnum[] | PaisesScalarFieldEnum
    having?: paisesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaisesCountAggregateInputType | true
    _avg?: PaisesAvgAggregateInputType
    _sum?: PaisesSumAggregateInputType
    _min?: PaisesMinAggregateInputType
    _max?: PaisesMaxAggregateInputType
  }

  export type PaisesGroupByOutputType = {
    id_pais: number
    nombre: string
    estado_auditoria: string
    fecha_creacion: Date
    fecha_modificacion: Date | null
    _count: PaisesCountAggregateOutputType | null
    _avg: PaisesAvgAggregateOutputType | null
    _sum: PaisesSumAggregateOutputType | null
    _min: PaisesMinAggregateOutputType | null
    _max: PaisesMaxAggregateOutputType | null
  }

  type GetPaisesGroupByPayload<T extends paisesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaisesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaisesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaisesGroupByOutputType[P]>
            : GetScalarType<T[P], PaisesGroupByOutputType[P]>
        }
      >
    >


  export type paisesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_pais?: boolean
    nombre?: boolean
    estado_auditoria?: boolean
    fecha_creacion?: boolean
    fecha_modificacion?: boolean
    destinos?: boolean | paises$destinosArgs<ExtArgs>
    _count?: boolean | PaisesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paises"]>

  export type paisesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_pais?: boolean
    nombre?: boolean
    estado_auditoria?: boolean
    fecha_creacion?: boolean
    fecha_modificacion?: boolean
  }, ExtArgs["result"]["paises"]>

  export type paisesSelectScalar = {
    id_pais?: boolean
    nombre?: boolean
    estado_auditoria?: boolean
    fecha_creacion?: boolean
    fecha_modificacion?: boolean
  }

  export type paisesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    destinos?: boolean | paises$destinosArgs<ExtArgs>
    _count?: boolean | PaisesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type paisesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $paisesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "paises"
    objects: {
      destinos: Prisma.$destinosPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_pais: number
      nombre: string
      estado_auditoria: string
      fecha_creacion: Date
      fecha_modificacion: Date | null
    }, ExtArgs["result"]["paises"]>
    composites: {}
  }

  type paisesGetPayload<S extends boolean | null | undefined | paisesDefaultArgs> = $Result.GetResult<Prisma.$paisesPayload, S>

  type paisesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<paisesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaisesCountAggregateInputType | true
    }

  export interface paisesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['paises'], meta: { name: 'paises' } }
    /**
     * Find zero or one Paises that matches the filter.
     * @param {paisesFindUniqueArgs} args - Arguments to find a Paises
     * @example
     * // Get one Paises
     * const paises = await prisma.paises.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends paisesFindUniqueArgs>(args: SelectSubset<T, paisesFindUniqueArgs<ExtArgs>>): Prisma__paisesClient<$Result.GetResult<Prisma.$paisesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Paises that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {paisesFindUniqueOrThrowArgs} args - Arguments to find a Paises
     * @example
     * // Get one Paises
     * const paises = await prisma.paises.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends paisesFindUniqueOrThrowArgs>(args: SelectSubset<T, paisesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__paisesClient<$Result.GetResult<Prisma.$paisesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Paises that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paisesFindFirstArgs} args - Arguments to find a Paises
     * @example
     * // Get one Paises
     * const paises = await prisma.paises.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends paisesFindFirstArgs>(args?: SelectSubset<T, paisesFindFirstArgs<ExtArgs>>): Prisma__paisesClient<$Result.GetResult<Prisma.$paisesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Paises that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paisesFindFirstOrThrowArgs} args - Arguments to find a Paises
     * @example
     * // Get one Paises
     * const paises = await prisma.paises.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends paisesFindFirstOrThrowArgs>(args?: SelectSubset<T, paisesFindFirstOrThrowArgs<ExtArgs>>): Prisma__paisesClient<$Result.GetResult<Prisma.$paisesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Paises that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paisesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Paises
     * const paises = await prisma.paises.findMany()
     * 
     * // Get first 10 Paises
     * const paises = await prisma.paises.findMany({ take: 10 })
     * 
     * // Only select the `id_pais`
     * const paisesWithId_paisOnly = await prisma.paises.findMany({ select: { id_pais: true } })
     * 
     */
    findMany<T extends paisesFindManyArgs>(args?: SelectSubset<T, paisesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paisesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Paises.
     * @param {paisesCreateArgs} args - Arguments to create a Paises.
     * @example
     * // Create one Paises
     * const Paises = await prisma.paises.create({
     *   data: {
     *     // ... data to create a Paises
     *   }
     * })
     * 
     */
    create<T extends paisesCreateArgs>(args: SelectSubset<T, paisesCreateArgs<ExtArgs>>): Prisma__paisesClient<$Result.GetResult<Prisma.$paisesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Paises.
     * @param {paisesCreateManyArgs} args - Arguments to create many Paises.
     * @example
     * // Create many Paises
     * const paises = await prisma.paises.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends paisesCreateManyArgs>(args?: SelectSubset<T, paisesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Paises and returns the data saved in the database.
     * @param {paisesCreateManyAndReturnArgs} args - Arguments to create many Paises.
     * @example
     * // Create many Paises
     * const paises = await prisma.paises.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Paises and only return the `id_pais`
     * const paisesWithId_paisOnly = await prisma.paises.createManyAndReturn({ 
     *   select: { id_pais: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends paisesCreateManyAndReturnArgs>(args?: SelectSubset<T, paisesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paisesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Paises.
     * @param {paisesDeleteArgs} args - Arguments to delete one Paises.
     * @example
     * // Delete one Paises
     * const Paises = await prisma.paises.delete({
     *   where: {
     *     // ... filter to delete one Paises
     *   }
     * })
     * 
     */
    delete<T extends paisesDeleteArgs>(args: SelectSubset<T, paisesDeleteArgs<ExtArgs>>): Prisma__paisesClient<$Result.GetResult<Prisma.$paisesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Paises.
     * @param {paisesUpdateArgs} args - Arguments to update one Paises.
     * @example
     * // Update one Paises
     * const paises = await prisma.paises.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends paisesUpdateArgs>(args: SelectSubset<T, paisesUpdateArgs<ExtArgs>>): Prisma__paisesClient<$Result.GetResult<Prisma.$paisesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Paises.
     * @param {paisesDeleteManyArgs} args - Arguments to filter Paises to delete.
     * @example
     * // Delete a few Paises
     * const { count } = await prisma.paises.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends paisesDeleteManyArgs>(args?: SelectSubset<T, paisesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Paises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paisesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Paises
     * const paises = await prisma.paises.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends paisesUpdateManyArgs>(args: SelectSubset<T, paisesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Paises.
     * @param {paisesUpsertArgs} args - Arguments to update or create a Paises.
     * @example
     * // Update or create a Paises
     * const paises = await prisma.paises.upsert({
     *   create: {
     *     // ... data to create a Paises
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Paises we want to update
     *   }
     * })
     */
    upsert<T extends paisesUpsertArgs>(args: SelectSubset<T, paisesUpsertArgs<ExtArgs>>): Prisma__paisesClient<$Result.GetResult<Prisma.$paisesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Paises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paisesCountArgs} args - Arguments to filter Paises to count.
     * @example
     * // Count the number of Paises
     * const count = await prisma.paises.count({
     *   where: {
     *     // ... the filter for the Paises we want to count
     *   }
     * })
    **/
    count<T extends paisesCountArgs>(
      args?: Subset<T, paisesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaisesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Paises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaisesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaisesAggregateArgs>(args: Subset<T, PaisesAggregateArgs>): Prisma.PrismaPromise<GetPaisesAggregateType<T>>

    /**
     * Group by Paises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paisesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends paisesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: paisesGroupByArgs['orderBy'] }
        : { orderBy?: paisesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, paisesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaisesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the paises model
   */
  readonly fields: paisesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for paises.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__paisesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    destinos<T extends paises$destinosArgs<ExtArgs> = {}>(args?: Subset<T, paises$destinosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$destinosPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the paises model
   */ 
  interface paisesFieldRefs {
    readonly id_pais: FieldRef<"paises", 'Int'>
    readonly nombre: FieldRef<"paises", 'String'>
    readonly estado_auditoria: FieldRef<"paises", 'String'>
    readonly fecha_creacion: FieldRef<"paises", 'DateTime'>
    readonly fecha_modificacion: FieldRef<"paises", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * paises findUnique
   */
  export type paisesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paises
     */
    select?: paisesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paisesInclude<ExtArgs> | null
    /**
     * Filter, which paises to fetch.
     */
    where: paisesWhereUniqueInput
  }

  /**
   * paises findUniqueOrThrow
   */
  export type paisesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paises
     */
    select?: paisesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paisesInclude<ExtArgs> | null
    /**
     * Filter, which paises to fetch.
     */
    where: paisesWhereUniqueInput
  }

  /**
   * paises findFirst
   */
  export type paisesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paises
     */
    select?: paisesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paisesInclude<ExtArgs> | null
    /**
     * Filter, which paises to fetch.
     */
    where?: paisesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of paises to fetch.
     */
    orderBy?: paisesOrderByWithRelationInput | paisesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for paises.
     */
    cursor?: paisesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` paises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` paises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of paises.
     */
    distinct?: PaisesScalarFieldEnum | PaisesScalarFieldEnum[]
  }

  /**
   * paises findFirstOrThrow
   */
  export type paisesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paises
     */
    select?: paisesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paisesInclude<ExtArgs> | null
    /**
     * Filter, which paises to fetch.
     */
    where?: paisesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of paises to fetch.
     */
    orderBy?: paisesOrderByWithRelationInput | paisesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for paises.
     */
    cursor?: paisesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` paises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` paises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of paises.
     */
    distinct?: PaisesScalarFieldEnum | PaisesScalarFieldEnum[]
  }

  /**
   * paises findMany
   */
  export type paisesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paises
     */
    select?: paisesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paisesInclude<ExtArgs> | null
    /**
     * Filter, which paises to fetch.
     */
    where?: paisesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of paises to fetch.
     */
    orderBy?: paisesOrderByWithRelationInput | paisesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing paises.
     */
    cursor?: paisesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` paises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` paises.
     */
    skip?: number
    distinct?: PaisesScalarFieldEnum | PaisesScalarFieldEnum[]
  }

  /**
   * paises create
   */
  export type paisesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paises
     */
    select?: paisesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paisesInclude<ExtArgs> | null
    /**
     * The data needed to create a paises.
     */
    data: XOR<paisesCreateInput, paisesUncheckedCreateInput>
  }

  /**
   * paises createMany
   */
  export type paisesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many paises.
     */
    data: paisesCreateManyInput | paisesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * paises createManyAndReturn
   */
  export type paisesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paises
     */
    select?: paisesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many paises.
     */
    data: paisesCreateManyInput | paisesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * paises update
   */
  export type paisesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paises
     */
    select?: paisesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paisesInclude<ExtArgs> | null
    /**
     * The data needed to update a paises.
     */
    data: XOR<paisesUpdateInput, paisesUncheckedUpdateInput>
    /**
     * Choose, which paises to update.
     */
    where: paisesWhereUniqueInput
  }

  /**
   * paises updateMany
   */
  export type paisesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update paises.
     */
    data: XOR<paisesUpdateManyMutationInput, paisesUncheckedUpdateManyInput>
    /**
     * Filter which paises to update
     */
    where?: paisesWhereInput
  }

  /**
   * paises upsert
   */
  export type paisesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paises
     */
    select?: paisesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paisesInclude<ExtArgs> | null
    /**
     * The filter to search for the paises to update in case it exists.
     */
    where: paisesWhereUniqueInput
    /**
     * In case the paises found by the `where` argument doesn't exist, create a new paises with this data.
     */
    create: XOR<paisesCreateInput, paisesUncheckedCreateInput>
    /**
     * In case the paises was found with the provided `where` argument, update it with this data.
     */
    update: XOR<paisesUpdateInput, paisesUncheckedUpdateInput>
  }

  /**
   * paises delete
   */
  export type paisesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paises
     */
    select?: paisesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paisesInclude<ExtArgs> | null
    /**
     * Filter which paises to delete.
     */
    where: paisesWhereUniqueInput
  }

  /**
   * paises deleteMany
   */
  export type paisesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which paises to delete
     */
    where?: paisesWhereInput
  }

  /**
   * paises.destinos
   */
  export type paises$destinosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the destinos
     */
    select?: destinosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: destinosInclude<ExtArgs> | null
    where?: destinosWhereInput
    orderBy?: destinosOrderByWithRelationInput | destinosOrderByWithRelationInput[]
    cursor?: destinosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DestinosScalarFieldEnum | DestinosScalarFieldEnum[]
  }

  /**
   * paises without action
   */
  export type paisesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paises
     */
    select?: paisesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paisesInclude<ExtArgs> | null
  }


  /**
   * Model paquetes
   */

  export type AggregatePaquetes = {
    _count: PaquetesCountAggregateOutputType | null
    _avg: PaquetesAvgAggregateOutputType | null
    _sum: PaquetesSumAggregateOutputType | null
    _min: PaquetesMinAggregateOutputType | null
    _max: PaquetesMaxAggregateOutputType | null
  }

  export type PaquetesAvgAggregateOutputType = {
    id_paquete: number | null
    id_hospedaje: number | null
    id_categoria: number | null
    precio: Decimal | null
  }

  export type PaquetesSumAggregateOutputType = {
    id_paquete: number | null
    id_hospedaje: number | null
    id_categoria: number | null
    precio: Decimal | null
  }

  export type PaquetesMinAggregateOutputType = {
    id_paquete: number | null
    id_hospedaje: number | null
    id_categoria: number | null
    nombre: string | null
    transporte: string | null
    precio: Decimal | null
    estado_auditoria: string | null
    fecha_modificacion: Date | null
    fecha_creacion: Date | null
  }

  export type PaquetesMaxAggregateOutputType = {
    id_paquete: number | null
    id_hospedaje: number | null
    id_categoria: number | null
    nombre: string | null
    transporte: string | null
    precio: Decimal | null
    estado_auditoria: string | null
    fecha_modificacion: Date | null
    fecha_creacion: Date | null
  }

  export type PaquetesCountAggregateOutputType = {
    id_paquete: number
    id_hospedaje: number
    id_categoria: number
    nombre: number
    transporte: number
    precio: number
    estado_auditoria: number
    fecha_modificacion: number
    fecha_creacion: number
    _all: number
  }


  export type PaquetesAvgAggregateInputType = {
    id_paquete?: true
    id_hospedaje?: true
    id_categoria?: true
    precio?: true
  }

  export type PaquetesSumAggregateInputType = {
    id_paquete?: true
    id_hospedaje?: true
    id_categoria?: true
    precio?: true
  }

  export type PaquetesMinAggregateInputType = {
    id_paquete?: true
    id_hospedaje?: true
    id_categoria?: true
    nombre?: true
    transporte?: true
    precio?: true
    estado_auditoria?: true
    fecha_modificacion?: true
    fecha_creacion?: true
  }

  export type PaquetesMaxAggregateInputType = {
    id_paquete?: true
    id_hospedaje?: true
    id_categoria?: true
    nombre?: true
    transporte?: true
    precio?: true
    estado_auditoria?: true
    fecha_modificacion?: true
    fecha_creacion?: true
  }

  export type PaquetesCountAggregateInputType = {
    id_paquete?: true
    id_hospedaje?: true
    id_categoria?: true
    nombre?: true
    transporte?: true
    precio?: true
    estado_auditoria?: true
    fecha_modificacion?: true
    fecha_creacion?: true
    _all?: true
  }

  export type PaquetesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which paquetes to aggregate.
     */
    where?: paquetesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of paquetes to fetch.
     */
    orderBy?: paquetesOrderByWithRelationInput | paquetesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: paquetesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` paquetes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` paquetes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned paquetes
    **/
    _count?: true | PaquetesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaquetesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaquetesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaquetesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaquetesMaxAggregateInputType
  }

  export type GetPaquetesAggregateType<T extends PaquetesAggregateArgs> = {
        [P in keyof T & keyof AggregatePaquetes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaquetes[P]>
      : GetScalarType<T[P], AggregatePaquetes[P]>
  }




  export type paquetesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paquetesWhereInput
    orderBy?: paquetesOrderByWithAggregationInput | paquetesOrderByWithAggregationInput[]
    by: PaquetesScalarFieldEnum[] | PaquetesScalarFieldEnum
    having?: paquetesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaquetesCountAggregateInputType | true
    _avg?: PaquetesAvgAggregateInputType
    _sum?: PaquetesSumAggregateInputType
    _min?: PaquetesMinAggregateInputType
    _max?: PaquetesMaxAggregateInputType
  }

  export type PaquetesGroupByOutputType = {
    id_paquete: number
    id_hospedaje: number
    id_categoria: number
    nombre: string
    transporte: string
    precio: Decimal
    estado_auditoria: string
    fecha_modificacion: Date
    fecha_creacion: Date | null
    _count: PaquetesCountAggregateOutputType | null
    _avg: PaquetesAvgAggregateOutputType | null
    _sum: PaquetesSumAggregateOutputType | null
    _min: PaquetesMinAggregateOutputType | null
    _max: PaquetesMaxAggregateOutputType | null
  }

  type GetPaquetesGroupByPayload<T extends paquetesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaquetesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaquetesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaquetesGroupByOutputType[P]>
            : GetScalarType<T[P], PaquetesGroupByOutputType[P]>
        }
      >
    >


  export type paquetesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_paquete?: boolean
    id_hospedaje?: boolean
    id_categoria?: boolean
    nombre?: boolean
    transporte?: boolean
    precio?: boolean
    estado_auditoria?: boolean
    fecha_modificacion?: boolean
    fecha_creacion?: boolean
    categorias?: boolean | categoriasDefaultArgs<ExtArgs>
    hospedajes?: boolean | hospedajesDefaultArgs<ExtArgs>
    viajes?: boolean | paquetes$viajesArgs<ExtArgs>
    _count?: boolean | PaquetesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paquetes"]>

  export type paquetesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_paquete?: boolean
    id_hospedaje?: boolean
    id_categoria?: boolean
    nombre?: boolean
    transporte?: boolean
    precio?: boolean
    estado_auditoria?: boolean
    fecha_modificacion?: boolean
    fecha_creacion?: boolean
    categorias?: boolean | categoriasDefaultArgs<ExtArgs>
    hospedajes?: boolean | hospedajesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paquetes"]>

  export type paquetesSelectScalar = {
    id_paquete?: boolean
    id_hospedaje?: boolean
    id_categoria?: boolean
    nombre?: boolean
    transporte?: boolean
    precio?: boolean
    estado_auditoria?: boolean
    fecha_modificacion?: boolean
    fecha_creacion?: boolean
  }

  export type paquetesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categorias?: boolean | categoriasDefaultArgs<ExtArgs>
    hospedajes?: boolean | hospedajesDefaultArgs<ExtArgs>
    viajes?: boolean | paquetes$viajesArgs<ExtArgs>
    _count?: boolean | PaquetesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type paquetesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categorias?: boolean | categoriasDefaultArgs<ExtArgs>
    hospedajes?: boolean | hospedajesDefaultArgs<ExtArgs>
  }

  export type $paquetesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "paquetes"
    objects: {
      categorias: Prisma.$categoriasPayload<ExtArgs>
      hospedajes: Prisma.$hospedajesPayload<ExtArgs>
      viajes: Prisma.$viajesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_paquete: number
      id_hospedaje: number
      id_categoria: number
      nombre: string
      transporte: string
      precio: Prisma.Decimal
      estado_auditoria: string
      fecha_modificacion: Date
      fecha_creacion: Date | null
    }, ExtArgs["result"]["paquetes"]>
    composites: {}
  }

  type paquetesGetPayload<S extends boolean | null | undefined | paquetesDefaultArgs> = $Result.GetResult<Prisma.$paquetesPayload, S>

  type paquetesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<paquetesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaquetesCountAggregateInputType | true
    }

  export interface paquetesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['paquetes'], meta: { name: 'paquetes' } }
    /**
     * Find zero or one Paquetes that matches the filter.
     * @param {paquetesFindUniqueArgs} args - Arguments to find a Paquetes
     * @example
     * // Get one Paquetes
     * const paquetes = await prisma.paquetes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends paquetesFindUniqueArgs>(args: SelectSubset<T, paquetesFindUniqueArgs<ExtArgs>>): Prisma__paquetesClient<$Result.GetResult<Prisma.$paquetesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Paquetes that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {paquetesFindUniqueOrThrowArgs} args - Arguments to find a Paquetes
     * @example
     * // Get one Paquetes
     * const paquetes = await prisma.paquetes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends paquetesFindUniqueOrThrowArgs>(args: SelectSubset<T, paquetesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__paquetesClient<$Result.GetResult<Prisma.$paquetesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Paquetes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paquetesFindFirstArgs} args - Arguments to find a Paquetes
     * @example
     * // Get one Paquetes
     * const paquetes = await prisma.paquetes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends paquetesFindFirstArgs>(args?: SelectSubset<T, paquetesFindFirstArgs<ExtArgs>>): Prisma__paquetesClient<$Result.GetResult<Prisma.$paquetesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Paquetes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paquetesFindFirstOrThrowArgs} args - Arguments to find a Paquetes
     * @example
     * // Get one Paquetes
     * const paquetes = await prisma.paquetes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends paquetesFindFirstOrThrowArgs>(args?: SelectSubset<T, paquetesFindFirstOrThrowArgs<ExtArgs>>): Prisma__paquetesClient<$Result.GetResult<Prisma.$paquetesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Paquetes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paquetesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Paquetes
     * const paquetes = await prisma.paquetes.findMany()
     * 
     * // Get first 10 Paquetes
     * const paquetes = await prisma.paquetes.findMany({ take: 10 })
     * 
     * // Only select the `id_paquete`
     * const paquetesWithId_paqueteOnly = await prisma.paquetes.findMany({ select: { id_paquete: true } })
     * 
     */
    findMany<T extends paquetesFindManyArgs>(args?: SelectSubset<T, paquetesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paquetesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Paquetes.
     * @param {paquetesCreateArgs} args - Arguments to create a Paquetes.
     * @example
     * // Create one Paquetes
     * const Paquetes = await prisma.paquetes.create({
     *   data: {
     *     // ... data to create a Paquetes
     *   }
     * })
     * 
     */
    create<T extends paquetesCreateArgs>(args: SelectSubset<T, paquetesCreateArgs<ExtArgs>>): Prisma__paquetesClient<$Result.GetResult<Prisma.$paquetesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Paquetes.
     * @param {paquetesCreateManyArgs} args - Arguments to create many Paquetes.
     * @example
     * // Create many Paquetes
     * const paquetes = await prisma.paquetes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends paquetesCreateManyArgs>(args?: SelectSubset<T, paquetesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Paquetes and returns the data saved in the database.
     * @param {paquetesCreateManyAndReturnArgs} args - Arguments to create many Paquetes.
     * @example
     * // Create many Paquetes
     * const paquetes = await prisma.paquetes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Paquetes and only return the `id_paquete`
     * const paquetesWithId_paqueteOnly = await prisma.paquetes.createManyAndReturn({ 
     *   select: { id_paquete: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends paquetesCreateManyAndReturnArgs>(args?: SelectSubset<T, paquetesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paquetesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Paquetes.
     * @param {paquetesDeleteArgs} args - Arguments to delete one Paquetes.
     * @example
     * // Delete one Paquetes
     * const Paquetes = await prisma.paquetes.delete({
     *   where: {
     *     // ... filter to delete one Paquetes
     *   }
     * })
     * 
     */
    delete<T extends paquetesDeleteArgs>(args: SelectSubset<T, paquetesDeleteArgs<ExtArgs>>): Prisma__paquetesClient<$Result.GetResult<Prisma.$paquetesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Paquetes.
     * @param {paquetesUpdateArgs} args - Arguments to update one Paquetes.
     * @example
     * // Update one Paquetes
     * const paquetes = await prisma.paquetes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends paquetesUpdateArgs>(args: SelectSubset<T, paquetesUpdateArgs<ExtArgs>>): Prisma__paquetesClient<$Result.GetResult<Prisma.$paquetesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Paquetes.
     * @param {paquetesDeleteManyArgs} args - Arguments to filter Paquetes to delete.
     * @example
     * // Delete a few Paquetes
     * const { count } = await prisma.paquetes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends paquetesDeleteManyArgs>(args?: SelectSubset<T, paquetesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Paquetes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paquetesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Paquetes
     * const paquetes = await prisma.paquetes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends paquetesUpdateManyArgs>(args: SelectSubset<T, paquetesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Paquetes.
     * @param {paquetesUpsertArgs} args - Arguments to update or create a Paquetes.
     * @example
     * // Update or create a Paquetes
     * const paquetes = await prisma.paquetes.upsert({
     *   create: {
     *     // ... data to create a Paquetes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Paquetes we want to update
     *   }
     * })
     */
    upsert<T extends paquetesUpsertArgs>(args: SelectSubset<T, paquetesUpsertArgs<ExtArgs>>): Prisma__paquetesClient<$Result.GetResult<Prisma.$paquetesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Paquetes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paquetesCountArgs} args - Arguments to filter Paquetes to count.
     * @example
     * // Count the number of Paquetes
     * const count = await prisma.paquetes.count({
     *   where: {
     *     // ... the filter for the Paquetes we want to count
     *   }
     * })
    **/
    count<T extends paquetesCountArgs>(
      args?: Subset<T, paquetesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaquetesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Paquetes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaquetesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaquetesAggregateArgs>(args: Subset<T, PaquetesAggregateArgs>): Prisma.PrismaPromise<GetPaquetesAggregateType<T>>

    /**
     * Group by Paquetes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paquetesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends paquetesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: paquetesGroupByArgs['orderBy'] }
        : { orderBy?: paquetesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, paquetesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaquetesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the paquetes model
   */
  readonly fields: paquetesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for paquetes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__paquetesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    categorias<T extends categoriasDefaultArgs<ExtArgs> = {}>(args?: Subset<T, categoriasDefaultArgs<ExtArgs>>): Prisma__categoriasClient<$Result.GetResult<Prisma.$categoriasPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    hospedajes<T extends hospedajesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, hospedajesDefaultArgs<ExtArgs>>): Prisma__hospedajesClient<$Result.GetResult<Prisma.$hospedajesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    viajes<T extends paquetes$viajesArgs<ExtArgs> = {}>(args?: Subset<T, paquetes$viajesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$viajesPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the paquetes model
   */ 
  interface paquetesFieldRefs {
    readonly id_paquete: FieldRef<"paquetes", 'Int'>
    readonly id_hospedaje: FieldRef<"paquetes", 'Int'>
    readonly id_categoria: FieldRef<"paquetes", 'Int'>
    readonly nombre: FieldRef<"paquetes", 'String'>
    readonly transporte: FieldRef<"paquetes", 'String'>
    readonly precio: FieldRef<"paquetes", 'Decimal'>
    readonly estado_auditoria: FieldRef<"paquetes", 'String'>
    readonly fecha_modificacion: FieldRef<"paquetes", 'DateTime'>
    readonly fecha_creacion: FieldRef<"paquetes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * paquetes findUnique
   */
  export type paquetesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paquetes
     */
    select?: paquetesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paquetesInclude<ExtArgs> | null
    /**
     * Filter, which paquetes to fetch.
     */
    where: paquetesWhereUniqueInput
  }

  /**
   * paquetes findUniqueOrThrow
   */
  export type paquetesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paquetes
     */
    select?: paquetesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paquetesInclude<ExtArgs> | null
    /**
     * Filter, which paquetes to fetch.
     */
    where: paquetesWhereUniqueInput
  }

  /**
   * paquetes findFirst
   */
  export type paquetesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paquetes
     */
    select?: paquetesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paquetesInclude<ExtArgs> | null
    /**
     * Filter, which paquetes to fetch.
     */
    where?: paquetesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of paquetes to fetch.
     */
    orderBy?: paquetesOrderByWithRelationInput | paquetesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for paquetes.
     */
    cursor?: paquetesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` paquetes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` paquetes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of paquetes.
     */
    distinct?: PaquetesScalarFieldEnum | PaquetesScalarFieldEnum[]
  }

  /**
   * paquetes findFirstOrThrow
   */
  export type paquetesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paquetes
     */
    select?: paquetesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paquetesInclude<ExtArgs> | null
    /**
     * Filter, which paquetes to fetch.
     */
    where?: paquetesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of paquetes to fetch.
     */
    orderBy?: paquetesOrderByWithRelationInput | paquetesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for paquetes.
     */
    cursor?: paquetesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` paquetes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` paquetes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of paquetes.
     */
    distinct?: PaquetesScalarFieldEnum | PaquetesScalarFieldEnum[]
  }

  /**
   * paquetes findMany
   */
  export type paquetesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paquetes
     */
    select?: paquetesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paquetesInclude<ExtArgs> | null
    /**
     * Filter, which paquetes to fetch.
     */
    where?: paquetesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of paquetes to fetch.
     */
    orderBy?: paquetesOrderByWithRelationInput | paquetesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing paquetes.
     */
    cursor?: paquetesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` paquetes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` paquetes.
     */
    skip?: number
    distinct?: PaquetesScalarFieldEnum | PaquetesScalarFieldEnum[]
  }

  /**
   * paquetes create
   */
  export type paquetesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paquetes
     */
    select?: paquetesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paquetesInclude<ExtArgs> | null
    /**
     * The data needed to create a paquetes.
     */
    data: XOR<paquetesCreateInput, paquetesUncheckedCreateInput>
  }

  /**
   * paquetes createMany
   */
  export type paquetesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many paquetes.
     */
    data: paquetesCreateManyInput | paquetesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * paquetes createManyAndReturn
   */
  export type paquetesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paquetes
     */
    select?: paquetesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many paquetes.
     */
    data: paquetesCreateManyInput | paquetesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paquetesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * paquetes update
   */
  export type paquetesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paquetes
     */
    select?: paquetesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paquetesInclude<ExtArgs> | null
    /**
     * The data needed to update a paquetes.
     */
    data: XOR<paquetesUpdateInput, paquetesUncheckedUpdateInput>
    /**
     * Choose, which paquetes to update.
     */
    where: paquetesWhereUniqueInput
  }

  /**
   * paquetes updateMany
   */
  export type paquetesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update paquetes.
     */
    data: XOR<paquetesUpdateManyMutationInput, paquetesUncheckedUpdateManyInput>
    /**
     * Filter which paquetes to update
     */
    where?: paquetesWhereInput
  }

  /**
   * paquetes upsert
   */
  export type paquetesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paquetes
     */
    select?: paquetesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paquetesInclude<ExtArgs> | null
    /**
     * The filter to search for the paquetes to update in case it exists.
     */
    where: paquetesWhereUniqueInput
    /**
     * In case the paquetes found by the `where` argument doesn't exist, create a new paquetes with this data.
     */
    create: XOR<paquetesCreateInput, paquetesUncheckedCreateInput>
    /**
     * In case the paquetes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<paquetesUpdateInput, paquetesUncheckedUpdateInput>
  }

  /**
   * paquetes delete
   */
  export type paquetesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paquetes
     */
    select?: paquetesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paquetesInclude<ExtArgs> | null
    /**
     * Filter which paquetes to delete.
     */
    where: paquetesWhereUniqueInput
  }

  /**
   * paquetes deleteMany
   */
  export type paquetesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which paquetes to delete
     */
    where?: paquetesWhereInput
  }

  /**
   * paquetes.viajes
   */
  export type paquetes$viajesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viajes
     */
    select?: viajesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: viajesInclude<ExtArgs> | null
    where?: viajesWhereInput
    orderBy?: viajesOrderByWithRelationInput | viajesOrderByWithRelationInput[]
    cursor?: viajesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ViajesScalarFieldEnum | ViajesScalarFieldEnum[]
  }

  /**
   * paquetes without action
   */
  export type paquetesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paquetes
     */
    select?: paquetesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paquetesInclude<ExtArgs> | null
  }


  /**
   * Model roles
   */

  export type AggregateRoles = {
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  export type RolesAvgAggregateOutputType = {
    id_rol: number | null
  }

  export type RolesSumAggregateOutputType = {
    id_rol: number | null
  }

  export type RolesMinAggregateOutputType = {
    id_rol: number | null
    nombre: string | null
    estado_auditoria: string | null
    fecha_creacion: Date | null
    fecha_modificacion: Date | null
  }

  export type RolesMaxAggregateOutputType = {
    id_rol: number | null
    nombre: string | null
    estado_auditoria: string | null
    fecha_creacion: Date | null
    fecha_modificacion: Date | null
  }

  export type RolesCountAggregateOutputType = {
    id_rol: number
    nombre: number
    estado_auditoria: number
    fecha_creacion: number
    fecha_modificacion: number
    _all: number
  }


  export type RolesAvgAggregateInputType = {
    id_rol?: true
  }

  export type RolesSumAggregateInputType = {
    id_rol?: true
  }

  export type RolesMinAggregateInputType = {
    id_rol?: true
    nombre?: true
    estado_auditoria?: true
    fecha_creacion?: true
    fecha_modificacion?: true
  }

  export type RolesMaxAggregateInputType = {
    id_rol?: true
    nombre?: true
    estado_auditoria?: true
    fecha_creacion?: true
    fecha_modificacion?: true
  }

  export type RolesCountAggregateInputType = {
    id_rol?: true
    nombre?: true
    estado_auditoria?: true
    fecha_creacion?: true
    fecha_modificacion?: true
    _all?: true
  }

  export type RolesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which roles to aggregate.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned roles
    **/
    _count?: true | RolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolesMaxAggregateInputType
  }

  export type GetRolesAggregateType<T extends RolesAggregateArgs> = {
        [P in keyof T & keyof AggregateRoles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoles[P]>
      : GetScalarType<T[P], AggregateRoles[P]>
  }




  export type rolesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rolesWhereInput
    orderBy?: rolesOrderByWithAggregationInput | rolesOrderByWithAggregationInput[]
    by: RolesScalarFieldEnum[] | RolesScalarFieldEnum
    having?: rolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolesCountAggregateInputType | true
    _avg?: RolesAvgAggregateInputType
    _sum?: RolesSumAggregateInputType
    _min?: RolesMinAggregateInputType
    _max?: RolesMaxAggregateInputType
  }

  export type RolesGroupByOutputType = {
    id_rol: number
    nombre: string
    estado_auditoria: string
    fecha_creacion: Date
    fecha_modificacion: Date | null
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  type GetRolesGroupByPayload<T extends rolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolesGroupByOutputType[P]>
            : GetScalarType<T[P], RolesGroupByOutputType[P]>
        }
      >
    >


  export type rolesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_rol?: boolean
    nombre?: boolean
    estado_auditoria?: boolean
    fecha_creacion?: boolean
    fecha_modificacion?: boolean
    usuarios?: boolean | roles$usuariosArgs<ExtArgs>
    _count?: boolean | RolesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roles"]>

  export type rolesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_rol?: boolean
    nombre?: boolean
    estado_auditoria?: boolean
    fecha_creacion?: boolean
    fecha_modificacion?: boolean
  }, ExtArgs["result"]["roles"]>

  export type rolesSelectScalar = {
    id_rol?: boolean
    nombre?: boolean
    estado_auditoria?: boolean
    fecha_creacion?: boolean
    fecha_modificacion?: boolean
  }

  export type rolesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuarios?: boolean | roles$usuariosArgs<ExtArgs>
    _count?: boolean | RolesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type rolesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $rolesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "roles"
    objects: {
      usuarios: Prisma.$usuariosPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_rol: number
      nombre: string
      estado_auditoria: string
      fecha_creacion: Date
      fecha_modificacion: Date | null
    }, ExtArgs["result"]["roles"]>
    composites: {}
  }

  type rolesGetPayload<S extends boolean | null | undefined | rolesDefaultArgs> = $Result.GetResult<Prisma.$rolesPayload, S>

  type rolesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<rolesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RolesCountAggregateInputType | true
    }

  export interface rolesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['roles'], meta: { name: 'roles' } }
    /**
     * Find zero or one Roles that matches the filter.
     * @param {rolesFindUniqueArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends rolesFindUniqueArgs>(args: SelectSubset<T, rolesFindUniqueArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Roles that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {rolesFindUniqueOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends rolesFindUniqueOrThrowArgs>(args: SelectSubset<T, rolesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesFindFirstArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends rolesFindFirstArgs>(args?: SelectSubset<T, rolesFindFirstArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Roles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesFindFirstOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends rolesFindFirstOrThrowArgs>(args?: SelectSubset<T, rolesFindFirstOrThrowArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.roles.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.roles.findMany({ take: 10 })
     * 
     * // Only select the `id_rol`
     * const rolesWithId_rolOnly = await prisma.roles.findMany({ select: { id_rol: true } })
     * 
     */
    findMany<T extends rolesFindManyArgs>(args?: SelectSubset<T, rolesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Roles.
     * @param {rolesCreateArgs} args - Arguments to create a Roles.
     * @example
     * // Create one Roles
     * const Roles = await prisma.roles.create({
     *   data: {
     *     // ... data to create a Roles
     *   }
     * })
     * 
     */
    create<T extends rolesCreateArgs>(args: SelectSubset<T, rolesCreateArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Roles.
     * @param {rolesCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const roles = await prisma.roles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends rolesCreateManyArgs>(args?: SelectSubset<T, rolesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {rolesCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const roles = await prisma.roles.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id_rol`
     * const rolesWithId_rolOnly = await prisma.roles.createManyAndReturn({ 
     *   select: { id_rol: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends rolesCreateManyAndReturnArgs>(args?: SelectSubset<T, rolesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Roles.
     * @param {rolesDeleteArgs} args - Arguments to delete one Roles.
     * @example
     * // Delete one Roles
     * const Roles = await prisma.roles.delete({
     *   where: {
     *     // ... filter to delete one Roles
     *   }
     * })
     * 
     */
    delete<T extends rolesDeleteArgs>(args: SelectSubset<T, rolesDeleteArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Roles.
     * @param {rolesUpdateArgs} args - Arguments to update one Roles.
     * @example
     * // Update one Roles
     * const roles = await prisma.roles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends rolesUpdateArgs>(args: SelectSubset<T, rolesUpdateArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Roles.
     * @param {rolesDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.roles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends rolesDeleteManyArgs>(args?: SelectSubset<T, rolesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const roles = await prisma.roles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends rolesUpdateManyArgs>(args: SelectSubset<T, rolesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Roles.
     * @param {rolesUpsertArgs} args - Arguments to update or create a Roles.
     * @example
     * // Update or create a Roles
     * const roles = await prisma.roles.upsert({
     *   create: {
     *     // ... data to create a Roles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Roles we want to update
     *   }
     * })
     */
    upsert<T extends rolesUpsertArgs>(args: SelectSubset<T, rolesUpsertArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.roles.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends rolesCountArgs>(
      args?: Subset<T, rolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolesAggregateArgs>(args: Subset<T, RolesAggregateArgs>): Prisma.PrismaPromise<GetRolesAggregateType<T>>

    /**
     * Group by Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends rolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: rolesGroupByArgs['orderBy'] }
        : { orderBy?: rolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, rolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the roles model
   */
  readonly fields: rolesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for roles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__rolesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuarios<T extends roles$usuariosArgs<ExtArgs> = {}>(args?: Subset<T, roles$usuariosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usuariosPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the roles model
   */ 
  interface rolesFieldRefs {
    readonly id_rol: FieldRef<"roles", 'Int'>
    readonly nombre: FieldRef<"roles", 'String'>
    readonly estado_auditoria: FieldRef<"roles", 'String'>
    readonly fecha_creacion: FieldRef<"roles", 'DateTime'>
    readonly fecha_modificacion: FieldRef<"roles", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * roles findUnique
   */
  export type rolesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles findUniqueOrThrow
   */
  export type rolesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles findFirst
   */
  export type rolesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * roles findFirstOrThrow
   */
  export type rolesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * roles findMany
   */
  export type rolesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing roles.
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * roles create
   */
  export type rolesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * The data needed to create a roles.
     */
    data: XOR<rolesCreateInput, rolesUncheckedCreateInput>
  }

  /**
   * roles createMany
   */
  export type rolesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many roles.
     */
    data: rolesCreateManyInput | rolesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * roles createManyAndReturn
   */
  export type rolesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many roles.
     */
    data: rolesCreateManyInput | rolesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * roles update
   */
  export type rolesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * The data needed to update a roles.
     */
    data: XOR<rolesUpdateInput, rolesUncheckedUpdateInput>
    /**
     * Choose, which roles to update.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles updateMany
   */
  export type rolesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update roles.
     */
    data: XOR<rolesUpdateManyMutationInput, rolesUncheckedUpdateManyInput>
    /**
     * Filter which roles to update
     */
    where?: rolesWhereInput
  }

  /**
   * roles upsert
   */
  export type rolesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * The filter to search for the roles to update in case it exists.
     */
    where: rolesWhereUniqueInput
    /**
     * In case the roles found by the `where` argument doesn't exist, create a new roles with this data.
     */
    create: XOR<rolesCreateInput, rolesUncheckedCreateInput>
    /**
     * In case the roles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<rolesUpdateInput, rolesUncheckedUpdateInput>
  }

  /**
   * roles delete
   */
  export type rolesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter which roles to delete.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles deleteMany
   */
  export type rolesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which roles to delete
     */
    where?: rolesWhereInput
  }

  /**
   * roles.usuarios
   */
  export type roles$usuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuarios
     */
    select?: usuariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosInclude<ExtArgs> | null
    where?: usuariosWhereInput
    orderBy?: usuariosOrderByWithRelationInput | usuariosOrderByWithRelationInput[]
    cursor?: usuariosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsuariosScalarFieldEnum | UsuariosScalarFieldEnum[]
  }

  /**
   * roles without action
   */
  export type rolesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
  }


  /**
   * Model destinos
   */

  export type AggregateDestinos = {
    _count: DestinosCountAggregateOutputType | null
    _avg: DestinosAvgAggregateOutputType | null
    _sum: DestinosSumAggregateOutputType | null
    _min: DestinosMinAggregateOutputType | null
    _max: DestinosMaxAggregateOutputType | null
  }

  export type DestinosAvgAggregateOutputType = {
    id_destino: number | null
    id_pais: number | null
  }

  export type DestinosSumAggregateOutputType = {
    id_destino: number | null
    id_pais: number | null
  }

  export type DestinosMinAggregateOutputType = {
    id_destino: number | null
    id_pais: number | null
    nombre: string | null
    estado_auditoria: string | null
    fecha_creacion: Date | null
    fecha_modificacion: Date | null
  }

  export type DestinosMaxAggregateOutputType = {
    id_destino: number | null
    id_pais: number | null
    nombre: string | null
    estado_auditoria: string | null
    fecha_creacion: Date | null
    fecha_modificacion: Date | null
  }

  export type DestinosCountAggregateOutputType = {
    id_destino: number
    id_pais: number
    nombre: number
    estado_auditoria: number
    fecha_creacion: number
    fecha_modificacion: number
    _all: number
  }


  export type DestinosAvgAggregateInputType = {
    id_destino?: true
    id_pais?: true
  }

  export type DestinosSumAggregateInputType = {
    id_destino?: true
    id_pais?: true
  }

  export type DestinosMinAggregateInputType = {
    id_destino?: true
    id_pais?: true
    nombre?: true
    estado_auditoria?: true
    fecha_creacion?: true
    fecha_modificacion?: true
  }

  export type DestinosMaxAggregateInputType = {
    id_destino?: true
    id_pais?: true
    nombre?: true
    estado_auditoria?: true
    fecha_creacion?: true
    fecha_modificacion?: true
  }

  export type DestinosCountAggregateInputType = {
    id_destino?: true
    id_pais?: true
    nombre?: true
    estado_auditoria?: true
    fecha_creacion?: true
    fecha_modificacion?: true
    _all?: true
  }

  export type DestinosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which destinos to aggregate.
     */
    where?: destinosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of destinos to fetch.
     */
    orderBy?: destinosOrderByWithRelationInput | destinosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: destinosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` destinos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` destinos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned destinos
    **/
    _count?: true | DestinosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DestinosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DestinosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DestinosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DestinosMaxAggregateInputType
  }

  export type GetDestinosAggregateType<T extends DestinosAggregateArgs> = {
        [P in keyof T & keyof AggregateDestinos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDestinos[P]>
      : GetScalarType<T[P], AggregateDestinos[P]>
  }




  export type destinosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: destinosWhereInput
    orderBy?: destinosOrderByWithAggregationInput | destinosOrderByWithAggregationInput[]
    by: DestinosScalarFieldEnum[] | DestinosScalarFieldEnum
    having?: destinosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DestinosCountAggregateInputType | true
    _avg?: DestinosAvgAggregateInputType
    _sum?: DestinosSumAggregateInputType
    _min?: DestinosMinAggregateInputType
    _max?: DestinosMaxAggregateInputType
  }

  export type DestinosGroupByOutputType = {
    id_destino: number
    id_pais: number
    nombre: string
    estado_auditoria: string
    fecha_creacion: Date
    fecha_modificacion: Date | null
    _count: DestinosCountAggregateOutputType | null
    _avg: DestinosAvgAggregateOutputType | null
    _sum: DestinosSumAggregateOutputType | null
    _min: DestinosMinAggregateOutputType | null
    _max: DestinosMaxAggregateOutputType | null
  }

  type GetDestinosGroupByPayload<T extends destinosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DestinosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DestinosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DestinosGroupByOutputType[P]>
            : GetScalarType<T[P], DestinosGroupByOutputType[P]>
        }
      >
    >


  export type destinosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_destino?: boolean
    id_pais?: boolean
    nombre?: boolean
    estado_auditoria?: boolean
    fecha_creacion?: boolean
    fecha_modificacion?: boolean
    paises?: boolean | paisesDefaultArgs<ExtArgs>
    hospedajes?: boolean | destinos$hospedajesArgs<ExtArgs>
    viajes?: boolean | destinos$viajesArgs<ExtArgs>
    _count?: boolean | DestinosCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["destinos"]>

  export type destinosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_destino?: boolean
    id_pais?: boolean
    nombre?: boolean
    estado_auditoria?: boolean
    fecha_creacion?: boolean
    fecha_modificacion?: boolean
    paises?: boolean | paisesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["destinos"]>

  export type destinosSelectScalar = {
    id_destino?: boolean
    id_pais?: boolean
    nombre?: boolean
    estado_auditoria?: boolean
    fecha_creacion?: boolean
    fecha_modificacion?: boolean
  }

  export type destinosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paises?: boolean | paisesDefaultArgs<ExtArgs>
    hospedajes?: boolean | destinos$hospedajesArgs<ExtArgs>
    viajes?: boolean | destinos$viajesArgs<ExtArgs>
    _count?: boolean | DestinosCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type destinosIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paises?: boolean | paisesDefaultArgs<ExtArgs>
  }

  export type $destinosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "destinos"
    objects: {
      paises: Prisma.$paisesPayload<ExtArgs>
      hospedajes: Prisma.$hospedajesPayload<ExtArgs>[]
      viajes: Prisma.$viajesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_destino: number
      id_pais: number
      nombre: string
      estado_auditoria: string
      fecha_creacion: Date
      fecha_modificacion: Date | null
    }, ExtArgs["result"]["destinos"]>
    composites: {}
  }

  type destinosGetPayload<S extends boolean | null | undefined | destinosDefaultArgs> = $Result.GetResult<Prisma.$destinosPayload, S>

  type destinosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<destinosFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DestinosCountAggregateInputType | true
    }

  export interface destinosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['destinos'], meta: { name: 'destinos' } }
    /**
     * Find zero or one Destinos that matches the filter.
     * @param {destinosFindUniqueArgs} args - Arguments to find a Destinos
     * @example
     * // Get one Destinos
     * const destinos = await prisma.destinos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends destinosFindUniqueArgs>(args: SelectSubset<T, destinosFindUniqueArgs<ExtArgs>>): Prisma__destinosClient<$Result.GetResult<Prisma.$destinosPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Destinos that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {destinosFindUniqueOrThrowArgs} args - Arguments to find a Destinos
     * @example
     * // Get one Destinos
     * const destinos = await prisma.destinos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends destinosFindUniqueOrThrowArgs>(args: SelectSubset<T, destinosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__destinosClient<$Result.GetResult<Prisma.$destinosPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Destinos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {destinosFindFirstArgs} args - Arguments to find a Destinos
     * @example
     * // Get one Destinos
     * const destinos = await prisma.destinos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends destinosFindFirstArgs>(args?: SelectSubset<T, destinosFindFirstArgs<ExtArgs>>): Prisma__destinosClient<$Result.GetResult<Prisma.$destinosPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Destinos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {destinosFindFirstOrThrowArgs} args - Arguments to find a Destinos
     * @example
     * // Get one Destinos
     * const destinos = await prisma.destinos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends destinosFindFirstOrThrowArgs>(args?: SelectSubset<T, destinosFindFirstOrThrowArgs<ExtArgs>>): Prisma__destinosClient<$Result.GetResult<Prisma.$destinosPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Destinos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {destinosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Destinos
     * const destinos = await prisma.destinos.findMany()
     * 
     * // Get first 10 Destinos
     * const destinos = await prisma.destinos.findMany({ take: 10 })
     * 
     * // Only select the `id_destino`
     * const destinosWithId_destinoOnly = await prisma.destinos.findMany({ select: { id_destino: true } })
     * 
     */
    findMany<T extends destinosFindManyArgs>(args?: SelectSubset<T, destinosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$destinosPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Destinos.
     * @param {destinosCreateArgs} args - Arguments to create a Destinos.
     * @example
     * // Create one Destinos
     * const Destinos = await prisma.destinos.create({
     *   data: {
     *     // ... data to create a Destinos
     *   }
     * })
     * 
     */
    create<T extends destinosCreateArgs>(args: SelectSubset<T, destinosCreateArgs<ExtArgs>>): Prisma__destinosClient<$Result.GetResult<Prisma.$destinosPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Destinos.
     * @param {destinosCreateManyArgs} args - Arguments to create many Destinos.
     * @example
     * // Create many Destinos
     * const destinos = await prisma.destinos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends destinosCreateManyArgs>(args?: SelectSubset<T, destinosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Destinos and returns the data saved in the database.
     * @param {destinosCreateManyAndReturnArgs} args - Arguments to create many Destinos.
     * @example
     * // Create many Destinos
     * const destinos = await prisma.destinos.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Destinos and only return the `id_destino`
     * const destinosWithId_destinoOnly = await prisma.destinos.createManyAndReturn({ 
     *   select: { id_destino: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends destinosCreateManyAndReturnArgs>(args?: SelectSubset<T, destinosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$destinosPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Destinos.
     * @param {destinosDeleteArgs} args - Arguments to delete one Destinos.
     * @example
     * // Delete one Destinos
     * const Destinos = await prisma.destinos.delete({
     *   where: {
     *     // ... filter to delete one Destinos
     *   }
     * })
     * 
     */
    delete<T extends destinosDeleteArgs>(args: SelectSubset<T, destinosDeleteArgs<ExtArgs>>): Prisma__destinosClient<$Result.GetResult<Prisma.$destinosPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Destinos.
     * @param {destinosUpdateArgs} args - Arguments to update one Destinos.
     * @example
     * // Update one Destinos
     * const destinos = await prisma.destinos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends destinosUpdateArgs>(args: SelectSubset<T, destinosUpdateArgs<ExtArgs>>): Prisma__destinosClient<$Result.GetResult<Prisma.$destinosPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Destinos.
     * @param {destinosDeleteManyArgs} args - Arguments to filter Destinos to delete.
     * @example
     * // Delete a few Destinos
     * const { count } = await prisma.destinos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends destinosDeleteManyArgs>(args?: SelectSubset<T, destinosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Destinos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {destinosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Destinos
     * const destinos = await prisma.destinos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends destinosUpdateManyArgs>(args: SelectSubset<T, destinosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Destinos.
     * @param {destinosUpsertArgs} args - Arguments to update or create a Destinos.
     * @example
     * // Update or create a Destinos
     * const destinos = await prisma.destinos.upsert({
     *   create: {
     *     // ... data to create a Destinos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Destinos we want to update
     *   }
     * })
     */
    upsert<T extends destinosUpsertArgs>(args: SelectSubset<T, destinosUpsertArgs<ExtArgs>>): Prisma__destinosClient<$Result.GetResult<Prisma.$destinosPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Destinos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {destinosCountArgs} args - Arguments to filter Destinos to count.
     * @example
     * // Count the number of Destinos
     * const count = await prisma.destinos.count({
     *   where: {
     *     // ... the filter for the Destinos we want to count
     *   }
     * })
    **/
    count<T extends destinosCountArgs>(
      args?: Subset<T, destinosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DestinosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Destinos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DestinosAggregateArgs>(args: Subset<T, DestinosAggregateArgs>): Prisma.PrismaPromise<GetDestinosAggregateType<T>>

    /**
     * Group by Destinos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {destinosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends destinosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: destinosGroupByArgs['orderBy'] }
        : { orderBy?: destinosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, destinosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDestinosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the destinos model
   */
  readonly fields: destinosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for destinos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__destinosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    paises<T extends paisesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, paisesDefaultArgs<ExtArgs>>): Prisma__paisesClient<$Result.GetResult<Prisma.$paisesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    hospedajes<T extends destinos$hospedajesArgs<ExtArgs> = {}>(args?: Subset<T, destinos$hospedajesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$hospedajesPayload<ExtArgs>, T, "findMany"> | Null>
    viajes<T extends destinos$viajesArgs<ExtArgs> = {}>(args?: Subset<T, destinos$viajesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$viajesPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the destinos model
   */ 
  interface destinosFieldRefs {
    readonly id_destino: FieldRef<"destinos", 'Int'>
    readonly id_pais: FieldRef<"destinos", 'Int'>
    readonly nombre: FieldRef<"destinos", 'String'>
    readonly estado_auditoria: FieldRef<"destinos", 'String'>
    readonly fecha_creacion: FieldRef<"destinos", 'DateTime'>
    readonly fecha_modificacion: FieldRef<"destinos", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * destinos findUnique
   */
  export type destinosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the destinos
     */
    select?: destinosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: destinosInclude<ExtArgs> | null
    /**
     * Filter, which destinos to fetch.
     */
    where: destinosWhereUniqueInput
  }

  /**
   * destinos findUniqueOrThrow
   */
  export type destinosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the destinos
     */
    select?: destinosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: destinosInclude<ExtArgs> | null
    /**
     * Filter, which destinos to fetch.
     */
    where: destinosWhereUniqueInput
  }

  /**
   * destinos findFirst
   */
  export type destinosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the destinos
     */
    select?: destinosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: destinosInclude<ExtArgs> | null
    /**
     * Filter, which destinos to fetch.
     */
    where?: destinosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of destinos to fetch.
     */
    orderBy?: destinosOrderByWithRelationInput | destinosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for destinos.
     */
    cursor?: destinosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` destinos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` destinos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of destinos.
     */
    distinct?: DestinosScalarFieldEnum | DestinosScalarFieldEnum[]
  }

  /**
   * destinos findFirstOrThrow
   */
  export type destinosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the destinos
     */
    select?: destinosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: destinosInclude<ExtArgs> | null
    /**
     * Filter, which destinos to fetch.
     */
    where?: destinosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of destinos to fetch.
     */
    orderBy?: destinosOrderByWithRelationInput | destinosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for destinos.
     */
    cursor?: destinosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` destinos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` destinos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of destinos.
     */
    distinct?: DestinosScalarFieldEnum | DestinosScalarFieldEnum[]
  }

  /**
   * destinos findMany
   */
  export type destinosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the destinos
     */
    select?: destinosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: destinosInclude<ExtArgs> | null
    /**
     * Filter, which destinos to fetch.
     */
    where?: destinosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of destinos to fetch.
     */
    orderBy?: destinosOrderByWithRelationInput | destinosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing destinos.
     */
    cursor?: destinosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` destinos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` destinos.
     */
    skip?: number
    distinct?: DestinosScalarFieldEnum | DestinosScalarFieldEnum[]
  }

  /**
   * destinos create
   */
  export type destinosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the destinos
     */
    select?: destinosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: destinosInclude<ExtArgs> | null
    /**
     * The data needed to create a destinos.
     */
    data: XOR<destinosCreateInput, destinosUncheckedCreateInput>
  }

  /**
   * destinos createMany
   */
  export type destinosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many destinos.
     */
    data: destinosCreateManyInput | destinosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * destinos createManyAndReturn
   */
  export type destinosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the destinos
     */
    select?: destinosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many destinos.
     */
    data: destinosCreateManyInput | destinosCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: destinosIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * destinos update
   */
  export type destinosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the destinos
     */
    select?: destinosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: destinosInclude<ExtArgs> | null
    /**
     * The data needed to update a destinos.
     */
    data: XOR<destinosUpdateInput, destinosUncheckedUpdateInput>
    /**
     * Choose, which destinos to update.
     */
    where: destinosWhereUniqueInput
  }

  /**
   * destinos updateMany
   */
  export type destinosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update destinos.
     */
    data: XOR<destinosUpdateManyMutationInput, destinosUncheckedUpdateManyInput>
    /**
     * Filter which destinos to update
     */
    where?: destinosWhereInput
  }

  /**
   * destinos upsert
   */
  export type destinosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the destinos
     */
    select?: destinosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: destinosInclude<ExtArgs> | null
    /**
     * The filter to search for the destinos to update in case it exists.
     */
    where: destinosWhereUniqueInput
    /**
     * In case the destinos found by the `where` argument doesn't exist, create a new destinos with this data.
     */
    create: XOR<destinosCreateInput, destinosUncheckedCreateInput>
    /**
     * In case the destinos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<destinosUpdateInput, destinosUncheckedUpdateInput>
  }

  /**
   * destinos delete
   */
  export type destinosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the destinos
     */
    select?: destinosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: destinosInclude<ExtArgs> | null
    /**
     * Filter which destinos to delete.
     */
    where: destinosWhereUniqueInput
  }

  /**
   * destinos deleteMany
   */
  export type destinosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which destinos to delete
     */
    where?: destinosWhereInput
  }

  /**
   * destinos.hospedajes
   */
  export type destinos$hospedajesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hospedajes
     */
    select?: hospedajesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hospedajesInclude<ExtArgs> | null
    where?: hospedajesWhereInput
    orderBy?: hospedajesOrderByWithRelationInput | hospedajesOrderByWithRelationInput[]
    cursor?: hospedajesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HospedajesScalarFieldEnum | HospedajesScalarFieldEnum[]
  }

  /**
   * destinos.viajes
   */
  export type destinos$viajesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viajes
     */
    select?: viajesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: viajesInclude<ExtArgs> | null
    where?: viajesWhereInput
    orderBy?: viajesOrderByWithRelationInput | viajesOrderByWithRelationInput[]
    cursor?: viajesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ViajesScalarFieldEnum | ViajesScalarFieldEnum[]
  }

  /**
   * destinos without action
   */
  export type destinosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the destinos
     */
    select?: destinosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: destinosInclude<ExtArgs> | null
  }


  /**
   * Model hospedajes
   */

  export type AggregateHospedajes = {
    _count: HospedajesCountAggregateOutputType | null
    _avg: HospedajesAvgAggregateOutputType | null
    _sum: HospedajesSumAggregateOutputType | null
    _min: HospedajesMinAggregateOutputType | null
    _max: HospedajesMaxAggregateOutputType | null
  }

  export type HospedajesAvgAggregateOutputType = {
    id_hospedaje: number | null
    id_destino: number | null
    precio: Decimal | null
  }

  export type HospedajesSumAggregateOutputType = {
    id_hospedaje: number | null
    id_destino: number | null
    precio: Decimal | null
  }

  export type HospedajesMinAggregateOutputType = {
    id_hospedaje: number | null
    id_destino: number | null
    nombre: string | null
    precio: Decimal | null
    estado_auditoria: string | null
    fecha_creacion: Date | null
    fecha_modificacion: Date | null
  }

  export type HospedajesMaxAggregateOutputType = {
    id_hospedaje: number | null
    id_destino: number | null
    nombre: string | null
    precio: Decimal | null
    estado_auditoria: string | null
    fecha_creacion: Date | null
    fecha_modificacion: Date | null
  }

  export type HospedajesCountAggregateOutputType = {
    id_hospedaje: number
    id_destino: number
    nombre: number
    precio: number
    estado_auditoria: number
    fecha_creacion: number
    fecha_modificacion: number
    _all: number
  }


  export type HospedajesAvgAggregateInputType = {
    id_hospedaje?: true
    id_destino?: true
    precio?: true
  }

  export type HospedajesSumAggregateInputType = {
    id_hospedaje?: true
    id_destino?: true
    precio?: true
  }

  export type HospedajesMinAggregateInputType = {
    id_hospedaje?: true
    id_destino?: true
    nombre?: true
    precio?: true
    estado_auditoria?: true
    fecha_creacion?: true
    fecha_modificacion?: true
  }

  export type HospedajesMaxAggregateInputType = {
    id_hospedaje?: true
    id_destino?: true
    nombre?: true
    precio?: true
    estado_auditoria?: true
    fecha_creacion?: true
    fecha_modificacion?: true
  }

  export type HospedajesCountAggregateInputType = {
    id_hospedaje?: true
    id_destino?: true
    nombre?: true
    precio?: true
    estado_auditoria?: true
    fecha_creacion?: true
    fecha_modificacion?: true
    _all?: true
  }

  export type HospedajesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which hospedajes to aggregate.
     */
    where?: hospedajesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hospedajes to fetch.
     */
    orderBy?: hospedajesOrderByWithRelationInput | hospedajesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: hospedajesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hospedajes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hospedajes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned hospedajes
    **/
    _count?: true | HospedajesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HospedajesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HospedajesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HospedajesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HospedajesMaxAggregateInputType
  }

  export type GetHospedajesAggregateType<T extends HospedajesAggregateArgs> = {
        [P in keyof T & keyof AggregateHospedajes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHospedajes[P]>
      : GetScalarType<T[P], AggregateHospedajes[P]>
  }




  export type hospedajesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: hospedajesWhereInput
    orderBy?: hospedajesOrderByWithAggregationInput | hospedajesOrderByWithAggregationInput[]
    by: HospedajesScalarFieldEnum[] | HospedajesScalarFieldEnum
    having?: hospedajesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HospedajesCountAggregateInputType | true
    _avg?: HospedajesAvgAggregateInputType
    _sum?: HospedajesSumAggregateInputType
    _min?: HospedajesMinAggregateInputType
    _max?: HospedajesMaxAggregateInputType
  }

  export type HospedajesGroupByOutputType = {
    id_hospedaje: number
    id_destino: number
    nombre: string
    precio: Decimal
    estado_auditoria: string
    fecha_creacion: Date
    fecha_modificacion: Date | null
    _count: HospedajesCountAggregateOutputType | null
    _avg: HospedajesAvgAggregateOutputType | null
    _sum: HospedajesSumAggregateOutputType | null
    _min: HospedajesMinAggregateOutputType | null
    _max: HospedajesMaxAggregateOutputType | null
  }

  type GetHospedajesGroupByPayload<T extends hospedajesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HospedajesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HospedajesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HospedajesGroupByOutputType[P]>
            : GetScalarType<T[P], HospedajesGroupByOutputType[P]>
        }
      >
    >


  export type hospedajesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_hospedaje?: boolean
    id_destino?: boolean
    nombre?: boolean
    precio?: boolean
    estado_auditoria?: boolean
    fecha_creacion?: boolean
    fecha_modificacion?: boolean
    destinos?: boolean | destinosDefaultArgs<ExtArgs>
    paquetes?: boolean | hospedajes$paquetesArgs<ExtArgs>
    viajes?: boolean | hospedajes$viajesArgs<ExtArgs>
    _count?: boolean | HospedajesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hospedajes"]>

  export type hospedajesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_hospedaje?: boolean
    id_destino?: boolean
    nombre?: boolean
    precio?: boolean
    estado_auditoria?: boolean
    fecha_creacion?: boolean
    fecha_modificacion?: boolean
    destinos?: boolean | destinosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hospedajes"]>

  export type hospedajesSelectScalar = {
    id_hospedaje?: boolean
    id_destino?: boolean
    nombre?: boolean
    precio?: boolean
    estado_auditoria?: boolean
    fecha_creacion?: boolean
    fecha_modificacion?: boolean
  }

  export type hospedajesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    destinos?: boolean | destinosDefaultArgs<ExtArgs>
    paquetes?: boolean | hospedajes$paquetesArgs<ExtArgs>
    viajes?: boolean | hospedajes$viajesArgs<ExtArgs>
    _count?: boolean | HospedajesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type hospedajesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    destinos?: boolean | destinosDefaultArgs<ExtArgs>
  }

  export type $hospedajesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "hospedajes"
    objects: {
      destinos: Prisma.$destinosPayload<ExtArgs>
      paquetes: Prisma.$paquetesPayload<ExtArgs>[]
      viajes: Prisma.$viajesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_hospedaje: number
      id_destino: number
      nombre: string
      precio: Prisma.Decimal
      estado_auditoria: string
      fecha_creacion: Date
      fecha_modificacion: Date | null
    }, ExtArgs["result"]["hospedajes"]>
    composites: {}
  }

  type hospedajesGetPayload<S extends boolean | null | undefined | hospedajesDefaultArgs> = $Result.GetResult<Prisma.$hospedajesPayload, S>

  type hospedajesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<hospedajesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HospedajesCountAggregateInputType | true
    }

  export interface hospedajesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['hospedajes'], meta: { name: 'hospedajes' } }
    /**
     * Find zero or one Hospedajes that matches the filter.
     * @param {hospedajesFindUniqueArgs} args - Arguments to find a Hospedajes
     * @example
     * // Get one Hospedajes
     * const hospedajes = await prisma.hospedajes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends hospedajesFindUniqueArgs>(args: SelectSubset<T, hospedajesFindUniqueArgs<ExtArgs>>): Prisma__hospedajesClient<$Result.GetResult<Prisma.$hospedajesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Hospedajes that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {hospedajesFindUniqueOrThrowArgs} args - Arguments to find a Hospedajes
     * @example
     * // Get one Hospedajes
     * const hospedajes = await prisma.hospedajes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends hospedajesFindUniqueOrThrowArgs>(args: SelectSubset<T, hospedajesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__hospedajesClient<$Result.GetResult<Prisma.$hospedajesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Hospedajes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hospedajesFindFirstArgs} args - Arguments to find a Hospedajes
     * @example
     * // Get one Hospedajes
     * const hospedajes = await prisma.hospedajes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends hospedajesFindFirstArgs>(args?: SelectSubset<T, hospedajesFindFirstArgs<ExtArgs>>): Prisma__hospedajesClient<$Result.GetResult<Prisma.$hospedajesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Hospedajes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hospedajesFindFirstOrThrowArgs} args - Arguments to find a Hospedajes
     * @example
     * // Get one Hospedajes
     * const hospedajes = await prisma.hospedajes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends hospedajesFindFirstOrThrowArgs>(args?: SelectSubset<T, hospedajesFindFirstOrThrowArgs<ExtArgs>>): Prisma__hospedajesClient<$Result.GetResult<Prisma.$hospedajesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Hospedajes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hospedajesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Hospedajes
     * const hospedajes = await prisma.hospedajes.findMany()
     * 
     * // Get first 10 Hospedajes
     * const hospedajes = await prisma.hospedajes.findMany({ take: 10 })
     * 
     * // Only select the `id_hospedaje`
     * const hospedajesWithId_hospedajeOnly = await prisma.hospedajes.findMany({ select: { id_hospedaje: true } })
     * 
     */
    findMany<T extends hospedajesFindManyArgs>(args?: SelectSubset<T, hospedajesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$hospedajesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Hospedajes.
     * @param {hospedajesCreateArgs} args - Arguments to create a Hospedajes.
     * @example
     * // Create one Hospedajes
     * const Hospedajes = await prisma.hospedajes.create({
     *   data: {
     *     // ... data to create a Hospedajes
     *   }
     * })
     * 
     */
    create<T extends hospedajesCreateArgs>(args: SelectSubset<T, hospedajesCreateArgs<ExtArgs>>): Prisma__hospedajesClient<$Result.GetResult<Prisma.$hospedajesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Hospedajes.
     * @param {hospedajesCreateManyArgs} args - Arguments to create many Hospedajes.
     * @example
     * // Create many Hospedajes
     * const hospedajes = await prisma.hospedajes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends hospedajesCreateManyArgs>(args?: SelectSubset<T, hospedajesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Hospedajes and returns the data saved in the database.
     * @param {hospedajesCreateManyAndReturnArgs} args - Arguments to create many Hospedajes.
     * @example
     * // Create many Hospedajes
     * const hospedajes = await prisma.hospedajes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Hospedajes and only return the `id_hospedaje`
     * const hospedajesWithId_hospedajeOnly = await prisma.hospedajes.createManyAndReturn({ 
     *   select: { id_hospedaje: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends hospedajesCreateManyAndReturnArgs>(args?: SelectSubset<T, hospedajesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$hospedajesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Hospedajes.
     * @param {hospedajesDeleteArgs} args - Arguments to delete one Hospedajes.
     * @example
     * // Delete one Hospedajes
     * const Hospedajes = await prisma.hospedajes.delete({
     *   where: {
     *     // ... filter to delete one Hospedajes
     *   }
     * })
     * 
     */
    delete<T extends hospedajesDeleteArgs>(args: SelectSubset<T, hospedajesDeleteArgs<ExtArgs>>): Prisma__hospedajesClient<$Result.GetResult<Prisma.$hospedajesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Hospedajes.
     * @param {hospedajesUpdateArgs} args - Arguments to update one Hospedajes.
     * @example
     * // Update one Hospedajes
     * const hospedajes = await prisma.hospedajes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends hospedajesUpdateArgs>(args: SelectSubset<T, hospedajesUpdateArgs<ExtArgs>>): Prisma__hospedajesClient<$Result.GetResult<Prisma.$hospedajesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Hospedajes.
     * @param {hospedajesDeleteManyArgs} args - Arguments to filter Hospedajes to delete.
     * @example
     * // Delete a few Hospedajes
     * const { count } = await prisma.hospedajes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends hospedajesDeleteManyArgs>(args?: SelectSubset<T, hospedajesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hospedajes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hospedajesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Hospedajes
     * const hospedajes = await prisma.hospedajes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends hospedajesUpdateManyArgs>(args: SelectSubset<T, hospedajesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Hospedajes.
     * @param {hospedajesUpsertArgs} args - Arguments to update or create a Hospedajes.
     * @example
     * // Update or create a Hospedajes
     * const hospedajes = await prisma.hospedajes.upsert({
     *   create: {
     *     // ... data to create a Hospedajes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Hospedajes we want to update
     *   }
     * })
     */
    upsert<T extends hospedajesUpsertArgs>(args: SelectSubset<T, hospedajesUpsertArgs<ExtArgs>>): Prisma__hospedajesClient<$Result.GetResult<Prisma.$hospedajesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Hospedajes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hospedajesCountArgs} args - Arguments to filter Hospedajes to count.
     * @example
     * // Count the number of Hospedajes
     * const count = await prisma.hospedajes.count({
     *   where: {
     *     // ... the filter for the Hospedajes we want to count
     *   }
     * })
    **/
    count<T extends hospedajesCountArgs>(
      args?: Subset<T, hospedajesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HospedajesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Hospedajes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospedajesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HospedajesAggregateArgs>(args: Subset<T, HospedajesAggregateArgs>): Prisma.PrismaPromise<GetHospedajesAggregateType<T>>

    /**
     * Group by Hospedajes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hospedajesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends hospedajesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: hospedajesGroupByArgs['orderBy'] }
        : { orderBy?: hospedajesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, hospedajesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHospedajesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the hospedajes model
   */
  readonly fields: hospedajesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for hospedajes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__hospedajesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    destinos<T extends destinosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, destinosDefaultArgs<ExtArgs>>): Prisma__destinosClient<$Result.GetResult<Prisma.$destinosPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    paquetes<T extends hospedajes$paquetesArgs<ExtArgs> = {}>(args?: Subset<T, hospedajes$paquetesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paquetesPayload<ExtArgs>, T, "findMany"> | Null>
    viajes<T extends hospedajes$viajesArgs<ExtArgs> = {}>(args?: Subset<T, hospedajes$viajesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$viajesPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the hospedajes model
   */ 
  interface hospedajesFieldRefs {
    readonly id_hospedaje: FieldRef<"hospedajes", 'Int'>
    readonly id_destino: FieldRef<"hospedajes", 'Int'>
    readonly nombre: FieldRef<"hospedajes", 'String'>
    readonly precio: FieldRef<"hospedajes", 'Decimal'>
    readonly estado_auditoria: FieldRef<"hospedajes", 'String'>
    readonly fecha_creacion: FieldRef<"hospedajes", 'DateTime'>
    readonly fecha_modificacion: FieldRef<"hospedajes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * hospedajes findUnique
   */
  export type hospedajesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hospedajes
     */
    select?: hospedajesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hospedajesInclude<ExtArgs> | null
    /**
     * Filter, which hospedajes to fetch.
     */
    where: hospedajesWhereUniqueInput
  }

  /**
   * hospedajes findUniqueOrThrow
   */
  export type hospedajesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hospedajes
     */
    select?: hospedajesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hospedajesInclude<ExtArgs> | null
    /**
     * Filter, which hospedajes to fetch.
     */
    where: hospedajesWhereUniqueInput
  }

  /**
   * hospedajes findFirst
   */
  export type hospedajesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hospedajes
     */
    select?: hospedajesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hospedajesInclude<ExtArgs> | null
    /**
     * Filter, which hospedajes to fetch.
     */
    where?: hospedajesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hospedajes to fetch.
     */
    orderBy?: hospedajesOrderByWithRelationInput | hospedajesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for hospedajes.
     */
    cursor?: hospedajesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hospedajes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hospedajes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of hospedajes.
     */
    distinct?: HospedajesScalarFieldEnum | HospedajesScalarFieldEnum[]
  }

  /**
   * hospedajes findFirstOrThrow
   */
  export type hospedajesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hospedajes
     */
    select?: hospedajesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hospedajesInclude<ExtArgs> | null
    /**
     * Filter, which hospedajes to fetch.
     */
    where?: hospedajesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hospedajes to fetch.
     */
    orderBy?: hospedajesOrderByWithRelationInput | hospedajesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for hospedajes.
     */
    cursor?: hospedajesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hospedajes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hospedajes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of hospedajes.
     */
    distinct?: HospedajesScalarFieldEnum | HospedajesScalarFieldEnum[]
  }

  /**
   * hospedajes findMany
   */
  export type hospedajesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hospedajes
     */
    select?: hospedajesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hospedajesInclude<ExtArgs> | null
    /**
     * Filter, which hospedajes to fetch.
     */
    where?: hospedajesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hospedajes to fetch.
     */
    orderBy?: hospedajesOrderByWithRelationInput | hospedajesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing hospedajes.
     */
    cursor?: hospedajesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hospedajes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hospedajes.
     */
    skip?: number
    distinct?: HospedajesScalarFieldEnum | HospedajesScalarFieldEnum[]
  }

  /**
   * hospedajes create
   */
  export type hospedajesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hospedajes
     */
    select?: hospedajesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hospedajesInclude<ExtArgs> | null
    /**
     * The data needed to create a hospedajes.
     */
    data: XOR<hospedajesCreateInput, hospedajesUncheckedCreateInput>
  }

  /**
   * hospedajes createMany
   */
  export type hospedajesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many hospedajes.
     */
    data: hospedajesCreateManyInput | hospedajesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * hospedajes createManyAndReturn
   */
  export type hospedajesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hospedajes
     */
    select?: hospedajesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many hospedajes.
     */
    data: hospedajesCreateManyInput | hospedajesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hospedajesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * hospedajes update
   */
  export type hospedajesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hospedajes
     */
    select?: hospedajesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hospedajesInclude<ExtArgs> | null
    /**
     * The data needed to update a hospedajes.
     */
    data: XOR<hospedajesUpdateInput, hospedajesUncheckedUpdateInput>
    /**
     * Choose, which hospedajes to update.
     */
    where: hospedajesWhereUniqueInput
  }

  /**
   * hospedajes updateMany
   */
  export type hospedajesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update hospedajes.
     */
    data: XOR<hospedajesUpdateManyMutationInput, hospedajesUncheckedUpdateManyInput>
    /**
     * Filter which hospedajes to update
     */
    where?: hospedajesWhereInput
  }

  /**
   * hospedajes upsert
   */
  export type hospedajesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hospedajes
     */
    select?: hospedajesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hospedajesInclude<ExtArgs> | null
    /**
     * The filter to search for the hospedajes to update in case it exists.
     */
    where: hospedajesWhereUniqueInput
    /**
     * In case the hospedajes found by the `where` argument doesn't exist, create a new hospedajes with this data.
     */
    create: XOR<hospedajesCreateInput, hospedajesUncheckedCreateInput>
    /**
     * In case the hospedajes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<hospedajesUpdateInput, hospedajesUncheckedUpdateInput>
  }

  /**
   * hospedajes delete
   */
  export type hospedajesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hospedajes
     */
    select?: hospedajesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hospedajesInclude<ExtArgs> | null
    /**
     * Filter which hospedajes to delete.
     */
    where: hospedajesWhereUniqueInput
  }

  /**
   * hospedajes deleteMany
   */
  export type hospedajesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which hospedajes to delete
     */
    where?: hospedajesWhereInput
  }

  /**
   * hospedajes.paquetes
   */
  export type hospedajes$paquetesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paquetes
     */
    select?: paquetesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paquetesInclude<ExtArgs> | null
    where?: paquetesWhereInput
    orderBy?: paquetesOrderByWithRelationInput | paquetesOrderByWithRelationInput[]
    cursor?: paquetesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaquetesScalarFieldEnum | PaquetesScalarFieldEnum[]
  }

  /**
   * hospedajes.viajes
   */
  export type hospedajes$viajesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viajes
     */
    select?: viajesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: viajesInclude<ExtArgs> | null
    where?: viajesWhereInput
    orderBy?: viajesOrderByWithRelationInput | viajesOrderByWithRelationInput[]
    cursor?: viajesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ViajesScalarFieldEnum | ViajesScalarFieldEnum[]
  }

  /**
   * hospedajes without action
   */
  export type hospedajesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hospedajes
     */
    select?: hospedajesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hospedajesInclude<ExtArgs> | null
  }


  /**
   * Model reservas
   */

  export type AggregateReservas = {
    _count: ReservasCountAggregateOutputType | null
    _avg: ReservasAvgAggregateOutputType | null
    _sum: ReservasSumAggregateOutputType | null
    _min: ReservasMinAggregateOutputType | null
    _max: ReservasMaxAggregateOutputType | null
  }

  export type ReservasAvgAggregateOutputType = {
    id_reserva: number | null
    id_usuario: number | null
    id_viaje: number | null
    pago_total: Decimal | null
  }

  export type ReservasSumAggregateOutputType = {
    id_reserva: number | null
    id_usuario: number | null
    id_viaje: number | null
    pago_total: Decimal | null
  }

  export type ReservasMinAggregateOutputType = {
    id_reserva: number | null
    id_usuario: number | null
    id_viaje: number | null
    numero_personas: string | null
    metodo_pago: string | null
    pago_total: Decimal | null
    estado_auditoria: string | null
    fecha_creacion: Date | null
    fecha_modificacion: Date | null
  }

  export type ReservasMaxAggregateOutputType = {
    id_reserva: number | null
    id_usuario: number | null
    id_viaje: number | null
    numero_personas: string | null
    metodo_pago: string | null
    pago_total: Decimal | null
    estado_auditoria: string | null
    fecha_creacion: Date | null
    fecha_modificacion: Date | null
  }

  export type ReservasCountAggregateOutputType = {
    id_reserva: number
    id_usuario: number
    id_viaje: number
    numero_personas: number
    metodo_pago: number
    pago_total: number
    estado_auditoria: number
    fecha_creacion: number
    fecha_modificacion: number
    _all: number
  }


  export type ReservasAvgAggregateInputType = {
    id_reserva?: true
    id_usuario?: true
    id_viaje?: true
    pago_total?: true
  }

  export type ReservasSumAggregateInputType = {
    id_reserva?: true
    id_usuario?: true
    id_viaje?: true
    pago_total?: true
  }

  export type ReservasMinAggregateInputType = {
    id_reserva?: true
    id_usuario?: true
    id_viaje?: true
    numero_personas?: true
    metodo_pago?: true
    pago_total?: true
    estado_auditoria?: true
    fecha_creacion?: true
    fecha_modificacion?: true
  }

  export type ReservasMaxAggregateInputType = {
    id_reserva?: true
    id_usuario?: true
    id_viaje?: true
    numero_personas?: true
    metodo_pago?: true
    pago_total?: true
    estado_auditoria?: true
    fecha_creacion?: true
    fecha_modificacion?: true
  }

  export type ReservasCountAggregateInputType = {
    id_reserva?: true
    id_usuario?: true
    id_viaje?: true
    numero_personas?: true
    metodo_pago?: true
    pago_total?: true
    estado_auditoria?: true
    fecha_creacion?: true
    fecha_modificacion?: true
    _all?: true
  }

  export type ReservasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reservas to aggregate.
     */
    where?: reservasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reservas to fetch.
     */
    orderBy?: reservasOrderByWithRelationInput | reservasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: reservasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reservas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reservas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reservas
    **/
    _count?: true | ReservasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReservasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReservasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReservasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReservasMaxAggregateInputType
  }

  export type GetReservasAggregateType<T extends ReservasAggregateArgs> = {
        [P in keyof T & keyof AggregateReservas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReservas[P]>
      : GetScalarType<T[P], AggregateReservas[P]>
  }




  export type reservasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reservasWhereInput
    orderBy?: reservasOrderByWithAggregationInput | reservasOrderByWithAggregationInput[]
    by: ReservasScalarFieldEnum[] | ReservasScalarFieldEnum
    having?: reservasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReservasCountAggregateInputType | true
    _avg?: ReservasAvgAggregateInputType
    _sum?: ReservasSumAggregateInputType
    _min?: ReservasMinAggregateInputType
    _max?: ReservasMaxAggregateInputType
  }

  export type ReservasGroupByOutputType = {
    id_reserva: number
    id_usuario: number
    id_viaje: number
    numero_personas: string
    metodo_pago: string
    pago_total: Decimal
    estado_auditoria: string
    fecha_creacion: Date
    fecha_modificacion: Date | null
    _count: ReservasCountAggregateOutputType | null
    _avg: ReservasAvgAggregateOutputType | null
    _sum: ReservasSumAggregateOutputType | null
    _min: ReservasMinAggregateOutputType | null
    _max: ReservasMaxAggregateOutputType | null
  }

  type GetReservasGroupByPayload<T extends reservasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReservasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReservasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReservasGroupByOutputType[P]>
            : GetScalarType<T[P], ReservasGroupByOutputType[P]>
        }
      >
    >


  export type reservasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_reserva?: boolean
    id_usuario?: boolean
    id_viaje?: boolean
    numero_personas?: boolean
    metodo_pago?: boolean
    pago_total?: boolean
    estado_auditoria?: boolean
    fecha_creacion?: boolean
    fecha_modificacion?: boolean
    usuarios?: boolean | usuariosDefaultArgs<ExtArgs>
    viajes?: boolean | viajesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reservas"]>

  export type reservasSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_reserva?: boolean
    id_usuario?: boolean
    id_viaje?: boolean
    numero_personas?: boolean
    metodo_pago?: boolean
    pago_total?: boolean
    estado_auditoria?: boolean
    fecha_creacion?: boolean
    fecha_modificacion?: boolean
    usuarios?: boolean | usuariosDefaultArgs<ExtArgs>
    viajes?: boolean | viajesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reservas"]>

  export type reservasSelectScalar = {
    id_reserva?: boolean
    id_usuario?: boolean
    id_viaje?: boolean
    numero_personas?: boolean
    metodo_pago?: boolean
    pago_total?: boolean
    estado_auditoria?: boolean
    fecha_creacion?: boolean
    fecha_modificacion?: boolean
  }

  export type reservasInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuarios?: boolean | usuariosDefaultArgs<ExtArgs>
    viajes?: boolean | viajesDefaultArgs<ExtArgs>
  }
  export type reservasIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuarios?: boolean | usuariosDefaultArgs<ExtArgs>
    viajes?: boolean | viajesDefaultArgs<ExtArgs>
  }

  export type $reservasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "reservas"
    objects: {
      usuarios: Prisma.$usuariosPayload<ExtArgs>
      viajes: Prisma.$viajesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_reserva: number
      id_usuario: number
      id_viaje: number
      numero_personas: string
      metodo_pago: string
      pago_total: Prisma.Decimal
      estado_auditoria: string
      fecha_creacion: Date
      fecha_modificacion: Date | null
    }, ExtArgs["result"]["reservas"]>
    composites: {}
  }

  type reservasGetPayload<S extends boolean | null | undefined | reservasDefaultArgs> = $Result.GetResult<Prisma.$reservasPayload, S>

  type reservasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<reservasFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReservasCountAggregateInputType | true
    }

  export interface reservasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['reservas'], meta: { name: 'reservas' } }
    /**
     * Find zero or one Reservas that matches the filter.
     * @param {reservasFindUniqueArgs} args - Arguments to find a Reservas
     * @example
     * // Get one Reservas
     * const reservas = await prisma.reservas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends reservasFindUniqueArgs>(args: SelectSubset<T, reservasFindUniqueArgs<ExtArgs>>): Prisma__reservasClient<$Result.GetResult<Prisma.$reservasPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Reservas that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {reservasFindUniqueOrThrowArgs} args - Arguments to find a Reservas
     * @example
     * // Get one Reservas
     * const reservas = await prisma.reservas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends reservasFindUniqueOrThrowArgs>(args: SelectSubset<T, reservasFindUniqueOrThrowArgs<ExtArgs>>): Prisma__reservasClient<$Result.GetResult<Prisma.$reservasPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Reservas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reservasFindFirstArgs} args - Arguments to find a Reservas
     * @example
     * // Get one Reservas
     * const reservas = await prisma.reservas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends reservasFindFirstArgs>(args?: SelectSubset<T, reservasFindFirstArgs<ExtArgs>>): Prisma__reservasClient<$Result.GetResult<Prisma.$reservasPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Reservas that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reservasFindFirstOrThrowArgs} args - Arguments to find a Reservas
     * @example
     * // Get one Reservas
     * const reservas = await prisma.reservas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends reservasFindFirstOrThrowArgs>(args?: SelectSubset<T, reservasFindFirstOrThrowArgs<ExtArgs>>): Prisma__reservasClient<$Result.GetResult<Prisma.$reservasPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Reservas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reservasFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reservas
     * const reservas = await prisma.reservas.findMany()
     * 
     * // Get first 10 Reservas
     * const reservas = await prisma.reservas.findMany({ take: 10 })
     * 
     * // Only select the `id_reserva`
     * const reservasWithId_reservaOnly = await prisma.reservas.findMany({ select: { id_reserva: true } })
     * 
     */
    findMany<T extends reservasFindManyArgs>(args?: SelectSubset<T, reservasFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reservasPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Reservas.
     * @param {reservasCreateArgs} args - Arguments to create a Reservas.
     * @example
     * // Create one Reservas
     * const Reservas = await prisma.reservas.create({
     *   data: {
     *     // ... data to create a Reservas
     *   }
     * })
     * 
     */
    create<T extends reservasCreateArgs>(args: SelectSubset<T, reservasCreateArgs<ExtArgs>>): Prisma__reservasClient<$Result.GetResult<Prisma.$reservasPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Reservas.
     * @param {reservasCreateManyArgs} args - Arguments to create many Reservas.
     * @example
     * // Create many Reservas
     * const reservas = await prisma.reservas.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends reservasCreateManyArgs>(args?: SelectSubset<T, reservasCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reservas and returns the data saved in the database.
     * @param {reservasCreateManyAndReturnArgs} args - Arguments to create many Reservas.
     * @example
     * // Create many Reservas
     * const reservas = await prisma.reservas.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reservas and only return the `id_reserva`
     * const reservasWithId_reservaOnly = await prisma.reservas.createManyAndReturn({ 
     *   select: { id_reserva: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends reservasCreateManyAndReturnArgs>(args?: SelectSubset<T, reservasCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reservasPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Reservas.
     * @param {reservasDeleteArgs} args - Arguments to delete one Reservas.
     * @example
     * // Delete one Reservas
     * const Reservas = await prisma.reservas.delete({
     *   where: {
     *     // ... filter to delete one Reservas
     *   }
     * })
     * 
     */
    delete<T extends reservasDeleteArgs>(args: SelectSubset<T, reservasDeleteArgs<ExtArgs>>): Prisma__reservasClient<$Result.GetResult<Prisma.$reservasPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Reservas.
     * @param {reservasUpdateArgs} args - Arguments to update one Reservas.
     * @example
     * // Update one Reservas
     * const reservas = await prisma.reservas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends reservasUpdateArgs>(args: SelectSubset<T, reservasUpdateArgs<ExtArgs>>): Prisma__reservasClient<$Result.GetResult<Prisma.$reservasPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Reservas.
     * @param {reservasDeleteManyArgs} args - Arguments to filter Reservas to delete.
     * @example
     * // Delete a few Reservas
     * const { count } = await prisma.reservas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends reservasDeleteManyArgs>(args?: SelectSubset<T, reservasDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reservas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reservasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reservas
     * const reservas = await prisma.reservas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends reservasUpdateManyArgs>(args: SelectSubset<T, reservasUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Reservas.
     * @param {reservasUpsertArgs} args - Arguments to update or create a Reservas.
     * @example
     * // Update or create a Reservas
     * const reservas = await prisma.reservas.upsert({
     *   create: {
     *     // ... data to create a Reservas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reservas we want to update
     *   }
     * })
     */
    upsert<T extends reservasUpsertArgs>(args: SelectSubset<T, reservasUpsertArgs<ExtArgs>>): Prisma__reservasClient<$Result.GetResult<Prisma.$reservasPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Reservas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reservasCountArgs} args - Arguments to filter Reservas to count.
     * @example
     * // Count the number of Reservas
     * const count = await prisma.reservas.count({
     *   where: {
     *     // ... the filter for the Reservas we want to count
     *   }
     * })
    **/
    count<T extends reservasCountArgs>(
      args?: Subset<T, reservasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReservasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reservas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReservasAggregateArgs>(args: Subset<T, ReservasAggregateArgs>): Prisma.PrismaPromise<GetReservasAggregateType<T>>

    /**
     * Group by Reservas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reservasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends reservasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: reservasGroupByArgs['orderBy'] }
        : { orderBy?: reservasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, reservasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReservasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the reservas model
   */
  readonly fields: reservasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for reservas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__reservasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuarios<T extends usuariosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usuariosDefaultArgs<ExtArgs>>): Prisma__usuariosClient<$Result.GetResult<Prisma.$usuariosPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    viajes<T extends viajesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, viajesDefaultArgs<ExtArgs>>): Prisma__viajesClient<$Result.GetResult<Prisma.$viajesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the reservas model
   */ 
  interface reservasFieldRefs {
    readonly id_reserva: FieldRef<"reservas", 'Int'>
    readonly id_usuario: FieldRef<"reservas", 'Int'>
    readonly id_viaje: FieldRef<"reservas", 'Int'>
    readonly numero_personas: FieldRef<"reservas", 'String'>
    readonly metodo_pago: FieldRef<"reservas", 'String'>
    readonly pago_total: FieldRef<"reservas", 'Decimal'>
    readonly estado_auditoria: FieldRef<"reservas", 'String'>
    readonly fecha_creacion: FieldRef<"reservas", 'DateTime'>
    readonly fecha_modificacion: FieldRef<"reservas", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * reservas findUnique
   */
  export type reservasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reservas
     */
    select?: reservasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reservasInclude<ExtArgs> | null
    /**
     * Filter, which reservas to fetch.
     */
    where: reservasWhereUniqueInput
  }

  /**
   * reservas findUniqueOrThrow
   */
  export type reservasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reservas
     */
    select?: reservasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reservasInclude<ExtArgs> | null
    /**
     * Filter, which reservas to fetch.
     */
    where: reservasWhereUniqueInput
  }

  /**
   * reservas findFirst
   */
  export type reservasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reservas
     */
    select?: reservasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reservasInclude<ExtArgs> | null
    /**
     * Filter, which reservas to fetch.
     */
    where?: reservasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reservas to fetch.
     */
    orderBy?: reservasOrderByWithRelationInput | reservasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reservas.
     */
    cursor?: reservasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reservas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reservas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reservas.
     */
    distinct?: ReservasScalarFieldEnum | ReservasScalarFieldEnum[]
  }

  /**
   * reservas findFirstOrThrow
   */
  export type reservasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reservas
     */
    select?: reservasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reservasInclude<ExtArgs> | null
    /**
     * Filter, which reservas to fetch.
     */
    where?: reservasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reservas to fetch.
     */
    orderBy?: reservasOrderByWithRelationInput | reservasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reservas.
     */
    cursor?: reservasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reservas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reservas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reservas.
     */
    distinct?: ReservasScalarFieldEnum | ReservasScalarFieldEnum[]
  }

  /**
   * reservas findMany
   */
  export type reservasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reservas
     */
    select?: reservasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reservasInclude<ExtArgs> | null
    /**
     * Filter, which reservas to fetch.
     */
    where?: reservasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reservas to fetch.
     */
    orderBy?: reservasOrderByWithRelationInput | reservasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reservas.
     */
    cursor?: reservasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reservas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reservas.
     */
    skip?: number
    distinct?: ReservasScalarFieldEnum | ReservasScalarFieldEnum[]
  }

  /**
   * reservas create
   */
  export type reservasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reservas
     */
    select?: reservasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reservasInclude<ExtArgs> | null
    /**
     * The data needed to create a reservas.
     */
    data: XOR<reservasCreateInput, reservasUncheckedCreateInput>
  }

  /**
   * reservas createMany
   */
  export type reservasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many reservas.
     */
    data: reservasCreateManyInput | reservasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * reservas createManyAndReturn
   */
  export type reservasCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reservas
     */
    select?: reservasSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many reservas.
     */
    data: reservasCreateManyInput | reservasCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reservasIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * reservas update
   */
  export type reservasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reservas
     */
    select?: reservasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reservasInclude<ExtArgs> | null
    /**
     * The data needed to update a reservas.
     */
    data: XOR<reservasUpdateInput, reservasUncheckedUpdateInput>
    /**
     * Choose, which reservas to update.
     */
    where: reservasWhereUniqueInput
  }

  /**
   * reservas updateMany
   */
  export type reservasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update reservas.
     */
    data: XOR<reservasUpdateManyMutationInput, reservasUncheckedUpdateManyInput>
    /**
     * Filter which reservas to update
     */
    where?: reservasWhereInput
  }

  /**
   * reservas upsert
   */
  export type reservasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reservas
     */
    select?: reservasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reservasInclude<ExtArgs> | null
    /**
     * The filter to search for the reservas to update in case it exists.
     */
    where: reservasWhereUniqueInput
    /**
     * In case the reservas found by the `where` argument doesn't exist, create a new reservas with this data.
     */
    create: XOR<reservasCreateInput, reservasUncheckedCreateInput>
    /**
     * In case the reservas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<reservasUpdateInput, reservasUncheckedUpdateInput>
  }

  /**
   * reservas delete
   */
  export type reservasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reservas
     */
    select?: reservasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reservasInclude<ExtArgs> | null
    /**
     * Filter which reservas to delete.
     */
    where: reservasWhereUniqueInput
  }

  /**
   * reservas deleteMany
   */
  export type reservasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reservas to delete
     */
    where?: reservasWhereInput
  }

  /**
   * reservas without action
   */
  export type reservasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reservas
     */
    select?: reservasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reservasInclude<ExtArgs> | null
  }


  /**
   * Model usuarios
   */

  export type AggregateUsuarios = {
    _count: UsuariosCountAggregateOutputType | null
    _avg: UsuariosAvgAggregateOutputType | null
    _sum: UsuariosSumAggregateOutputType | null
    _min: UsuariosMinAggregateOutputType | null
    _max: UsuariosMaxAggregateOutputType | null
  }

  export type UsuariosAvgAggregateOutputType = {
    id_usuario: number | null
    id_rol: number | null
  }

  export type UsuariosSumAggregateOutputType = {
    id_usuario: number | null
    id_rol: number | null
  }

  export type UsuariosMinAggregateOutputType = {
    id_usuario: number | null
    id_rol: number | null
    nombres: string | null
    apellido_paterno: string | null
    apellido_materno: string | null
    username: string | null
    email: string | null
    clave: string | null
    telefono: string | null
    direccion: string | null
    sexo: string | null
    estado_auditoria: string | null
    fecha_creacion: Date | null
    fecha_modificacion: Date | null
  }

  export type UsuariosMaxAggregateOutputType = {
    id_usuario: number | null
    id_rol: number | null
    nombres: string | null
    apellido_paterno: string | null
    apellido_materno: string | null
    username: string | null
    email: string | null
    clave: string | null
    telefono: string | null
    direccion: string | null
    sexo: string | null
    estado_auditoria: string | null
    fecha_creacion: Date | null
    fecha_modificacion: Date | null
  }

  export type UsuariosCountAggregateOutputType = {
    id_usuario: number
    id_rol: number
    nombres: number
    apellido_paterno: number
    apellido_materno: number
    username: number
    email: number
    clave: number
    telefono: number
    direccion: number
    sexo: number
    estado_auditoria: number
    fecha_creacion: number
    fecha_modificacion: number
    _all: number
  }


  export type UsuariosAvgAggregateInputType = {
    id_usuario?: true
    id_rol?: true
  }

  export type UsuariosSumAggregateInputType = {
    id_usuario?: true
    id_rol?: true
  }

  export type UsuariosMinAggregateInputType = {
    id_usuario?: true
    id_rol?: true
    nombres?: true
    apellido_paterno?: true
    apellido_materno?: true
    username?: true
    email?: true
    clave?: true
    telefono?: true
    direccion?: true
    sexo?: true
    estado_auditoria?: true
    fecha_creacion?: true
    fecha_modificacion?: true
  }

  export type UsuariosMaxAggregateInputType = {
    id_usuario?: true
    id_rol?: true
    nombres?: true
    apellido_paterno?: true
    apellido_materno?: true
    username?: true
    email?: true
    clave?: true
    telefono?: true
    direccion?: true
    sexo?: true
    estado_auditoria?: true
    fecha_creacion?: true
    fecha_modificacion?: true
  }

  export type UsuariosCountAggregateInputType = {
    id_usuario?: true
    id_rol?: true
    nombres?: true
    apellido_paterno?: true
    apellido_materno?: true
    username?: true
    email?: true
    clave?: true
    telefono?: true
    direccion?: true
    sexo?: true
    estado_auditoria?: true
    fecha_creacion?: true
    fecha_modificacion?: true
    _all?: true
  }

  export type UsuariosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which usuarios to aggregate.
     */
    where?: usuariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     */
    orderBy?: usuariosOrderByWithRelationInput | usuariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usuariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned usuarios
    **/
    _count?: true | UsuariosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuariosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuariosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuariosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuariosMaxAggregateInputType
  }

  export type GetUsuariosAggregateType<T extends UsuariosAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuarios]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuarios[P]>
      : GetScalarType<T[P], AggregateUsuarios[P]>
  }




  export type usuariosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usuariosWhereInput
    orderBy?: usuariosOrderByWithAggregationInput | usuariosOrderByWithAggregationInput[]
    by: UsuariosScalarFieldEnum[] | UsuariosScalarFieldEnum
    having?: usuariosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuariosCountAggregateInputType | true
    _avg?: UsuariosAvgAggregateInputType
    _sum?: UsuariosSumAggregateInputType
    _min?: UsuariosMinAggregateInputType
    _max?: UsuariosMaxAggregateInputType
  }

  export type UsuariosGroupByOutputType = {
    id_usuario: number
    id_rol: number
    nombres: string
    apellido_paterno: string
    apellido_materno: string
    username: string
    email: string
    clave: string
    telefono: string
    direccion: string
    sexo: string
    estado_auditoria: string
    fecha_creacion: Date
    fecha_modificacion: Date | null
    _count: UsuariosCountAggregateOutputType | null
    _avg: UsuariosAvgAggregateOutputType | null
    _sum: UsuariosSumAggregateOutputType | null
    _min: UsuariosMinAggregateOutputType | null
    _max: UsuariosMaxAggregateOutputType | null
  }

  type GetUsuariosGroupByPayload<T extends usuariosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuariosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuariosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuariosGroupByOutputType[P]>
            : GetScalarType<T[P], UsuariosGroupByOutputType[P]>
        }
      >
    >


  export type usuariosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_usuario?: boolean
    id_rol?: boolean
    nombres?: boolean
    apellido_paterno?: boolean
    apellido_materno?: boolean
    username?: boolean
    email?: boolean
    clave?: boolean
    telefono?: boolean
    direccion?: boolean
    sexo?: boolean
    estado_auditoria?: boolean
    fecha_creacion?: boolean
    fecha_modificacion?: boolean
    reservas?: boolean | usuarios$reservasArgs<ExtArgs>
    roles?: boolean | rolesDefaultArgs<ExtArgs>
    _count?: boolean | UsuariosCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuarios"]>

  export type usuariosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_usuario?: boolean
    id_rol?: boolean
    nombres?: boolean
    apellido_paterno?: boolean
    apellido_materno?: boolean
    username?: boolean
    email?: boolean
    clave?: boolean
    telefono?: boolean
    direccion?: boolean
    sexo?: boolean
    estado_auditoria?: boolean
    fecha_creacion?: boolean
    fecha_modificacion?: boolean
    roles?: boolean | rolesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuarios"]>

  export type usuariosSelectScalar = {
    id_usuario?: boolean
    id_rol?: boolean
    nombres?: boolean
    apellido_paterno?: boolean
    apellido_materno?: boolean
    username?: boolean
    email?: boolean
    clave?: boolean
    telefono?: boolean
    direccion?: boolean
    sexo?: boolean
    estado_auditoria?: boolean
    fecha_creacion?: boolean
    fecha_modificacion?: boolean
  }

  export type usuariosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reservas?: boolean | usuarios$reservasArgs<ExtArgs>
    roles?: boolean | rolesDefaultArgs<ExtArgs>
    _count?: boolean | UsuariosCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type usuariosIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | rolesDefaultArgs<ExtArgs>
  }

  export type $usuariosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "usuarios"
    objects: {
      reservas: Prisma.$reservasPayload<ExtArgs>[]
      roles: Prisma.$rolesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_usuario: number
      id_rol: number
      nombres: string
      apellido_paterno: string
      apellido_materno: string
      username: string
      email: string
      clave: string
      telefono: string
      direccion: string
      sexo: string
      estado_auditoria: string
      fecha_creacion: Date
      fecha_modificacion: Date | null
    }, ExtArgs["result"]["usuarios"]>
    composites: {}
  }

  type usuariosGetPayload<S extends boolean | null | undefined | usuariosDefaultArgs> = $Result.GetResult<Prisma.$usuariosPayload, S>

  type usuariosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<usuariosFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsuariosCountAggregateInputType | true
    }

  export interface usuariosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['usuarios'], meta: { name: 'usuarios' } }
    /**
     * Find zero or one Usuarios that matches the filter.
     * @param {usuariosFindUniqueArgs} args - Arguments to find a Usuarios
     * @example
     * // Get one Usuarios
     * const usuarios = await prisma.usuarios.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usuariosFindUniqueArgs>(args: SelectSubset<T, usuariosFindUniqueArgs<ExtArgs>>): Prisma__usuariosClient<$Result.GetResult<Prisma.$usuariosPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Usuarios that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {usuariosFindUniqueOrThrowArgs} args - Arguments to find a Usuarios
     * @example
     * // Get one Usuarios
     * const usuarios = await prisma.usuarios.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usuariosFindUniqueOrThrowArgs>(args: SelectSubset<T, usuariosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usuariosClient<$Result.GetResult<Prisma.$usuariosPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuariosFindFirstArgs} args - Arguments to find a Usuarios
     * @example
     * // Get one Usuarios
     * const usuarios = await prisma.usuarios.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usuariosFindFirstArgs>(args?: SelectSubset<T, usuariosFindFirstArgs<ExtArgs>>): Prisma__usuariosClient<$Result.GetResult<Prisma.$usuariosPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Usuarios that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuariosFindFirstOrThrowArgs} args - Arguments to find a Usuarios
     * @example
     * // Get one Usuarios
     * const usuarios = await prisma.usuarios.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usuariosFindFirstOrThrowArgs>(args?: SelectSubset<T, usuariosFindFirstOrThrowArgs<ExtArgs>>): Prisma__usuariosClient<$Result.GetResult<Prisma.$usuariosPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuariosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuarios.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuarios.findMany({ take: 10 })
     * 
     * // Only select the `id_usuario`
     * const usuariosWithId_usuarioOnly = await prisma.usuarios.findMany({ select: { id_usuario: true } })
     * 
     */
    findMany<T extends usuariosFindManyArgs>(args?: SelectSubset<T, usuariosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usuariosPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Usuarios.
     * @param {usuariosCreateArgs} args - Arguments to create a Usuarios.
     * @example
     * // Create one Usuarios
     * const Usuarios = await prisma.usuarios.create({
     *   data: {
     *     // ... data to create a Usuarios
     *   }
     * })
     * 
     */
    create<T extends usuariosCreateArgs>(args: SelectSubset<T, usuariosCreateArgs<ExtArgs>>): Prisma__usuariosClient<$Result.GetResult<Prisma.$usuariosPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Usuarios.
     * @param {usuariosCreateManyArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuarios = await prisma.usuarios.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usuariosCreateManyArgs>(args?: SelectSubset<T, usuariosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Usuarios and returns the data saved in the database.
     * @param {usuariosCreateManyAndReturnArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuarios = await prisma.usuarios.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Usuarios and only return the `id_usuario`
     * const usuariosWithId_usuarioOnly = await prisma.usuarios.createManyAndReturn({ 
     *   select: { id_usuario: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends usuariosCreateManyAndReturnArgs>(args?: SelectSubset<T, usuariosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usuariosPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Usuarios.
     * @param {usuariosDeleteArgs} args - Arguments to delete one Usuarios.
     * @example
     * // Delete one Usuarios
     * const Usuarios = await prisma.usuarios.delete({
     *   where: {
     *     // ... filter to delete one Usuarios
     *   }
     * })
     * 
     */
    delete<T extends usuariosDeleteArgs>(args: SelectSubset<T, usuariosDeleteArgs<ExtArgs>>): Prisma__usuariosClient<$Result.GetResult<Prisma.$usuariosPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Usuarios.
     * @param {usuariosUpdateArgs} args - Arguments to update one Usuarios.
     * @example
     * // Update one Usuarios
     * const usuarios = await prisma.usuarios.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usuariosUpdateArgs>(args: SelectSubset<T, usuariosUpdateArgs<ExtArgs>>): Prisma__usuariosClient<$Result.GetResult<Prisma.$usuariosPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Usuarios.
     * @param {usuariosDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuarios.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usuariosDeleteManyArgs>(args?: SelectSubset<T, usuariosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuariosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuarios = await prisma.usuarios.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usuariosUpdateManyArgs>(args: SelectSubset<T, usuariosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Usuarios.
     * @param {usuariosUpsertArgs} args - Arguments to update or create a Usuarios.
     * @example
     * // Update or create a Usuarios
     * const usuarios = await prisma.usuarios.upsert({
     *   create: {
     *     // ... data to create a Usuarios
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuarios we want to update
     *   }
     * })
     */
    upsert<T extends usuariosUpsertArgs>(args: SelectSubset<T, usuariosUpsertArgs<ExtArgs>>): Prisma__usuariosClient<$Result.GetResult<Prisma.$usuariosPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuariosCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuarios.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends usuariosCountArgs>(
      args?: Subset<T, usuariosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuariosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuariosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuariosAggregateArgs>(args: Subset<T, UsuariosAggregateArgs>): Prisma.PrismaPromise<GetUsuariosAggregateType<T>>

    /**
     * Group by Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuariosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usuariosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usuariosGroupByArgs['orderBy'] }
        : { orderBy?: usuariosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usuariosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuariosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the usuarios model
   */
  readonly fields: usuariosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for usuarios.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usuariosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reservas<T extends usuarios$reservasArgs<ExtArgs> = {}>(args?: Subset<T, usuarios$reservasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reservasPayload<ExtArgs>, T, "findMany"> | Null>
    roles<T extends rolesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, rolesDefaultArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the usuarios model
   */ 
  interface usuariosFieldRefs {
    readonly id_usuario: FieldRef<"usuarios", 'Int'>
    readonly id_rol: FieldRef<"usuarios", 'Int'>
    readonly nombres: FieldRef<"usuarios", 'String'>
    readonly apellido_paterno: FieldRef<"usuarios", 'String'>
    readonly apellido_materno: FieldRef<"usuarios", 'String'>
    readonly username: FieldRef<"usuarios", 'String'>
    readonly email: FieldRef<"usuarios", 'String'>
    readonly clave: FieldRef<"usuarios", 'String'>
    readonly telefono: FieldRef<"usuarios", 'String'>
    readonly direccion: FieldRef<"usuarios", 'String'>
    readonly sexo: FieldRef<"usuarios", 'String'>
    readonly estado_auditoria: FieldRef<"usuarios", 'String'>
    readonly fecha_creacion: FieldRef<"usuarios", 'DateTime'>
    readonly fecha_modificacion: FieldRef<"usuarios", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * usuarios findUnique
   */
  export type usuariosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuarios
     */
    select?: usuariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosInclude<ExtArgs> | null
    /**
     * Filter, which usuarios to fetch.
     */
    where: usuariosWhereUniqueInput
  }

  /**
   * usuarios findUniqueOrThrow
   */
  export type usuariosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuarios
     */
    select?: usuariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosInclude<ExtArgs> | null
    /**
     * Filter, which usuarios to fetch.
     */
    where: usuariosWhereUniqueInput
  }

  /**
   * usuarios findFirst
   */
  export type usuariosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuarios
     */
    select?: usuariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosInclude<ExtArgs> | null
    /**
     * Filter, which usuarios to fetch.
     */
    where?: usuariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     */
    orderBy?: usuariosOrderByWithRelationInput | usuariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usuarios.
     */
    cursor?: usuariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usuarios.
     */
    distinct?: UsuariosScalarFieldEnum | UsuariosScalarFieldEnum[]
  }

  /**
   * usuarios findFirstOrThrow
   */
  export type usuariosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuarios
     */
    select?: usuariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosInclude<ExtArgs> | null
    /**
     * Filter, which usuarios to fetch.
     */
    where?: usuariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     */
    orderBy?: usuariosOrderByWithRelationInput | usuariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usuarios.
     */
    cursor?: usuariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usuarios.
     */
    distinct?: UsuariosScalarFieldEnum | UsuariosScalarFieldEnum[]
  }

  /**
   * usuarios findMany
   */
  export type usuariosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuarios
     */
    select?: usuariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosInclude<ExtArgs> | null
    /**
     * Filter, which usuarios to fetch.
     */
    where?: usuariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     */
    orderBy?: usuariosOrderByWithRelationInput | usuariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing usuarios.
     */
    cursor?: usuariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     */
    skip?: number
    distinct?: UsuariosScalarFieldEnum | UsuariosScalarFieldEnum[]
  }

  /**
   * usuarios create
   */
  export type usuariosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuarios
     */
    select?: usuariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosInclude<ExtArgs> | null
    /**
     * The data needed to create a usuarios.
     */
    data: XOR<usuariosCreateInput, usuariosUncheckedCreateInput>
  }

  /**
   * usuarios createMany
   */
  export type usuariosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many usuarios.
     */
    data: usuariosCreateManyInput | usuariosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * usuarios createManyAndReturn
   */
  export type usuariosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuarios
     */
    select?: usuariosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many usuarios.
     */
    data: usuariosCreateManyInput | usuariosCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * usuarios update
   */
  export type usuariosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuarios
     */
    select?: usuariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosInclude<ExtArgs> | null
    /**
     * The data needed to update a usuarios.
     */
    data: XOR<usuariosUpdateInput, usuariosUncheckedUpdateInput>
    /**
     * Choose, which usuarios to update.
     */
    where: usuariosWhereUniqueInput
  }

  /**
   * usuarios updateMany
   */
  export type usuariosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update usuarios.
     */
    data: XOR<usuariosUpdateManyMutationInput, usuariosUncheckedUpdateManyInput>
    /**
     * Filter which usuarios to update
     */
    where?: usuariosWhereInput
  }

  /**
   * usuarios upsert
   */
  export type usuariosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuarios
     */
    select?: usuariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosInclude<ExtArgs> | null
    /**
     * The filter to search for the usuarios to update in case it exists.
     */
    where: usuariosWhereUniqueInput
    /**
     * In case the usuarios found by the `where` argument doesn't exist, create a new usuarios with this data.
     */
    create: XOR<usuariosCreateInput, usuariosUncheckedCreateInput>
    /**
     * In case the usuarios was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usuariosUpdateInput, usuariosUncheckedUpdateInput>
  }

  /**
   * usuarios delete
   */
  export type usuariosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuarios
     */
    select?: usuariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosInclude<ExtArgs> | null
    /**
     * Filter which usuarios to delete.
     */
    where: usuariosWhereUniqueInput
  }

  /**
   * usuarios deleteMany
   */
  export type usuariosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which usuarios to delete
     */
    where?: usuariosWhereInput
  }

  /**
   * usuarios.reservas
   */
  export type usuarios$reservasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reservas
     */
    select?: reservasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reservasInclude<ExtArgs> | null
    where?: reservasWhereInput
    orderBy?: reservasOrderByWithRelationInput | reservasOrderByWithRelationInput[]
    cursor?: reservasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReservasScalarFieldEnum | ReservasScalarFieldEnum[]
  }

  /**
   * usuarios without action
   */
  export type usuariosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuarios
     */
    select?: usuariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosInclude<ExtArgs> | null
  }


  /**
   * Model viajes
   */

  export type AggregateViajes = {
    _count: ViajesCountAggregateOutputType | null
    _avg: ViajesAvgAggregateOutputType | null
    _sum: ViajesSumAggregateOutputType | null
    _min: ViajesMinAggregateOutputType | null
    _max: ViajesMaxAggregateOutputType | null
  }

  export type ViajesAvgAggregateOutputType = {
    id_viaje: number | null
    id_destino: number | null
    id_categoria: number | null
    id_hospedaje: number | null
    id_paquete: number | null
    tarifa: Decimal | null
  }

  export type ViajesSumAggregateOutputType = {
    id_viaje: number | null
    id_destino: number | null
    id_categoria: number | null
    id_hospedaje: number | null
    id_paquete: number | null
    tarifa: Decimal | null
  }

  export type ViajesMinAggregateOutputType = {
    id_viaje: number | null
    id_destino: number | null
    id_categoria: number | null
    id_hospedaje: number | null
    id_paquete: number | null
    fecha_inicio: Date | null
    fecha_fin: Date | null
    tarifa: Decimal | null
    estado_auditoria: string | null
    fecha_creacion: Date | null
    fecha_modificacion: Date | null
  }

  export type ViajesMaxAggregateOutputType = {
    id_viaje: number | null
    id_destino: number | null
    id_categoria: number | null
    id_hospedaje: number | null
    id_paquete: number | null
    fecha_inicio: Date | null
    fecha_fin: Date | null
    tarifa: Decimal | null
    estado_auditoria: string | null
    fecha_creacion: Date | null
    fecha_modificacion: Date | null
  }

  export type ViajesCountAggregateOutputType = {
    id_viaje: number
    id_destino: number
    id_categoria: number
    id_hospedaje: number
    id_paquete: number
    fecha_inicio: number
    fecha_fin: number
    tarifa: number
    estado_auditoria: number
    fecha_creacion: number
    fecha_modificacion: number
    _all: number
  }


  export type ViajesAvgAggregateInputType = {
    id_viaje?: true
    id_destino?: true
    id_categoria?: true
    id_hospedaje?: true
    id_paquete?: true
    tarifa?: true
  }

  export type ViajesSumAggregateInputType = {
    id_viaje?: true
    id_destino?: true
    id_categoria?: true
    id_hospedaje?: true
    id_paquete?: true
    tarifa?: true
  }

  export type ViajesMinAggregateInputType = {
    id_viaje?: true
    id_destino?: true
    id_categoria?: true
    id_hospedaje?: true
    id_paquete?: true
    fecha_inicio?: true
    fecha_fin?: true
    tarifa?: true
    estado_auditoria?: true
    fecha_creacion?: true
    fecha_modificacion?: true
  }

  export type ViajesMaxAggregateInputType = {
    id_viaje?: true
    id_destino?: true
    id_categoria?: true
    id_hospedaje?: true
    id_paquete?: true
    fecha_inicio?: true
    fecha_fin?: true
    tarifa?: true
    estado_auditoria?: true
    fecha_creacion?: true
    fecha_modificacion?: true
  }

  export type ViajesCountAggregateInputType = {
    id_viaje?: true
    id_destino?: true
    id_categoria?: true
    id_hospedaje?: true
    id_paquete?: true
    fecha_inicio?: true
    fecha_fin?: true
    tarifa?: true
    estado_auditoria?: true
    fecha_creacion?: true
    fecha_modificacion?: true
    _all?: true
  }

  export type ViajesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which viajes to aggregate.
     */
    where?: viajesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of viajes to fetch.
     */
    orderBy?: viajesOrderByWithRelationInput | viajesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: viajesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` viajes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` viajes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned viajes
    **/
    _count?: true | ViajesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ViajesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ViajesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ViajesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ViajesMaxAggregateInputType
  }

  export type GetViajesAggregateType<T extends ViajesAggregateArgs> = {
        [P in keyof T & keyof AggregateViajes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateViajes[P]>
      : GetScalarType<T[P], AggregateViajes[P]>
  }




  export type viajesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: viajesWhereInput
    orderBy?: viajesOrderByWithAggregationInput | viajesOrderByWithAggregationInput[]
    by: ViajesScalarFieldEnum[] | ViajesScalarFieldEnum
    having?: viajesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ViajesCountAggregateInputType | true
    _avg?: ViajesAvgAggregateInputType
    _sum?: ViajesSumAggregateInputType
    _min?: ViajesMinAggregateInputType
    _max?: ViajesMaxAggregateInputType
  }

  export type ViajesGroupByOutputType = {
    id_viaje: number
    id_destino: number
    id_categoria: number
    id_hospedaje: number
    id_paquete: number
    fecha_inicio: Date | null
    fecha_fin: Date | null
    tarifa: Decimal
    estado_auditoria: string
    fecha_creacion: Date
    fecha_modificacion: Date | null
    _count: ViajesCountAggregateOutputType | null
    _avg: ViajesAvgAggregateOutputType | null
    _sum: ViajesSumAggregateOutputType | null
    _min: ViajesMinAggregateOutputType | null
    _max: ViajesMaxAggregateOutputType | null
  }

  type GetViajesGroupByPayload<T extends viajesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ViajesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ViajesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ViajesGroupByOutputType[P]>
            : GetScalarType<T[P], ViajesGroupByOutputType[P]>
        }
      >
    >


  export type viajesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_viaje?: boolean
    id_destino?: boolean
    id_categoria?: boolean
    id_hospedaje?: boolean
    id_paquete?: boolean
    fecha_inicio?: boolean
    fecha_fin?: boolean
    tarifa?: boolean
    estado_auditoria?: boolean
    fecha_creacion?: boolean
    fecha_modificacion?: boolean
    itinerarios?: boolean | viajes$itinerariosArgs<ExtArgs>
    reservas?: boolean | viajes$reservasArgs<ExtArgs>
    categorias?: boolean | categoriasDefaultArgs<ExtArgs>
    destinos?: boolean | destinosDefaultArgs<ExtArgs>
    hospedajes?: boolean | hospedajesDefaultArgs<ExtArgs>
    paquetes?: boolean | paquetesDefaultArgs<ExtArgs>
    _count?: boolean | ViajesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["viajes"]>

  export type viajesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_viaje?: boolean
    id_destino?: boolean
    id_categoria?: boolean
    id_hospedaje?: boolean
    id_paquete?: boolean
    fecha_inicio?: boolean
    fecha_fin?: boolean
    tarifa?: boolean
    estado_auditoria?: boolean
    fecha_creacion?: boolean
    fecha_modificacion?: boolean
    categorias?: boolean | categoriasDefaultArgs<ExtArgs>
    destinos?: boolean | destinosDefaultArgs<ExtArgs>
    hospedajes?: boolean | hospedajesDefaultArgs<ExtArgs>
    paquetes?: boolean | paquetesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["viajes"]>

  export type viajesSelectScalar = {
    id_viaje?: boolean
    id_destino?: boolean
    id_categoria?: boolean
    id_hospedaje?: boolean
    id_paquete?: boolean
    fecha_inicio?: boolean
    fecha_fin?: boolean
    tarifa?: boolean
    estado_auditoria?: boolean
    fecha_creacion?: boolean
    fecha_modificacion?: boolean
  }

  export type viajesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itinerarios?: boolean | viajes$itinerariosArgs<ExtArgs>
    reservas?: boolean | viajes$reservasArgs<ExtArgs>
    categorias?: boolean | categoriasDefaultArgs<ExtArgs>
    destinos?: boolean | destinosDefaultArgs<ExtArgs>
    hospedajes?: boolean | hospedajesDefaultArgs<ExtArgs>
    paquetes?: boolean | paquetesDefaultArgs<ExtArgs>
    _count?: boolean | ViajesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type viajesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categorias?: boolean | categoriasDefaultArgs<ExtArgs>
    destinos?: boolean | destinosDefaultArgs<ExtArgs>
    hospedajes?: boolean | hospedajesDefaultArgs<ExtArgs>
    paquetes?: boolean | paquetesDefaultArgs<ExtArgs>
  }

  export type $viajesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "viajes"
    objects: {
      itinerarios: Prisma.$itinerariosPayload<ExtArgs>[]
      reservas: Prisma.$reservasPayload<ExtArgs>[]
      categorias: Prisma.$categoriasPayload<ExtArgs>
      destinos: Prisma.$destinosPayload<ExtArgs>
      hospedajes: Prisma.$hospedajesPayload<ExtArgs>
      paquetes: Prisma.$paquetesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_viaje: number
      id_destino: number
      id_categoria: number
      id_hospedaje: number
      id_paquete: number
      fecha_inicio: Date | null
      fecha_fin: Date | null
      tarifa: Prisma.Decimal
      estado_auditoria: string
      fecha_creacion: Date
      fecha_modificacion: Date | null
    }, ExtArgs["result"]["viajes"]>
    composites: {}
  }

  type viajesGetPayload<S extends boolean | null | undefined | viajesDefaultArgs> = $Result.GetResult<Prisma.$viajesPayload, S>

  type viajesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<viajesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ViajesCountAggregateInputType | true
    }

  export interface viajesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['viajes'], meta: { name: 'viajes' } }
    /**
     * Find zero or one Viajes that matches the filter.
     * @param {viajesFindUniqueArgs} args - Arguments to find a Viajes
     * @example
     * // Get one Viajes
     * const viajes = await prisma.viajes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends viajesFindUniqueArgs>(args: SelectSubset<T, viajesFindUniqueArgs<ExtArgs>>): Prisma__viajesClient<$Result.GetResult<Prisma.$viajesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Viajes that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {viajesFindUniqueOrThrowArgs} args - Arguments to find a Viajes
     * @example
     * // Get one Viajes
     * const viajes = await prisma.viajes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends viajesFindUniqueOrThrowArgs>(args: SelectSubset<T, viajesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__viajesClient<$Result.GetResult<Prisma.$viajesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Viajes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {viajesFindFirstArgs} args - Arguments to find a Viajes
     * @example
     * // Get one Viajes
     * const viajes = await prisma.viajes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends viajesFindFirstArgs>(args?: SelectSubset<T, viajesFindFirstArgs<ExtArgs>>): Prisma__viajesClient<$Result.GetResult<Prisma.$viajesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Viajes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {viajesFindFirstOrThrowArgs} args - Arguments to find a Viajes
     * @example
     * // Get one Viajes
     * const viajes = await prisma.viajes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends viajesFindFirstOrThrowArgs>(args?: SelectSubset<T, viajesFindFirstOrThrowArgs<ExtArgs>>): Prisma__viajesClient<$Result.GetResult<Prisma.$viajesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Viajes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {viajesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Viajes
     * const viajes = await prisma.viajes.findMany()
     * 
     * // Get first 10 Viajes
     * const viajes = await prisma.viajes.findMany({ take: 10 })
     * 
     * // Only select the `id_viaje`
     * const viajesWithId_viajeOnly = await prisma.viajes.findMany({ select: { id_viaje: true } })
     * 
     */
    findMany<T extends viajesFindManyArgs>(args?: SelectSubset<T, viajesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$viajesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Viajes.
     * @param {viajesCreateArgs} args - Arguments to create a Viajes.
     * @example
     * // Create one Viajes
     * const Viajes = await prisma.viajes.create({
     *   data: {
     *     // ... data to create a Viajes
     *   }
     * })
     * 
     */
    create<T extends viajesCreateArgs>(args: SelectSubset<T, viajesCreateArgs<ExtArgs>>): Prisma__viajesClient<$Result.GetResult<Prisma.$viajesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Viajes.
     * @param {viajesCreateManyArgs} args - Arguments to create many Viajes.
     * @example
     * // Create many Viajes
     * const viajes = await prisma.viajes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends viajesCreateManyArgs>(args?: SelectSubset<T, viajesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Viajes and returns the data saved in the database.
     * @param {viajesCreateManyAndReturnArgs} args - Arguments to create many Viajes.
     * @example
     * // Create many Viajes
     * const viajes = await prisma.viajes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Viajes and only return the `id_viaje`
     * const viajesWithId_viajeOnly = await prisma.viajes.createManyAndReturn({ 
     *   select: { id_viaje: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends viajesCreateManyAndReturnArgs>(args?: SelectSubset<T, viajesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$viajesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Viajes.
     * @param {viajesDeleteArgs} args - Arguments to delete one Viajes.
     * @example
     * // Delete one Viajes
     * const Viajes = await prisma.viajes.delete({
     *   where: {
     *     // ... filter to delete one Viajes
     *   }
     * })
     * 
     */
    delete<T extends viajesDeleteArgs>(args: SelectSubset<T, viajesDeleteArgs<ExtArgs>>): Prisma__viajesClient<$Result.GetResult<Prisma.$viajesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Viajes.
     * @param {viajesUpdateArgs} args - Arguments to update one Viajes.
     * @example
     * // Update one Viajes
     * const viajes = await prisma.viajes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends viajesUpdateArgs>(args: SelectSubset<T, viajesUpdateArgs<ExtArgs>>): Prisma__viajesClient<$Result.GetResult<Prisma.$viajesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Viajes.
     * @param {viajesDeleteManyArgs} args - Arguments to filter Viajes to delete.
     * @example
     * // Delete a few Viajes
     * const { count } = await prisma.viajes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends viajesDeleteManyArgs>(args?: SelectSubset<T, viajesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Viajes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {viajesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Viajes
     * const viajes = await prisma.viajes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends viajesUpdateManyArgs>(args: SelectSubset<T, viajesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Viajes.
     * @param {viajesUpsertArgs} args - Arguments to update or create a Viajes.
     * @example
     * // Update or create a Viajes
     * const viajes = await prisma.viajes.upsert({
     *   create: {
     *     // ... data to create a Viajes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Viajes we want to update
     *   }
     * })
     */
    upsert<T extends viajesUpsertArgs>(args: SelectSubset<T, viajesUpsertArgs<ExtArgs>>): Prisma__viajesClient<$Result.GetResult<Prisma.$viajesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Viajes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {viajesCountArgs} args - Arguments to filter Viajes to count.
     * @example
     * // Count the number of Viajes
     * const count = await prisma.viajes.count({
     *   where: {
     *     // ... the filter for the Viajes we want to count
     *   }
     * })
    **/
    count<T extends viajesCountArgs>(
      args?: Subset<T, viajesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ViajesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Viajes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViajesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ViajesAggregateArgs>(args: Subset<T, ViajesAggregateArgs>): Prisma.PrismaPromise<GetViajesAggregateType<T>>

    /**
     * Group by Viajes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {viajesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends viajesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: viajesGroupByArgs['orderBy'] }
        : { orderBy?: viajesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, viajesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetViajesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the viajes model
   */
  readonly fields: viajesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for viajes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__viajesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    itinerarios<T extends viajes$itinerariosArgs<ExtArgs> = {}>(args?: Subset<T, viajes$itinerariosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$itinerariosPayload<ExtArgs>, T, "findMany"> | Null>
    reservas<T extends viajes$reservasArgs<ExtArgs> = {}>(args?: Subset<T, viajes$reservasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reservasPayload<ExtArgs>, T, "findMany"> | Null>
    categorias<T extends categoriasDefaultArgs<ExtArgs> = {}>(args?: Subset<T, categoriasDefaultArgs<ExtArgs>>): Prisma__categoriasClient<$Result.GetResult<Prisma.$categoriasPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    destinos<T extends destinosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, destinosDefaultArgs<ExtArgs>>): Prisma__destinosClient<$Result.GetResult<Prisma.$destinosPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    hospedajes<T extends hospedajesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, hospedajesDefaultArgs<ExtArgs>>): Prisma__hospedajesClient<$Result.GetResult<Prisma.$hospedajesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    paquetes<T extends paquetesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, paquetesDefaultArgs<ExtArgs>>): Prisma__paquetesClient<$Result.GetResult<Prisma.$paquetesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the viajes model
   */ 
  interface viajesFieldRefs {
    readonly id_viaje: FieldRef<"viajes", 'Int'>
    readonly id_destino: FieldRef<"viajes", 'Int'>
    readonly id_categoria: FieldRef<"viajes", 'Int'>
    readonly id_hospedaje: FieldRef<"viajes", 'Int'>
    readonly id_paquete: FieldRef<"viajes", 'Int'>
    readonly fecha_inicio: FieldRef<"viajes", 'DateTime'>
    readonly fecha_fin: FieldRef<"viajes", 'DateTime'>
    readonly tarifa: FieldRef<"viajes", 'Decimal'>
    readonly estado_auditoria: FieldRef<"viajes", 'String'>
    readonly fecha_creacion: FieldRef<"viajes", 'DateTime'>
    readonly fecha_modificacion: FieldRef<"viajes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * viajes findUnique
   */
  export type viajesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viajes
     */
    select?: viajesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: viajesInclude<ExtArgs> | null
    /**
     * Filter, which viajes to fetch.
     */
    where: viajesWhereUniqueInput
  }

  /**
   * viajes findUniqueOrThrow
   */
  export type viajesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viajes
     */
    select?: viajesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: viajesInclude<ExtArgs> | null
    /**
     * Filter, which viajes to fetch.
     */
    where: viajesWhereUniqueInput
  }

  /**
   * viajes findFirst
   */
  export type viajesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viajes
     */
    select?: viajesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: viajesInclude<ExtArgs> | null
    /**
     * Filter, which viajes to fetch.
     */
    where?: viajesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of viajes to fetch.
     */
    orderBy?: viajesOrderByWithRelationInput | viajesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for viajes.
     */
    cursor?: viajesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` viajes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` viajes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of viajes.
     */
    distinct?: ViajesScalarFieldEnum | ViajesScalarFieldEnum[]
  }

  /**
   * viajes findFirstOrThrow
   */
  export type viajesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viajes
     */
    select?: viajesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: viajesInclude<ExtArgs> | null
    /**
     * Filter, which viajes to fetch.
     */
    where?: viajesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of viajes to fetch.
     */
    orderBy?: viajesOrderByWithRelationInput | viajesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for viajes.
     */
    cursor?: viajesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` viajes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` viajes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of viajes.
     */
    distinct?: ViajesScalarFieldEnum | ViajesScalarFieldEnum[]
  }

  /**
   * viajes findMany
   */
  export type viajesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viajes
     */
    select?: viajesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: viajesInclude<ExtArgs> | null
    /**
     * Filter, which viajes to fetch.
     */
    where?: viajesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of viajes to fetch.
     */
    orderBy?: viajesOrderByWithRelationInput | viajesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing viajes.
     */
    cursor?: viajesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` viajes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` viajes.
     */
    skip?: number
    distinct?: ViajesScalarFieldEnum | ViajesScalarFieldEnum[]
  }

  /**
   * viajes create
   */
  export type viajesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viajes
     */
    select?: viajesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: viajesInclude<ExtArgs> | null
    /**
     * The data needed to create a viajes.
     */
    data: XOR<viajesCreateInput, viajesUncheckedCreateInput>
  }

  /**
   * viajes createMany
   */
  export type viajesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many viajes.
     */
    data: viajesCreateManyInput | viajesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * viajes createManyAndReturn
   */
  export type viajesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viajes
     */
    select?: viajesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many viajes.
     */
    data: viajesCreateManyInput | viajesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: viajesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * viajes update
   */
  export type viajesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viajes
     */
    select?: viajesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: viajesInclude<ExtArgs> | null
    /**
     * The data needed to update a viajes.
     */
    data: XOR<viajesUpdateInput, viajesUncheckedUpdateInput>
    /**
     * Choose, which viajes to update.
     */
    where: viajesWhereUniqueInput
  }

  /**
   * viajes updateMany
   */
  export type viajesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update viajes.
     */
    data: XOR<viajesUpdateManyMutationInput, viajesUncheckedUpdateManyInput>
    /**
     * Filter which viajes to update
     */
    where?: viajesWhereInput
  }

  /**
   * viajes upsert
   */
  export type viajesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viajes
     */
    select?: viajesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: viajesInclude<ExtArgs> | null
    /**
     * The filter to search for the viajes to update in case it exists.
     */
    where: viajesWhereUniqueInput
    /**
     * In case the viajes found by the `where` argument doesn't exist, create a new viajes with this data.
     */
    create: XOR<viajesCreateInput, viajesUncheckedCreateInput>
    /**
     * In case the viajes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<viajesUpdateInput, viajesUncheckedUpdateInput>
  }

  /**
   * viajes delete
   */
  export type viajesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viajes
     */
    select?: viajesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: viajesInclude<ExtArgs> | null
    /**
     * Filter which viajes to delete.
     */
    where: viajesWhereUniqueInput
  }

  /**
   * viajes deleteMany
   */
  export type viajesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which viajes to delete
     */
    where?: viajesWhereInput
  }

  /**
   * viajes.itinerarios
   */
  export type viajes$itinerariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itinerarios
     */
    select?: itinerariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itinerariosInclude<ExtArgs> | null
    where?: itinerariosWhereInput
    orderBy?: itinerariosOrderByWithRelationInput | itinerariosOrderByWithRelationInput[]
    cursor?: itinerariosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItinerariosScalarFieldEnum | ItinerariosScalarFieldEnum[]
  }

  /**
   * viajes.reservas
   */
  export type viajes$reservasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reservas
     */
    select?: reservasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reservasInclude<ExtArgs> | null
    where?: reservasWhereInput
    orderBy?: reservasOrderByWithRelationInput | reservasOrderByWithRelationInput[]
    cursor?: reservasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReservasScalarFieldEnum | ReservasScalarFieldEnum[]
  }

  /**
   * viajes without action
   */
  export type viajesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viajes
     */
    select?: viajesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: viajesInclude<ExtArgs> | null
  }


  /**
   * Model itinerarios
   */

  export type AggregateItinerarios = {
    _count: ItinerariosCountAggregateOutputType | null
    _avg: ItinerariosAvgAggregateOutputType | null
    _sum: ItinerariosSumAggregateOutputType | null
    _min: ItinerariosMinAggregateOutputType | null
    _max: ItinerariosMaxAggregateOutputType | null
  }

  export type ItinerariosAvgAggregateOutputType = {
    id_itenerario: number | null
    id_viaje: number | null
  }

  export type ItinerariosSumAggregateOutputType = {
    id_itenerario: number | null
    id_viaje: number | null
  }

  export type ItinerariosMinAggregateOutputType = {
    id_itenerario: number | null
    id_viaje: number | null
    dia: string | null
    hora_inicio: string | null
    hora_fin: string | null
    actividad: string | null
    descripcion: string | null
    estado_auditoria: string | null
    fecha_creacion: Date | null
    fecha_modificacion: Date | null
  }

  export type ItinerariosMaxAggregateOutputType = {
    id_itenerario: number | null
    id_viaje: number | null
    dia: string | null
    hora_inicio: string | null
    hora_fin: string | null
    actividad: string | null
    descripcion: string | null
    estado_auditoria: string | null
    fecha_creacion: Date | null
    fecha_modificacion: Date | null
  }

  export type ItinerariosCountAggregateOutputType = {
    id_itenerario: number
    id_viaje: number
    dia: number
    hora_inicio: number
    hora_fin: number
    actividad: number
    descripcion: number
    estado_auditoria: number
    fecha_creacion: number
    fecha_modificacion: number
    _all: number
  }


  export type ItinerariosAvgAggregateInputType = {
    id_itenerario?: true
    id_viaje?: true
  }

  export type ItinerariosSumAggregateInputType = {
    id_itenerario?: true
    id_viaje?: true
  }

  export type ItinerariosMinAggregateInputType = {
    id_itenerario?: true
    id_viaje?: true
    dia?: true
    hora_inicio?: true
    hora_fin?: true
    actividad?: true
    descripcion?: true
    estado_auditoria?: true
    fecha_creacion?: true
    fecha_modificacion?: true
  }

  export type ItinerariosMaxAggregateInputType = {
    id_itenerario?: true
    id_viaje?: true
    dia?: true
    hora_inicio?: true
    hora_fin?: true
    actividad?: true
    descripcion?: true
    estado_auditoria?: true
    fecha_creacion?: true
    fecha_modificacion?: true
  }

  export type ItinerariosCountAggregateInputType = {
    id_itenerario?: true
    id_viaje?: true
    dia?: true
    hora_inicio?: true
    hora_fin?: true
    actividad?: true
    descripcion?: true
    estado_auditoria?: true
    fecha_creacion?: true
    fecha_modificacion?: true
    _all?: true
  }

  export type ItinerariosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which itinerarios to aggregate.
     */
    where?: itinerariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of itinerarios to fetch.
     */
    orderBy?: itinerariosOrderByWithRelationInput | itinerariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: itinerariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` itinerarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` itinerarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned itinerarios
    **/
    _count?: true | ItinerariosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItinerariosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItinerariosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItinerariosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItinerariosMaxAggregateInputType
  }

  export type GetItinerariosAggregateType<T extends ItinerariosAggregateArgs> = {
        [P in keyof T & keyof AggregateItinerarios]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItinerarios[P]>
      : GetScalarType<T[P], AggregateItinerarios[P]>
  }




  export type itinerariosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: itinerariosWhereInput
    orderBy?: itinerariosOrderByWithAggregationInput | itinerariosOrderByWithAggregationInput[]
    by: ItinerariosScalarFieldEnum[] | ItinerariosScalarFieldEnum
    having?: itinerariosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItinerariosCountAggregateInputType | true
    _avg?: ItinerariosAvgAggregateInputType
    _sum?: ItinerariosSumAggregateInputType
    _min?: ItinerariosMinAggregateInputType
    _max?: ItinerariosMaxAggregateInputType
  }

  export type ItinerariosGroupByOutputType = {
    id_itenerario: number
    id_viaje: number
    dia: string
    hora_inicio: string
    hora_fin: string
    actividad: string
    descripcion: string
    estado_auditoria: string
    fecha_creacion: Date
    fecha_modificacion: Date | null
    _count: ItinerariosCountAggregateOutputType | null
    _avg: ItinerariosAvgAggregateOutputType | null
    _sum: ItinerariosSumAggregateOutputType | null
    _min: ItinerariosMinAggregateOutputType | null
    _max: ItinerariosMaxAggregateOutputType | null
  }

  type GetItinerariosGroupByPayload<T extends itinerariosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItinerariosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItinerariosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItinerariosGroupByOutputType[P]>
            : GetScalarType<T[P], ItinerariosGroupByOutputType[P]>
        }
      >
    >


  export type itinerariosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_itenerario?: boolean
    id_viaje?: boolean
    dia?: boolean
    hora_inicio?: boolean
    hora_fin?: boolean
    actividad?: boolean
    descripcion?: boolean
    estado_auditoria?: boolean
    fecha_creacion?: boolean
    fecha_modificacion?: boolean
    viajes?: boolean | viajesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itinerarios"]>

  export type itinerariosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_itenerario?: boolean
    id_viaje?: boolean
    dia?: boolean
    hora_inicio?: boolean
    hora_fin?: boolean
    actividad?: boolean
    descripcion?: boolean
    estado_auditoria?: boolean
    fecha_creacion?: boolean
    fecha_modificacion?: boolean
    viajes?: boolean | viajesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itinerarios"]>

  export type itinerariosSelectScalar = {
    id_itenerario?: boolean
    id_viaje?: boolean
    dia?: boolean
    hora_inicio?: boolean
    hora_fin?: boolean
    actividad?: boolean
    descripcion?: boolean
    estado_auditoria?: boolean
    fecha_creacion?: boolean
    fecha_modificacion?: boolean
  }

  export type itinerariosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    viajes?: boolean | viajesDefaultArgs<ExtArgs>
  }
  export type itinerariosIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    viajes?: boolean | viajesDefaultArgs<ExtArgs>
  }

  export type $itinerariosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "itinerarios"
    objects: {
      viajes: Prisma.$viajesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_itenerario: number
      id_viaje: number
      dia: string
      hora_inicio: string
      hora_fin: string
      actividad: string
      descripcion: string
      estado_auditoria: string
      fecha_creacion: Date
      fecha_modificacion: Date | null
    }, ExtArgs["result"]["itinerarios"]>
    composites: {}
  }

  type itinerariosGetPayload<S extends boolean | null | undefined | itinerariosDefaultArgs> = $Result.GetResult<Prisma.$itinerariosPayload, S>

  type itinerariosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<itinerariosFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ItinerariosCountAggregateInputType | true
    }

  export interface itinerariosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['itinerarios'], meta: { name: 'itinerarios' } }
    /**
     * Find zero or one Itinerarios that matches the filter.
     * @param {itinerariosFindUniqueArgs} args - Arguments to find a Itinerarios
     * @example
     * // Get one Itinerarios
     * const itinerarios = await prisma.itinerarios.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends itinerariosFindUniqueArgs>(args: SelectSubset<T, itinerariosFindUniqueArgs<ExtArgs>>): Prisma__itinerariosClient<$Result.GetResult<Prisma.$itinerariosPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Itinerarios that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {itinerariosFindUniqueOrThrowArgs} args - Arguments to find a Itinerarios
     * @example
     * // Get one Itinerarios
     * const itinerarios = await prisma.itinerarios.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends itinerariosFindUniqueOrThrowArgs>(args: SelectSubset<T, itinerariosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__itinerariosClient<$Result.GetResult<Prisma.$itinerariosPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Itinerarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itinerariosFindFirstArgs} args - Arguments to find a Itinerarios
     * @example
     * // Get one Itinerarios
     * const itinerarios = await prisma.itinerarios.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends itinerariosFindFirstArgs>(args?: SelectSubset<T, itinerariosFindFirstArgs<ExtArgs>>): Prisma__itinerariosClient<$Result.GetResult<Prisma.$itinerariosPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Itinerarios that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itinerariosFindFirstOrThrowArgs} args - Arguments to find a Itinerarios
     * @example
     * // Get one Itinerarios
     * const itinerarios = await prisma.itinerarios.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends itinerariosFindFirstOrThrowArgs>(args?: SelectSubset<T, itinerariosFindFirstOrThrowArgs<ExtArgs>>): Prisma__itinerariosClient<$Result.GetResult<Prisma.$itinerariosPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Itinerarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itinerariosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Itinerarios
     * const itinerarios = await prisma.itinerarios.findMany()
     * 
     * // Get first 10 Itinerarios
     * const itinerarios = await prisma.itinerarios.findMany({ take: 10 })
     * 
     * // Only select the `id_itenerario`
     * const itinerariosWithId_itenerarioOnly = await prisma.itinerarios.findMany({ select: { id_itenerario: true } })
     * 
     */
    findMany<T extends itinerariosFindManyArgs>(args?: SelectSubset<T, itinerariosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$itinerariosPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Itinerarios.
     * @param {itinerariosCreateArgs} args - Arguments to create a Itinerarios.
     * @example
     * // Create one Itinerarios
     * const Itinerarios = await prisma.itinerarios.create({
     *   data: {
     *     // ... data to create a Itinerarios
     *   }
     * })
     * 
     */
    create<T extends itinerariosCreateArgs>(args: SelectSubset<T, itinerariosCreateArgs<ExtArgs>>): Prisma__itinerariosClient<$Result.GetResult<Prisma.$itinerariosPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Itinerarios.
     * @param {itinerariosCreateManyArgs} args - Arguments to create many Itinerarios.
     * @example
     * // Create many Itinerarios
     * const itinerarios = await prisma.itinerarios.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends itinerariosCreateManyArgs>(args?: SelectSubset<T, itinerariosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Itinerarios and returns the data saved in the database.
     * @param {itinerariosCreateManyAndReturnArgs} args - Arguments to create many Itinerarios.
     * @example
     * // Create many Itinerarios
     * const itinerarios = await prisma.itinerarios.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Itinerarios and only return the `id_itenerario`
     * const itinerariosWithId_itenerarioOnly = await prisma.itinerarios.createManyAndReturn({ 
     *   select: { id_itenerario: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends itinerariosCreateManyAndReturnArgs>(args?: SelectSubset<T, itinerariosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$itinerariosPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Itinerarios.
     * @param {itinerariosDeleteArgs} args - Arguments to delete one Itinerarios.
     * @example
     * // Delete one Itinerarios
     * const Itinerarios = await prisma.itinerarios.delete({
     *   where: {
     *     // ... filter to delete one Itinerarios
     *   }
     * })
     * 
     */
    delete<T extends itinerariosDeleteArgs>(args: SelectSubset<T, itinerariosDeleteArgs<ExtArgs>>): Prisma__itinerariosClient<$Result.GetResult<Prisma.$itinerariosPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Itinerarios.
     * @param {itinerariosUpdateArgs} args - Arguments to update one Itinerarios.
     * @example
     * // Update one Itinerarios
     * const itinerarios = await prisma.itinerarios.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends itinerariosUpdateArgs>(args: SelectSubset<T, itinerariosUpdateArgs<ExtArgs>>): Prisma__itinerariosClient<$Result.GetResult<Prisma.$itinerariosPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Itinerarios.
     * @param {itinerariosDeleteManyArgs} args - Arguments to filter Itinerarios to delete.
     * @example
     * // Delete a few Itinerarios
     * const { count } = await prisma.itinerarios.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends itinerariosDeleteManyArgs>(args?: SelectSubset<T, itinerariosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Itinerarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itinerariosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Itinerarios
     * const itinerarios = await prisma.itinerarios.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends itinerariosUpdateManyArgs>(args: SelectSubset<T, itinerariosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Itinerarios.
     * @param {itinerariosUpsertArgs} args - Arguments to update or create a Itinerarios.
     * @example
     * // Update or create a Itinerarios
     * const itinerarios = await prisma.itinerarios.upsert({
     *   create: {
     *     // ... data to create a Itinerarios
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Itinerarios we want to update
     *   }
     * })
     */
    upsert<T extends itinerariosUpsertArgs>(args: SelectSubset<T, itinerariosUpsertArgs<ExtArgs>>): Prisma__itinerariosClient<$Result.GetResult<Prisma.$itinerariosPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Itinerarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itinerariosCountArgs} args - Arguments to filter Itinerarios to count.
     * @example
     * // Count the number of Itinerarios
     * const count = await prisma.itinerarios.count({
     *   where: {
     *     // ... the filter for the Itinerarios we want to count
     *   }
     * })
    **/
    count<T extends itinerariosCountArgs>(
      args?: Subset<T, itinerariosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItinerariosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Itinerarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItinerariosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItinerariosAggregateArgs>(args: Subset<T, ItinerariosAggregateArgs>): Prisma.PrismaPromise<GetItinerariosAggregateType<T>>

    /**
     * Group by Itinerarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itinerariosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends itinerariosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: itinerariosGroupByArgs['orderBy'] }
        : { orderBy?: itinerariosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, itinerariosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItinerariosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the itinerarios model
   */
  readonly fields: itinerariosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for itinerarios.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__itinerariosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    viajes<T extends viajesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, viajesDefaultArgs<ExtArgs>>): Prisma__viajesClient<$Result.GetResult<Prisma.$viajesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the itinerarios model
   */ 
  interface itinerariosFieldRefs {
    readonly id_itenerario: FieldRef<"itinerarios", 'Int'>
    readonly id_viaje: FieldRef<"itinerarios", 'Int'>
    readonly dia: FieldRef<"itinerarios", 'String'>
    readonly hora_inicio: FieldRef<"itinerarios", 'String'>
    readonly hora_fin: FieldRef<"itinerarios", 'String'>
    readonly actividad: FieldRef<"itinerarios", 'String'>
    readonly descripcion: FieldRef<"itinerarios", 'String'>
    readonly estado_auditoria: FieldRef<"itinerarios", 'String'>
    readonly fecha_creacion: FieldRef<"itinerarios", 'DateTime'>
    readonly fecha_modificacion: FieldRef<"itinerarios", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * itinerarios findUnique
   */
  export type itinerariosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itinerarios
     */
    select?: itinerariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itinerariosInclude<ExtArgs> | null
    /**
     * Filter, which itinerarios to fetch.
     */
    where: itinerariosWhereUniqueInput
  }

  /**
   * itinerarios findUniqueOrThrow
   */
  export type itinerariosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itinerarios
     */
    select?: itinerariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itinerariosInclude<ExtArgs> | null
    /**
     * Filter, which itinerarios to fetch.
     */
    where: itinerariosWhereUniqueInput
  }

  /**
   * itinerarios findFirst
   */
  export type itinerariosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itinerarios
     */
    select?: itinerariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itinerariosInclude<ExtArgs> | null
    /**
     * Filter, which itinerarios to fetch.
     */
    where?: itinerariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of itinerarios to fetch.
     */
    orderBy?: itinerariosOrderByWithRelationInput | itinerariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for itinerarios.
     */
    cursor?: itinerariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` itinerarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` itinerarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of itinerarios.
     */
    distinct?: ItinerariosScalarFieldEnum | ItinerariosScalarFieldEnum[]
  }

  /**
   * itinerarios findFirstOrThrow
   */
  export type itinerariosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itinerarios
     */
    select?: itinerariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itinerariosInclude<ExtArgs> | null
    /**
     * Filter, which itinerarios to fetch.
     */
    where?: itinerariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of itinerarios to fetch.
     */
    orderBy?: itinerariosOrderByWithRelationInput | itinerariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for itinerarios.
     */
    cursor?: itinerariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` itinerarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` itinerarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of itinerarios.
     */
    distinct?: ItinerariosScalarFieldEnum | ItinerariosScalarFieldEnum[]
  }

  /**
   * itinerarios findMany
   */
  export type itinerariosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itinerarios
     */
    select?: itinerariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itinerariosInclude<ExtArgs> | null
    /**
     * Filter, which itinerarios to fetch.
     */
    where?: itinerariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of itinerarios to fetch.
     */
    orderBy?: itinerariosOrderByWithRelationInput | itinerariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing itinerarios.
     */
    cursor?: itinerariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` itinerarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` itinerarios.
     */
    skip?: number
    distinct?: ItinerariosScalarFieldEnum | ItinerariosScalarFieldEnum[]
  }

  /**
   * itinerarios create
   */
  export type itinerariosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itinerarios
     */
    select?: itinerariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itinerariosInclude<ExtArgs> | null
    /**
     * The data needed to create a itinerarios.
     */
    data: XOR<itinerariosCreateInput, itinerariosUncheckedCreateInput>
  }

  /**
   * itinerarios createMany
   */
  export type itinerariosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many itinerarios.
     */
    data: itinerariosCreateManyInput | itinerariosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * itinerarios createManyAndReturn
   */
  export type itinerariosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itinerarios
     */
    select?: itinerariosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many itinerarios.
     */
    data: itinerariosCreateManyInput | itinerariosCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itinerariosIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * itinerarios update
   */
  export type itinerariosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itinerarios
     */
    select?: itinerariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itinerariosInclude<ExtArgs> | null
    /**
     * The data needed to update a itinerarios.
     */
    data: XOR<itinerariosUpdateInput, itinerariosUncheckedUpdateInput>
    /**
     * Choose, which itinerarios to update.
     */
    where: itinerariosWhereUniqueInput
  }

  /**
   * itinerarios updateMany
   */
  export type itinerariosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update itinerarios.
     */
    data: XOR<itinerariosUpdateManyMutationInput, itinerariosUncheckedUpdateManyInput>
    /**
     * Filter which itinerarios to update
     */
    where?: itinerariosWhereInput
  }

  /**
   * itinerarios upsert
   */
  export type itinerariosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itinerarios
     */
    select?: itinerariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itinerariosInclude<ExtArgs> | null
    /**
     * The filter to search for the itinerarios to update in case it exists.
     */
    where: itinerariosWhereUniqueInput
    /**
     * In case the itinerarios found by the `where` argument doesn't exist, create a new itinerarios with this data.
     */
    create: XOR<itinerariosCreateInput, itinerariosUncheckedCreateInput>
    /**
     * In case the itinerarios was found with the provided `where` argument, update it with this data.
     */
    update: XOR<itinerariosUpdateInput, itinerariosUncheckedUpdateInput>
  }

  /**
   * itinerarios delete
   */
  export type itinerariosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itinerarios
     */
    select?: itinerariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itinerariosInclude<ExtArgs> | null
    /**
     * Filter which itinerarios to delete.
     */
    where: itinerariosWhereUniqueInput
  }

  /**
   * itinerarios deleteMany
   */
  export type itinerariosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which itinerarios to delete
     */
    where?: itinerariosWhereInput
  }

  /**
   * itinerarios without action
   */
  export type itinerariosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itinerarios
     */
    select?: itinerariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itinerariosInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CategoriasScalarFieldEnum: {
    id_categoria: 'id_categoria',
    nombre: 'nombre',
    estado_auditoria: 'estado_auditoria',
    fecha_creacion: 'fecha_creacion',
    fecha_modificacion: 'fecha_modificacion'
  };

  export type CategoriasScalarFieldEnum = (typeof CategoriasScalarFieldEnum)[keyof typeof CategoriasScalarFieldEnum]


  export const PaisesScalarFieldEnum: {
    id_pais: 'id_pais',
    nombre: 'nombre',
    estado_auditoria: 'estado_auditoria',
    fecha_creacion: 'fecha_creacion',
    fecha_modificacion: 'fecha_modificacion'
  };

  export type PaisesScalarFieldEnum = (typeof PaisesScalarFieldEnum)[keyof typeof PaisesScalarFieldEnum]


  export const PaquetesScalarFieldEnum: {
    id_paquete: 'id_paquete',
    id_hospedaje: 'id_hospedaje',
    id_categoria: 'id_categoria',
    nombre: 'nombre',
    transporte: 'transporte',
    precio: 'precio',
    estado_auditoria: 'estado_auditoria',
    fecha_modificacion: 'fecha_modificacion',
    fecha_creacion: 'fecha_creacion'
  };

  export type PaquetesScalarFieldEnum = (typeof PaquetesScalarFieldEnum)[keyof typeof PaquetesScalarFieldEnum]


  export const RolesScalarFieldEnum: {
    id_rol: 'id_rol',
    nombre: 'nombre',
    estado_auditoria: 'estado_auditoria',
    fecha_creacion: 'fecha_creacion',
    fecha_modificacion: 'fecha_modificacion'
  };

  export type RolesScalarFieldEnum = (typeof RolesScalarFieldEnum)[keyof typeof RolesScalarFieldEnum]


  export const DestinosScalarFieldEnum: {
    id_destino: 'id_destino',
    id_pais: 'id_pais',
    nombre: 'nombre',
    estado_auditoria: 'estado_auditoria',
    fecha_creacion: 'fecha_creacion',
    fecha_modificacion: 'fecha_modificacion'
  };

  export type DestinosScalarFieldEnum = (typeof DestinosScalarFieldEnum)[keyof typeof DestinosScalarFieldEnum]


  export const HospedajesScalarFieldEnum: {
    id_hospedaje: 'id_hospedaje',
    id_destino: 'id_destino',
    nombre: 'nombre',
    precio: 'precio',
    estado_auditoria: 'estado_auditoria',
    fecha_creacion: 'fecha_creacion',
    fecha_modificacion: 'fecha_modificacion'
  };

  export type HospedajesScalarFieldEnum = (typeof HospedajesScalarFieldEnum)[keyof typeof HospedajesScalarFieldEnum]


  export const ReservasScalarFieldEnum: {
    id_reserva: 'id_reserva',
    id_usuario: 'id_usuario',
    id_viaje: 'id_viaje',
    numero_personas: 'numero_personas',
    metodo_pago: 'metodo_pago',
    pago_total: 'pago_total',
    estado_auditoria: 'estado_auditoria',
    fecha_creacion: 'fecha_creacion',
    fecha_modificacion: 'fecha_modificacion'
  };

  export type ReservasScalarFieldEnum = (typeof ReservasScalarFieldEnum)[keyof typeof ReservasScalarFieldEnum]


  export const UsuariosScalarFieldEnum: {
    id_usuario: 'id_usuario',
    id_rol: 'id_rol',
    nombres: 'nombres',
    apellido_paterno: 'apellido_paterno',
    apellido_materno: 'apellido_materno',
    username: 'username',
    email: 'email',
    clave: 'clave',
    telefono: 'telefono',
    direccion: 'direccion',
    sexo: 'sexo',
    estado_auditoria: 'estado_auditoria',
    fecha_creacion: 'fecha_creacion',
    fecha_modificacion: 'fecha_modificacion'
  };

  export type UsuariosScalarFieldEnum = (typeof UsuariosScalarFieldEnum)[keyof typeof UsuariosScalarFieldEnum]


  export const ViajesScalarFieldEnum: {
    id_viaje: 'id_viaje',
    id_destino: 'id_destino',
    id_categoria: 'id_categoria',
    id_hospedaje: 'id_hospedaje',
    id_paquete: 'id_paquete',
    fecha_inicio: 'fecha_inicio',
    fecha_fin: 'fecha_fin',
    tarifa: 'tarifa',
    estado_auditoria: 'estado_auditoria',
    fecha_creacion: 'fecha_creacion',
    fecha_modificacion: 'fecha_modificacion'
  };

  export type ViajesScalarFieldEnum = (typeof ViajesScalarFieldEnum)[keyof typeof ViajesScalarFieldEnum]


  export const ItinerariosScalarFieldEnum: {
    id_itenerario: 'id_itenerario',
    id_viaje: 'id_viaje',
    dia: 'dia',
    hora_inicio: 'hora_inicio',
    hora_fin: 'hora_fin',
    actividad: 'actividad',
    descripcion: 'descripcion',
    estado_auditoria: 'estado_auditoria',
    fecha_creacion: 'fecha_creacion',
    fecha_modificacion: 'fecha_modificacion'
  };

  export type ItinerariosScalarFieldEnum = (typeof ItinerariosScalarFieldEnum)[keyof typeof ItinerariosScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type categoriasWhereInput = {
    AND?: categoriasWhereInput | categoriasWhereInput[]
    OR?: categoriasWhereInput[]
    NOT?: categoriasWhereInput | categoriasWhereInput[]
    id_categoria?: IntFilter<"categorias"> | number
    nombre?: StringFilter<"categorias"> | string
    estado_auditoria?: StringFilter<"categorias"> | string
    fecha_creacion?: DateTimeFilter<"categorias"> | Date | string
    fecha_modificacion?: DateTimeNullableFilter<"categorias"> | Date | string | null
    paquetes?: PaquetesListRelationFilter
    viajes?: ViajesListRelationFilter
  }

  export type categoriasOrderByWithRelationInput = {
    id_categoria?: SortOrder
    nombre?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_modificacion?: SortOrderInput | SortOrder
    paquetes?: paquetesOrderByRelationAggregateInput
    viajes?: viajesOrderByRelationAggregateInput
  }

  export type categoriasWhereUniqueInput = Prisma.AtLeast<{
    id_categoria?: number
    AND?: categoriasWhereInput | categoriasWhereInput[]
    OR?: categoriasWhereInput[]
    NOT?: categoriasWhereInput | categoriasWhereInput[]
    nombre?: StringFilter<"categorias"> | string
    estado_auditoria?: StringFilter<"categorias"> | string
    fecha_creacion?: DateTimeFilter<"categorias"> | Date | string
    fecha_modificacion?: DateTimeNullableFilter<"categorias"> | Date | string | null
    paquetes?: PaquetesListRelationFilter
    viajes?: ViajesListRelationFilter
  }, "id_categoria">

  export type categoriasOrderByWithAggregationInput = {
    id_categoria?: SortOrder
    nombre?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_modificacion?: SortOrderInput | SortOrder
    _count?: categoriasCountOrderByAggregateInput
    _avg?: categoriasAvgOrderByAggregateInput
    _max?: categoriasMaxOrderByAggregateInput
    _min?: categoriasMinOrderByAggregateInput
    _sum?: categoriasSumOrderByAggregateInput
  }

  export type categoriasScalarWhereWithAggregatesInput = {
    AND?: categoriasScalarWhereWithAggregatesInput | categoriasScalarWhereWithAggregatesInput[]
    OR?: categoriasScalarWhereWithAggregatesInput[]
    NOT?: categoriasScalarWhereWithAggregatesInput | categoriasScalarWhereWithAggregatesInput[]
    id_categoria?: IntWithAggregatesFilter<"categorias"> | number
    nombre?: StringWithAggregatesFilter<"categorias"> | string
    estado_auditoria?: StringWithAggregatesFilter<"categorias"> | string
    fecha_creacion?: DateTimeWithAggregatesFilter<"categorias"> | Date | string
    fecha_modificacion?: DateTimeNullableWithAggregatesFilter<"categorias"> | Date | string | null
  }

  export type paisesWhereInput = {
    AND?: paisesWhereInput | paisesWhereInput[]
    OR?: paisesWhereInput[]
    NOT?: paisesWhereInput | paisesWhereInput[]
    id_pais?: IntFilter<"paises"> | number
    nombre?: StringFilter<"paises"> | string
    estado_auditoria?: StringFilter<"paises"> | string
    fecha_creacion?: DateTimeFilter<"paises"> | Date | string
    fecha_modificacion?: DateTimeNullableFilter<"paises"> | Date | string | null
    destinos?: DestinosListRelationFilter
  }

  export type paisesOrderByWithRelationInput = {
    id_pais?: SortOrder
    nombre?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_modificacion?: SortOrderInput | SortOrder
    destinos?: destinosOrderByRelationAggregateInput
  }

  export type paisesWhereUniqueInput = Prisma.AtLeast<{
    id_pais?: number
    AND?: paisesWhereInput | paisesWhereInput[]
    OR?: paisesWhereInput[]
    NOT?: paisesWhereInput | paisesWhereInput[]
    nombre?: StringFilter<"paises"> | string
    estado_auditoria?: StringFilter<"paises"> | string
    fecha_creacion?: DateTimeFilter<"paises"> | Date | string
    fecha_modificacion?: DateTimeNullableFilter<"paises"> | Date | string | null
    destinos?: DestinosListRelationFilter
  }, "id_pais">

  export type paisesOrderByWithAggregationInput = {
    id_pais?: SortOrder
    nombre?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_modificacion?: SortOrderInput | SortOrder
    _count?: paisesCountOrderByAggregateInput
    _avg?: paisesAvgOrderByAggregateInput
    _max?: paisesMaxOrderByAggregateInput
    _min?: paisesMinOrderByAggregateInput
    _sum?: paisesSumOrderByAggregateInput
  }

  export type paisesScalarWhereWithAggregatesInput = {
    AND?: paisesScalarWhereWithAggregatesInput | paisesScalarWhereWithAggregatesInput[]
    OR?: paisesScalarWhereWithAggregatesInput[]
    NOT?: paisesScalarWhereWithAggregatesInput | paisesScalarWhereWithAggregatesInput[]
    id_pais?: IntWithAggregatesFilter<"paises"> | number
    nombre?: StringWithAggregatesFilter<"paises"> | string
    estado_auditoria?: StringWithAggregatesFilter<"paises"> | string
    fecha_creacion?: DateTimeWithAggregatesFilter<"paises"> | Date | string
    fecha_modificacion?: DateTimeNullableWithAggregatesFilter<"paises"> | Date | string | null
  }

  export type paquetesWhereInput = {
    AND?: paquetesWhereInput | paquetesWhereInput[]
    OR?: paquetesWhereInput[]
    NOT?: paquetesWhereInput | paquetesWhereInput[]
    id_paquete?: IntFilter<"paquetes"> | number
    id_hospedaje?: IntFilter<"paquetes"> | number
    id_categoria?: IntFilter<"paquetes"> | number
    nombre?: StringFilter<"paquetes"> | string
    transporte?: StringFilter<"paquetes"> | string
    precio?: DecimalFilter<"paquetes"> | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFilter<"paquetes"> | string
    fecha_modificacion?: DateTimeFilter<"paquetes"> | Date | string
    fecha_creacion?: DateTimeNullableFilter<"paquetes"> | Date | string | null
    categorias?: XOR<CategoriasRelationFilter, categoriasWhereInput>
    hospedajes?: XOR<HospedajesRelationFilter, hospedajesWhereInput>
    viajes?: ViajesListRelationFilter
  }

  export type paquetesOrderByWithRelationInput = {
    id_paquete?: SortOrder
    id_hospedaje?: SortOrder
    id_categoria?: SortOrder
    nombre?: SortOrder
    transporte?: SortOrder
    precio?: SortOrder
    estado_auditoria?: SortOrder
    fecha_modificacion?: SortOrder
    fecha_creacion?: SortOrderInput | SortOrder
    categorias?: categoriasOrderByWithRelationInput
    hospedajes?: hospedajesOrderByWithRelationInput
    viajes?: viajesOrderByRelationAggregateInput
  }

  export type paquetesWhereUniqueInput = Prisma.AtLeast<{
    id_paquete?: number
    AND?: paquetesWhereInput | paquetesWhereInput[]
    OR?: paquetesWhereInput[]
    NOT?: paquetesWhereInput | paquetesWhereInput[]
    id_hospedaje?: IntFilter<"paquetes"> | number
    id_categoria?: IntFilter<"paquetes"> | number
    nombre?: StringFilter<"paquetes"> | string
    transporte?: StringFilter<"paquetes"> | string
    precio?: DecimalFilter<"paquetes"> | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFilter<"paquetes"> | string
    fecha_modificacion?: DateTimeFilter<"paquetes"> | Date | string
    fecha_creacion?: DateTimeNullableFilter<"paquetes"> | Date | string | null
    categorias?: XOR<CategoriasRelationFilter, categoriasWhereInput>
    hospedajes?: XOR<HospedajesRelationFilter, hospedajesWhereInput>
    viajes?: ViajesListRelationFilter
  }, "id_paquete">

  export type paquetesOrderByWithAggregationInput = {
    id_paquete?: SortOrder
    id_hospedaje?: SortOrder
    id_categoria?: SortOrder
    nombre?: SortOrder
    transporte?: SortOrder
    precio?: SortOrder
    estado_auditoria?: SortOrder
    fecha_modificacion?: SortOrder
    fecha_creacion?: SortOrderInput | SortOrder
    _count?: paquetesCountOrderByAggregateInput
    _avg?: paquetesAvgOrderByAggregateInput
    _max?: paquetesMaxOrderByAggregateInput
    _min?: paquetesMinOrderByAggregateInput
    _sum?: paquetesSumOrderByAggregateInput
  }

  export type paquetesScalarWhereWithAggregatesInput = {
    AND?: paquetesScalarWhereWithAggregatesInput | paquetesScalarWhereWithAggregatesInput[]
    OR?: paquetesScalarWhereWithAggregatesInput[]
    NOT?: paquetesScalarWhereWithAggregatesInput | paquetesScalarWhereWithAggregatesInput[]
    id_paquete?: IntWithAggregatesFilter<"paquetes"> | number
    id_hospedaje?: IntWithAggregatesFilter<"paquetes"> | number
    id_categoria?: IntWithAggregatesFilter<"paquetes"> | number
    nombre?: StringWithAggregatesFilter<"paquetes"> | string
    transporte?: StringWithAggregatesFilter<"paquetes"> | string
    precio?: DecimalWithAggregatesFilter<"paquetes"> | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringWithAggregatesFilter<"paquetes"> | string
    fecha_modificacion?: DateTimeWithAggregatesFilter<"paquetes"> | Date | string
    fecha_creacion?: DateTimeNullableWithAggregatesFilter<"paquetes"> | Date | string | null
  }

  export type rolesWhereInput = {
    AND?: rolesWhereInput | rolesWhereInput[]
    OR?: rolesWhereInput[]
    NOT?: rolesWhereInput | rolesWhereInput[]
    id_rol?: IntFilter<"roles"> | number
    nombre?: StringFilter<"roles"> | string
    estado_auditoria?: StringFilter<"roles"> | string
    fecha_creacion?: DateTimeFilter<"roles"> | Date | string
    fecha_modificacion?: DateTimeNullableFilter<"roles"> | Date | string | null
    usuarios?: UsuariosListRelationFilter
  }

  export type rolesOrderByWithRelationInput = {
    id_rol?: SortOrder
    nombre?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_modificacion?: SortOrderInput | SortOrder
    usuarios?: usuariosOrderByRelationAggregateInput
  }

  export type rolesWhereUniqueInput = Prisma.AtLeast<{
    id_rol?: number
    AND?: rolesWhereInput | rolesWhereInput[]
    OR?: rolesWhereInput[]
    NOT?: rolesWhereInput | rolesWhereInput[]
    nombre?: StringFilter<"roles"> | string
    estado_auditoria?: StringFilter<"roles"> | string
    fecha_creacion?: DateTimeFilter<"roles"> | Date | string
    fecha_modificacion?: DateTimeNullableFilter<"roles"> | Date | string | null
    usuarios?: UsuariosListRelationFilter
  }, "id_rol">

  export type rolesOrderByWithAggregationInput = {
    id_rol?: SortOrder
    nombre?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_modificacion?: SortOrderInput | SortOrder
    _count?: rolesCountOrderByAggregateInput
    _avg?: rolesAvgOrderByAggregateInput
    _max?: rolesMaxOrderByAggregateInput
    _min?: rolesMinOrderByAggregateInput
    _sum?: rolesSumOrderByAggregateInput
  }

  export type rolesScalarWhereWithAggregatesInput = {
    AND?: rolesScalarWhereWithAggregatesInput | rolesScalarWhereWithAggregatesInput[]
    OR?: rolesScalarWhereWithAggregatesInput[]
    NOT?: rolesScalarWhereWithAggregatesInput | rolesScalarWhereWithAggregatesInput[]
    id_rol?: IntWithAggregatesFilter<"roles"> | number
    nombre?: StringWithAggregatesFilter<"roles"> | string
    estado_auditoria?: StringWithAggregatesFilter<"roles"> | string
    fecha_creacion?: DateTimeWithAggregatesFilter<"roles"> | Date | string
    fecha_modificacion?: DateTimeNullableWithAggregatesFilter<"roles"> | Date | string | null
  }

  export type destinosWhereInput = {
    AND?: destinosWhereInput | destinosWhereInput[]
    OR?: destinosWhereInput[]
    NOT?: destinosWhereInput | destinosWhereInput[]
    id_destino?: IntFilter<"destinos"> | number
    id_pais?: IntFilter<"destinos"> | number
    nombre?: StringFilter<"destinos"> | string
    estado_auditoria?: StringFilter<"destinos"> | string
    fecha_creacion?: DateTimeFilter<"destinos"> | Date | string
    fecha_modificacion?: DateTimeNullableFilter<"destinos"> | Date | string | null
    paises?: XOR<PaisesRelationFilter, paisesWhereInput>
    hospedajes?: HospedajesListRelationFilter
    viajes?: ViajesListRelationFilter
  }

  export type destinosOrderByWithRelationInput = {
    id_destino?: SortOrder
    id_pais?: SortOrder
    nombre?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_modificacion?: SortOrderInput | SortOrder
    paises?: paisesOrderByWithRelationInput
    hospedajes?: hospedajesOrderByRelationAggregateInput
    viajes?: viajesOrderByRelationAggregateInput
  }

  export type destinosWhereUniqueInput = Prisma.AtLeast<{
    id_destino?: number
    AND?: destinosWhereInput | destinosWhereInput[]
    OR?: destinosWhereInput[]
    NOT?: destinosWhereInput | destinosWhereInput[]
    id_pais?: IntFilter<"destinos"> | number
    nombre?: StringFilter<"destinos"> | string
    estado_auditoria?: StringFilter<"destinos"> | string
    fecha_creacion?: DateTimeFilter<"destinos"> | Date | string
    fecha_modificacion?: DateTimeNullableFilter<"destinos"> | Date | string | null
    paises?: XOR<PaisesRelationFilter, paisesWhereInput>
    hospedajes?: HospedajesListRelationFilter
    viajes?: ViajesListRelationFilter
  }, "id_destino">

  export type destinosOrderByWithAggregationInput = {
    id_destino?: SortOrder
    id_pais?: SortOrder
    nombre?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_modificacion?: SortOrderInput | SortOrder
    _count?: destinosCountOrderByAggregateInput
    _avg?: destinosAvgOrderByAggregateInput
    _max?: destinosMaxOrderByAggregateInput
    _min?: destinosMinOrderByAggregateInput
    _sum?: destinosSumOrderByAggregateInput
  }

  export type destinosScalarWhereWithAggregatesInput = {
    AND?: destinosScalarWhereWithAggregatesInput | destinosScalarWhereWithAggregatesInput[]
    OR?: destinosScalarWhereWithAggregatesInput[]
    NOT?: destinosScalarWhereWithAggregatesInput | destinosScalarWhereWithAggregatesInput[]
    id_destino?: IntWithAggregatesFilter<"destinos"> | number
    id_pais?: IntWithAggregatesFilter<"destinos"> | number
    nombre?: StringWithAggregatesFilter<"destinos"> | string
    estado_auditoria?: StringWithAggregatesFilter<"destinos"> | string
    fecha_creacion?: DateTimeWithAggregatesFilter<"destinos"> | Date | string
    fecha_modificacion?: DateTimeNullableWithAggregatesFilter<"destinos"> | Date | string | null
  }

  export type hospedajesWhereInput = {
    AND?: hospedajesWhereInput | hospedajesWhereInput[]
    OR?: hospedajesWhereInput[]
    NOT?: hospedajesWhereInput | hospedajesWhereInput[]
    id_hospedaje?: IntFilter<"hospedajes"> | number
    id_destino?: IntFilter<"hospedajes"> | number
    nombre?: StringFilter<"hospedajes"> | string
    precio?: DecimalFilter<"hospedajes"> | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFilter<"hospedajes"> | string
    fecha_creacion?: DateTimeFilter<"hospedajes"> | Date | string
    fecha_modificacion?: DateTimeNullableFilter<"hospedajes"> | Date | string | null
    destinos?: XOR<DestinosRelationFilter, destinosWhereInput>
    paquetes?: PaquetesListRelationFilter
    viajes?: ViajesListRelationFilter
  }

  export type hospedajesOrderByWithRelationInput = {
    id_hospedaje?: SortOrder
    id_destino?: SortOrder
    nombre?: SortOrder
    precio?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_modificacion?: SortOrderInput | SortOrder
    destinos?: destinosOrderByWithRelationInput
    paquetes?: paquetesOrderByRelationAggregateInput
    viajes?: viajesOrderByRelationAggregateInput
  }

  export type hospedajesWhereUniqueInput = Prisma.AtLeast<{
    id_hospedaje?: number
    AND?: hospedajesWhereInput | hospedajesWhereInput[]
    OR?: hospedajesWhereInput[]
    NOT?: hospedajesWhereInput | hospedajesWhereInput[]
    id_destino?: IntFilter<"hospedajes"> | number
    nombre?: StringFilter<"hospedajes"> | string
    precio?: DecimalFilter<"hospedajes"> | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFilter<"hospedajes"> | string
    fecha_creacion?: DateTimeFilter<"hospedajes"> | Date | string
    fecha_modificacion?: DateTimeNullableFilter<"hospedajes"> | Date | string | null
    destinos?: XOR<DestinosRelationFilter, destinosWhereInput>
    paquetes?: PaquetesListRelationFilter
    viajes?: ViajesListRelationFilter
  }, "id_hospedaje">

  export type hospedajesOrderByWithAggregationInput = {
    id_hospedaje?: SortOrder
    id_destino?: SortOrder
    nombre?: SortOrder
    precio?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_modificacion?: SortOrderInput | SortOrder
    _count?: hospedajesCountOrderByAggregateInput
    _avg?: hospedajesAvgOrderByAggregateInput
    _max?: hospedajesMaxOrderByAggregateInput
    _min?: hospedajesMinOrderByAggregateInput
    _sum?: hospedajesSumOrderByAggregateInput
  }

  export type hospedajesScalarWhereWithAggregatesInput = {
    AND?: hospedajesScalarWhereWithAggregatesInput | hospedajesScalarWhereWithAggregatesInput[]
    OR?: hospedajesScalarWhereWithAggregatesInput[]
    NOT?: hospedajesScalarWhereWithAggregatesInput | hospedajesScalarWhereWithAggregatesInput[]
    id_hospedaje?: IntWithAggregatesFilter<"hospedajes"> | number
    id_destino?: IntWithAggregatesFilter<"hospedajes"> | number
    nombre?: StringWithAggregatesFilter<"hospedajes"> | string
    precio?: DecimalWithAggregatesFilter<"hospedajes"> | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringWithAggregatesFilter<"hospedajes"> | string
    fecha_creacion?: DateTimeWithAggregatesFilter<"hospedajes"> | Date | string
    fecha_modificacion?: DateTimeNullableWithAggregatesFilter<"hospedajes"> | Date | string | null
  }

  export type reservasWhereInput = {
    AND?: reservasWhereInput | reservasWhereInput[]
    OR?: reservasWhereInput[]
    NOT?: reservasWhereInput | reservasWhereInput[]
    id_reserva?: IntFilter<"reservas"> | number
    id_usuario?: IntFilter<"reservas"> | number
    id_viaje?: IntFilter<"reservas"> | number
    numero_personas?: StringFilter<"reservas"> | string
    metodo_pago?: StringFilter<"reservas"> | string
    pago_total?: DecimalFilter<"reservas"> | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFilter<"reservas"> | string
    fecha_creacion?: DateTimeFilter<"reservas"> | Date | string
    fecha_modificacion?: DateTimeNullableFilter<"reservas"> | Date | string | null
    usuarios?: XOR<UsuariosRelationFilter, usuariosWhereInput>
    viajes?: XOR<ViajesRelationFilter, viajesWhereInput>
  }

  export type reservasOrderByWithRelationInput = {
    id_reserva?: SortOrder
    id_usuario?: SortOrder
    id_viaje?: SortOrder
    numero_personas?: SortOrder
    metodo_pago?: SortOrder
    pago_total?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_modificacion?: SortOrderInput | SortOrder
    usuarios?: usuariosOrderByWithRelationInput
    viajes?: viajesOrderByWithRelationInput
  }

  export type reservasWhereUniqueInput = Prisma.AtLeast<{
    id_reserva?: number
    AND?: reservasWhereInput | reservasWhereInput[]
    OR?: reservasWhereInput[]
    NOT?: reservasWhereInput | reservasWhereInput[]
    id_usuario?: IntFilter<"reservas"> | number
    id_viaje?: IntFilter<"reservas"> | number
    numero_personas?: StringFilter<"reservas"> | string
    metodo_pago?: StringFilter<"reservas"> | string
    pago_total?: DecimalFilter<"reservas"> | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFilter<"reservas"> | string
    fecha_creacion?: DateTimeFilter<"reservas"> | Date | string
    fecha_modificacion?: DateTimeNullableFilter<"reservas"> | Date | string | null
    usuarios?: XOR<UsuariosRelationFilter, usuariosWhereInput>
    viajes?: XOR<ViajesRelationFilter, viajesWhereInput>
  }, "id_reserva">

  export type reservasOrderByWithAggregationInput = {
    id_reserva?: SortOrder
    id_usuario?: SortOrder
    id_viaje?: SortOrder
    numero_personas?: SortOrder
    metodo_pago?: SortOrder
    pago_total?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_modificacion?: SortOrderInput | SortOrder
    _count?: reservasCountOrderByAggregateInput
    _avg?: reservasAvgOrderByAggregateInput
    _max?: reservasMaxOrderByAggregateInput
    _min?: reservasMinOrderByAggregateInput
    _sum?: reservasSumOrderByAggregateInput
  }

  export type reservasScalarWhereWithAggregatesInput = {
    AND?: reservasScalarWhereWithAggregatesInput | reservasScalarWhereWithAggregatesInput[]
    OR?: reservasScalarWhereWithAggregatesInput[]
    NOT?: reservasScalarWhereWithAggregatesInput | reservasScalarWhereWithAggregatesInput[]
    id_reserva?: IntWithAggregatesFilter<"reservas"> | number
    id_usuario?: IntWithAggregatesFilter<"reservas"> | number
    id_viaje?: IntWithAggregatesFilter<"reservas"> | number
    numero_personas?: StringWithAggregatesFilter<"reservas"> | string
    metodo_pago?: StringWithAggregatesFilter<"reservas"> | string
    pago_total?: DecimalWithAggregatesFilter<"reservas"> | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringWithAggregatesFilter<"reservas"> | string
    fecha_creacion?: DateTimeWithAggregatesFilter<"reservas"> | Date | string
    fecha_modificacion?: DateTimeNullableWithAggregatesFilter<"reservas"> | Date | string | null
  }

  export type usuariosWhereInput = {
    AND?: usuariosWhereInput | usuariosWhereInput[]
    OR?: usuariosWhereInput[]
    NOT?: usuariosWhereInput | usuariosWhereInput[]
    id_usuario?: IntFilter<"usuarios"> | number
    id_rol?: IntFilter<"usuarios"> | number
    nombres?: StringFilter<"usuarios"> | string
    apellido_paterno?: StringFilter<"usuarios"> | string
    apellido_materno?: StringFilter<"usuarios"> | string
    username?: StringFilter<"usuarios"> | string
    email?: StringFilter<"usuarios"> | string
    clave?: StringFilter<"usuarios"> | string
    telefono?: StringFilter<"usuarios"> | string
    direccion?: StringFilter<"usuarios"> | string
    sexo?: StringFilter<"usuarios"> | string
    estado_auditoria?: StringFilter<"usuarios"> | string
    fecha_creacion?: DateTimeFilter<"usuarios"> | Date | string
    fecha_modificacion?: DateTimeNullableFilter<"usuarios"> | Date | string | null
    reservas?: ReservasListRelationFilter
    roles?: XOR<RolesRelationFilter, rolesWhereInput>
  }

  export type usuariosOrderByWithRelationInput = {
    id_usuario?: SortOrder
    id_rol?: SortOrder
    nombres?: SortOrder
    apellido_paterno?: SortOrder
    apellido_materno?: SortOrder
    username?: SortOrder
    email?: SortOrder
    clave?: SortOrder
    telefono?: SortOrder
    direccion?: SortOrder
    sexo?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_modificacion?: SortOrderInput | SortOrder
    reservas?: reservasOrderByRelationAggregateInput
    roles?: rolesOrderByWithRelationInput
  }

  export type usuariosWhereUniqueInput = Prisma.AtLeast<{
    id_usuario?: number
    AND?: usuariosWhereInput | usuariosWhereInput[]
    OR?: usuariosWhereInput[]
    NOT?: usuariosWhereInput | usuariosWhereInput[]
    id_rol?: IntFilter<"usuarios"> | number
    nombres?: StringFilter<"usuarios"> | string
    apellido_paterno?: StringFilter<"usuarios"> | string
    apellido_materno?: StringFilter<"usuarios"> | string
    username?: StringFilter<"usuarios"> | string
    email?: StringFilter<"usuarios"> | string
    clave?: StringFilter<"usuarios"> | string
    telefono?: StringFilter<"usuarios"> | string
    direccion?: StringFilter<"usuarios"> | string
    sexo?: StringFilter<"usuarios"> | string
    estado_auditoria?: StringFilter<"usuarios"> | string
    fecha_creacion?: DateTimeFilter<"usuarios"> | Date | string
    fecha_modificacion?: DateTimeNullableFilter<"usuarios"> | Date | string | null
    reservas?: ReservasListRelationFilter
    roles?: XOR<RolesRelationFilter, rolesWhereInput>
  }, "id_usuario">

  export type usuariosOrderByWithAggregationInput = {
    id_usuario?: SortOrder
    id_rol?: SortOrder
    nombres?: SortOrder
    apellido_paterno?: SortOrder
    apellido_materno?: SortOrder
    username?: SortOrder
    email?: SortOrder
    clave?: SortOrder
    telefono?: SortOrder
    direccion?: SortOrder
    sexo?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_modificacion?: SortOrderInput | SortOrder
    _count?: usuariosCountOrderByAggregateInput
    _avg?: usuariosAvgOrderByAggregateInput
    _max?: usuariosMaxOrderByAggregateInput
    _min?: usuariosMinOrderByAggregateInput
    _sum?: usuariosSumOrderByAggregateInput
  }

  export type usuariosScalarWhereWithAggregatesInput = {
    AND?: usuariosScalarWhereWithAggregatesInput | usuariosScalarWhereWithAggregatesInput[]
    OR?: usuariosScalarWhereWithAggregatesInput[]
    NOT?: usuariosScalarWhereWithAggregatesInput | usuariosScalarWhereWithAggregatesInput[]
    id_usuario?: IntWithAggregatesFilter<"usuarios"> | number
    id_rol?: IntWithAggregatesFilter<"usuarios"> | number
    nombres?: StringWithAggregatesFilter<"usuarios"> | string
    apellido_paterno?: StringWithAggregatesFilter<"usuarios"> | string
    apellido_materno?: StringWithAggregatesFilter<"usuarios"> | string
    username?: StringWithAggregatesFilter<"usuarios"> | string
    email?: StringWithAggregatesFilter<"usuarios"> | string
    clave?: StringWithAggregatesFilter<"usuarios"> | string
    telefono?: StringWithAggregatesFilter<"usuarios"> | string
    direccion?: StringWithAggregatesFilter<"usuarios"> | string
    sexo?: StringWithAggregatesFilter<"usuarios"> | string
    estado_auditoria?: StringWithAggregatesFilter<"usuarios"> | string
    fecha_creacion?: DateTimeWithAggregatesFilter<"usuarios"> | Date | string
    fecha_modificacion?: DateTimeNullableWithAggregatesFilter<"usuarios"> | Date | string | null
  }

  export type viajesWhereInput = {
    AND?: viajesWhereInput | viajesWhereInput[]
    OR?: viajesWhereInput[]
    NOT?: viajesWhereInput | viajesWhereInput[]
    id_viaje?: IntFilter<"viajes"> | number
    id_destino?: IntFilter<"viajes"> | number
    id_categoria?: IntFilter<"viajes"> | number
    id_hospedaje?: IntFilter<"viajes"> | number
    id_paquete?: IntFilter<"viajes"> | number
    fecha_inicio?: DateTimeNullableFilter<"viajes"> | Date | string | null
    fecha_fin?: DateTimeNullableFilter<"viajes"> | Date | string | null
    tarifa?: DecimalFilter<"viajes"> | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFilter<"viajes"> | string
    fecha_creacion?: DateTimeFilter<"viajes"> | Date | string
    fecha_modificacion?: DateTimeNullableFilter<"viajes"> | Date | string | null
    itinerarios?: ItinerariosListRelationFilter
    reservas?: ReservasListRelationFilter
    categorias?: XOR<CategoriasRelationFilter, categoriasWhereInput>
    destinos?: XOR<DestinosRelationFilter, destinosWhereInput>
    hospedajes?: XOR<HospedajesRelationFilter, hospedajesWhereInput>
    paquetes?: XOR<PaquetesRelationFilter, paquetesWhereInput>
  }

  export type viajesOrderByWithRelationInput = {
    id_viaje?: SortOrder
    id_destino?: SortOrder
    id_categoria?: SortOrder
    id_hospedaje?: SortOrder
    id_paquete?: SortOrder
    fecha_inicio?: SortOrderInput | SortOrder
    fecha_fin?: SortOrderInput | SortOrder
    tarifa?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_modificacion?: SortOrderInput | SortOrder
    itinerarios?: itinerariosOrderByRelationAggregateInput
    reservas?: reservasOrderByRelationAggregateInput
    categorias?: categoriasOrderByWithRelationInput
    destinos?: destinosOrderByWithRelationInput
    hospedajes?: hospedajesOrderByWithRelationInput
    paquetes?: paquetesOrderByWithRelationInput
  }

  export type viajesWhereUniqueInput = Prisma.AtLeast<{
    id_viaje?: number
    AND?: viajesWhereInput | viajesWhereInput[]
    OR?: viajesWhereInput[]
    NOT?: viajesWhereInput | viajesWhereInput[]
    id_destino?: IntFilter<"viajes"> | number
    id_categoria?: IntFilter<"viajes"> | number
    id_hospedaje?: IntFilter<"viajes"> | number
    id_paquete?: IntFilter<"viajes"> | number
    fecha_inicio?: DateTimeNullableFilter<"viajes"> | Date | string | null
    fecha_fin?: DateTimeNullableFilter<"viajes"> | Date | string | null
    tarifa?: DecimalFilter<"viajes"> | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFilter<"viajes"> | string
    fecha_creacion?: DateTimeFilter<"viajes"> | Date | string
    fecha_modificacion?: DateTimeNullableFilter<"viajes"> | Date | string | null
    itinerarios?: ItinerariosListRelationFilter
    reservas?: ReservasListRelationFilter
    categorias?: XOR<CategoriasRelationFilter, categoriasWhereInput>
    destinos?: XOR<DestinosRelationFilter, destinosWhereInput>
    hospedajes?: XOR<HospedajesRelationFilter, hospedajesWhereInput>
    paquetes?: XOR<PaquetesRelationFilter, paquetesWhereInput>
  }, "id_viaje">

  export type viajesOrderByWithAggregationInput = {
    id_viaje?: SortOrder
    id_destino?: SortOrder
    id_categoria?: SortOrder
    id_hospedaje?: SortOrder
    id_paquete?: SortOrder
    fecha_inicio?: SortOrderInput | SortOrder
    fecha_fin?: SortOrderInput | SortOrder
    tarifa?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_modificacion?: SortOrderInput | SortOrder
    _count?: viajesCountOrderByAggregateInput
    _avg?: viajesAvgOrderByAggregateInput
    _max?: viajesMaxOrderByAggregateInput
    _min?: viajesMinOrderByAggregateInput
    _sum?: viajesSumOrderByAggregateInput
  }

  export type viajesScalarWhereWithAggregatesInput = {
    AND?: viajesScalarWhereWithAggregatesInput | viajesScalarWhereWithAggregatesInput[]
    OR?: viajesScalarWhereWithAggregatesInput[]
    NOT?: viajesScalarWhereWithAggregatesInput | viajesScalarWhereWithAggregatesInput[]
    id_viaje?: IntWithAggregatesFilter<"viajes"> | number
    id_destino?: IntWithAggregatesFilter<"viajes"> | number
    id_categoria?: IntWithAggregatesFilter<"viajes"> | number
    id_hospedaje?: IntWithAggregatesFilter<"viajes"> | number
    id_paquete?: IntWithAggregatesFilter<"viajes"> | number
    fecha_inicio?: DateTimeNullableWithAggregatesFilter<"viajes"> | Date | string | null
    fecha_fin?: DateTimeNullableWithAggregatesFilter<"viajes"> | Date | string | null
    tarifa?: DecimalWithAggregatesFilter<"viajes"> | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringWithAggregatesFilter<"viajes"> | string
    fecha_creacion?: DateTimeWithAggregatesFilter<"viajes"> | Date | string
    fecha_modificacion?: DateTimeNullableWithAggregatesFilter<"viajes"> | Date | string | null
  }

  export type itinerariosWhereInput = {
    AND?: itinerariosWhereInput | itinerariosWhereInput[]
    OR?: itinerariosWhereInput[]
    NOT?: itinerariosWhereInput | itinerariosWhereInput[]
    id_itenerario?: IntFilter<"itinerarios"> | number
    id_viaje?: IntFilter<"itinerarios"> | number
    dia?: StringFilter<"itinerarios"> | string
    hora_inicio?: StringFilter<"itinerarios"> | string
    hora_fin?: StringFilter<"itinerarios"> | string
    actividad?: StringFilter<"itinerarios"> | string
    descripcion?: StringFilter<"itinerarios"> | string
    estado_auditoria?: StringFilter<"itinerarios"> | string
    fecha_creacion?: DateTimeFilter<"itinerarios"> | Date | string
    fecha_modificacion?: DateTimeNullableFilter<"itinerarios"> | Date | string | null
    viajes?: XOR<ViajesRelationFilter, viajesWhereInput>
  }

  export type itinerariosOrderByWithRelationInput = {
    id_itenerario?: SortOrder
    id_viaje?: SortOrder
    dia?: SortOrder
    hora_inicio?: SortOrder
    hora_fin?: SortOrder
    actividad?: SortOrder
    descripcion?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_modificacion?: SortOrderInput | SortOrder
    viajes?: viajesOrderByWithRelationInput
  }

  export type itinerariosWhereUniqueInput = Prisma.AtLeast<{
    id_itenerario?: number
    AND?: itinerariosWhereInput | itinerariosWhereInput[]
    OR?: itinerariosWhereInput[]
    NOT?: itinerariosWhereInput | itinerariosWhereInput[]
    id_viaje?: IntFilter<"itinerarios"> | number
    dia?: StringFilter<"itinerarios"> | string
    hora_inicio?: StringFilter<"itinerarios"> | string
    hora_fin?: StringFilter<"itinerarios"> | string
    actividad?: StringFilter<"itinerarios"> | string
    descripcion?: StringFilter<"itinerarios"> | string
    estado_auditoria?: StringFilter<"itinerarios"> | string
    fecha_creacion?: DateTimeFilter<"itinerarios"> | Date | string
    fecha_modificacion?: DateTimeNullableFilter<"itinerarios"> | Date | string | null
    viajes?: XOR<ViajesRelationFilter, viajesWhereInput>
  }, "id_itenerario">

  export type itinerariosOrderByWithAggregationInput = {
    id_itenerario?: SortOrder
    id_viaje?: SortOrder
    dia?: SortOrder
    hora_inicio?: SortOrder
    hora_fin?: SortOrder
    actividad?: SortOrder
    descripcion?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_modificacion?: SortOrderInput | SortOrder
    _count?: itinerariosCountOrderByAggregateInput
    _avg?: itinerariosAvgOrderByAggregateInput
    _max?: itinerariosMaxOrderByAggregateInput
    _min?: itinerariosMinOrderByAggregateInput
    _sum?: itinerariosSumOrderByAggregateInput
  }

  export type itinerariosScalarWhereWithAggregatesInput = {
    AND?: itinerariosScalarWhereWithAggregatesInput | itinerariosScalarWhereWithAggregatesInput[]
    OR?: itinerariosScalarWhereWithAggregatesInput[]
    NOT?: itinerariosScalarWhereWithAggregatesInput | itinerariosScalarWhereWithAggregatesInput[]
    id_itenerario?: IntWithAggregatesFilter<"itinerarios"> | number
    id_viaje?: IntWithAggregatesFilter<"itinerarios"> | number
    dia?: StringWithAggregatesFilter<"itinerarios"> | string
    hora_inicio?: StringWithAggregatesFilter<"itinerarios"> | string
    hora_fin?: StringWithAggregatesFilter<"itinerarios"> | string
    actividad?: StringWithAggregatesFilter<"itinerarios"> | string
    descripcion?: StringWithAggregatesFilter<"itinerarios"> | string
    estado_auditoria?: StringWithAggregatesFilter<"itinerarios"> | string
    fecha_creacion?: DateTimeWithAggregatesFilter<"itinerarios"> | Date | string
    fecha_modificacion?: DateTimeNullableWithAggregatesFilter<"itinerarios"> | Date | string | null
  }

  export type categoriasCreateInput = {
    nombre: string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
    paquetes?: paquetesCreateNestedManyWithoutCategoriasInput
    viajes?: viajesCreateNestedManyWithoutCategoriasInput
  }

  export type categoriasUncheckedCreateInput = {
    id_categoria?: number
    nombre: string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
    paquetes?: paquetesUncheckedCreateNestedManyWithoutCategoriasInput
    viajes?: viajesUncheckedCreateNestedManyWithoutCategoriasInput
  }

  export type categoriasUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paquetes?: paquetesUpdateManyWithoutCategoriasNestedInput
    viajes?: viajesUpdateManyWithoutCategoriasNestedInput
  }

  export type categoriasUncheckedUpdateInput = {
    id_categoria?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paquetes?: paquetesUncheckedUpdateManyWithoutCategoriasNestedInput
    viajes?: viajesUncheckedUpdateManyWithoutCategoriasNestedInput
  }

  export type categoriasCreateManyInput = {
    id_categoria?: number
    nombre: string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
  }

  export type categoriasUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type categoriasUncheckedUpdateManyInput = {
    id_categoria?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type paisesCreateInput = {
    nombre: string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
    destinos?: destinosCreateNestedManyWithoutPaisesInput
  }

  export type paisesUncheckedCreateInput = {
    id_pais?: number
    nombre: string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
    destinos?: destinosUncheckedCreateNestedManyWithoutPaisesInput
  }

  export type paisesUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    destinos?: destinosUpdateManyWithoutPaisesNestedInput
  }

  export type paisesUncheckedUpdateInput = {
    id_pais?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    destinos?: destinosUncheckedUpdateManyWithoutPaisesNestedInput
  }

  export type paisesCreateManyInput = {
    id_pais?: number
    nombre: string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
  }

  export type paisesUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type paisesUncheckedUpdateManyInput = {
    id_pais?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type paquetesCreateInput = {
    nombre: string
    transporte: string
    precio: Decimal | DecimalJsLike | number | string
    estado_auditoria?: string
    fecha_modificacion?: Date | string
    fecha_creacion?: Date | string | null
    categorias: categoriasCreateNestedOneWithoutPaquetesInput
    hospedajes: hospedajesCreateNestedOneWithoutPaquetesInput
    viajes?: viajesCreateNestedManyWithoutPaquetesInput
  }

  export type paquetesUncheckedCreateInput = {
    id_paquete?: number
    id_hospedaje: number
    id_categoria: number
    nombre: string
    transporte: string
    precio: Decimal | DecimalJsLike | number | string
    estado_auditoria?: string
    fecha_modificacion?: Date | string
    fecha_creacion?: Date | string | null
    viajes?: viajesUncheckedCreateNestedManyWithoutPaquetesInput
  }

  export type paquetesUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    transporte?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_modificacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categorias?: categoriasUpdateOneRequiredWithoutPaquetesNestedInput
    hospedajes?: hospedajesUpdateOneRequiredWithoutPaquetesNestedInput
    viajes?: viajesUpdateManyWithoutPaquetesNestedInput
  }

  export type paquetesUncheckedUpdateInput = {
    id_paquete?: IntFieldUpdateOperationsInput | number
    id_hospedaje?: IntFieldUpdateOperationsInput | number
    id_categoria?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    transporte?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_modificacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viajes?: viajesUncheckedUpdateManyWithoutPaquetesNestedInput
  }

  export type paquetesCreateManyInput = {
    id_paquete?: number
    id_hospedaje: number
    id_categoria: number
    nombre: string
    transporte: string
    precio: Decimal | DecimalJsLike | number | string
    estado_auditoria?: string
    fecha_modificacion?: Date | string
    fecha_creacion?: Date | string | null
  }

  export type paquetesUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    transporte?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_modificacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type paquetesUncheckedUpdateManyInput = {
    id_paquete?: IntFieldUpdateOperationsInput | number
    id_hospedaje?: IntFieldUpdateOperationsInput | number
    id_categoria?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    transporte?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_modificacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type rolesCreateInput = {
    nombre: string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
    usuarios?: usuariosCreateNestedManyWithoutRolesInput
  }

  export type rolesUncheckedCreateInput = {
    id_rol?: number
    nombre: string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
    usuarios?: usuariosUncheckedCreateNestedManyWithoutRolesInput
  }

  export type rolesUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usuarios?: usuariosUpdateManyWithoutRolesNestedInput
  }

  export type rolesUncheckedUpdateInput = {
    id_rol?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usuarios?: usuariosUncheckedUpdateManyWithoutRolesNestedInput
  }

  export type rolesCreateManyInput = {
    id_rol?: number
    nombre: string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
  }

  export type rolesUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type rolesUncheckedUpdateManyInput = {
    id_rol?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type destinosCreateInput = {
    nombre: string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
    paises: paisesCreateNestedOneWithoutDestinosInput
    hospedajes?: hospedajesCreateNestedManyWithoutDestinosInput
    viajes?: viajesCreateNestedManyWithoutDestinosInput
  }

  export type destinosUncheckedCreateInput = {
    id_destino?: number
    id_pais: number
    nombre: string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
    hospedajes?: hospedajesUncheckedCreateNestedManyWithoutDestinosInput
    viajes?: viajesUncheckedCreateNestedManyWithoutDestinosInput
  }

  export type destinosUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paises?: paisesUpdateOneRequiredWithoutDestinosNestedInput
    hospedajes?: hospedajesUpdateManyWithoutDestinosNestedInput
    viajes?: viajesUpdateManyWithoutDestinosNestedInput
  }

  export type destinosUncheckedUpdateInput = {
    id_destino?: IntFieldUpdateOperationsInput | number
    id_pais?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hospedajes?: hospedajesUncheckedUpdateManyWithoutDestinosNestedInput
    viajes?: viajesUncheckedUpdateManyWithoutDestinosNestedInput
  }

  export type destinosCreateManyInput = {
    id_destino?: number
    id_pais: number
    nombre: string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
  }

  export type destinosUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type destinosUncheckedUpdateManyInput = {
    id_destino?: IntFieldUpdateOperationsInput | number
    id_pais?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type hospedajesCreateInput = {
    nombre: string
    precio: Decimal | DecimalJsLike | number | string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
    destinos: destinosCreateNestedOneWithoutHospedajesInput
    paquetes?: paquetesCreateNestedManyWithoutHospedajesInput
    viajes?: viajesCreateNestedManyWithoutHospedajesInput
  }

  export type hospedajesUncheckedCreateInput = {
    id_hospedaje?: number
    id_destino: number
    nombre: string
    precio: Decimal | DecimalJsLike | number | string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
    paquetes?: paquetesUncheckedCreateNestedManyWithoutHospedajesInput
    viajes?: viajesUncheckedCreateNestedManyWithoutHospedajesInput
  }

  export type hospedajesUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    destinos?: destinosUpdateOneRequiredWithoutHospedajesNestedInput
    paquetes?: paquetesUpdateManyWithoutHospedajesNestedInput
    viajes?: viajesUpdateManyWithoutHospedajesNestedInput
  }

  export type hospedajesUncheckedUpdateInput = {
    id_hospedaje?: IntFieldUpdateOperationsInput | number
    id_destino?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paquetes?: paquetesUncheckedUpdateManyWithoutHospedajesNestedInput
    viajes?: viajesUncheckedUpdateManyWithoutHospedajesNestedInput
  }

  export type hospedajesCreateManyInput = {
    id_hospedaje?: number
    id_destino: number
    nombre: string
    precio: Decimal | DecimalJsLike | number | string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
  }

  export type hospedajesUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type hospedajesUncheckedUpdateManyInput = {
    id_hospedaje?: IntFieldUpdateOperationsInput | number
    id_destino?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type reservasCreateInput = {
    numero_personas: string
    metodo_pago: string
    pago_total: Decimal | DecimalJsLike | number | string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
    usuarios: usuariosCreateNestedOneWithoutReservasInput
    viajes: viajesCreateNestedOneWithoutReservasInput
  }

  export type reservasUncheckedCreateInput = {
    id_reserva?: number
    id_usuario: number
    id_viaje: number
    numero_personas: string
    metodo_pago: string
    pago_total: Decimal | DecimalJsLike | number | string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
  }

  export type reservasUpdateInput = {
    numero_personas?: StringFieldUpdateOperationsInput | string
    metodo_pago?: StringFieldUpdateOperationsInput | string
    pago_total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usuarios?: usuariosUpdateOneRequiredWithoutReservasNestedInput
    viajes?: viajesUpdateOneRequiredWithoutReservasNestedInput
  }

  export type reservasUncheckedUpdateInput = {
    id_reserva?: IntFieldUpdateOperationsInput | number
    id_usuario?: IntFieldUpdateOperationsInput | number
    id_viaje?: IntFieldUpdateOperationsInput | number
    numero_personas?: StringFieldUpdateOperationsInput | string
    metodo_pago?: StringFieldUpdateOperationsInput | string
    pago_total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type reservasCreateManyInput = {
    id_reserva?: number
    id_usuario: number
    id_viaje: number
    numero_personas: string
    metodo_pago: string
    pago_total: Decimal | DecimalJsLike | number | string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
  }

  export type reservasUpdateManyMutationInput = {
    numero_personas?: StringFieldUpdateOperationsInput | string
    metodo_pago?: StringFieldUpdateOperationsInput | string
    pago_total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type reservasUncheckedUpdateManyInput = {
    id_reserva?: IntFieldUpdateOperationsInput | number
    id_usuario?: IntFieldUpdateOperationsInput | number
    id_viaje?: IntFieldUpdateOperationsInput | number
    numero_personas?: StringFieldUpdateOperationsInput | string
    metodo_pago?: StringFieldUpdateOperationsInput | string
    pago_total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usuariosCreateInput = {
    nombres: string
    apellido_paterno: string
    apellido_materno: string
    username: string
    email: string
    clave: string
    telefono: string
    direccion: string
    sexo: string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
    reservas?: reservasCreateNestedManyWithoutUsuariosInput
    roles: rolesCreateNestedOneWithoutUsuariosInput
  }

  export type usuariosUncheckedCreateInput = {
    id_usuario?: number
    id_rol: number
    nombres: string
    apellido_paterno: string
    apellido_materno: string
    username: string
    email: string
    clave: string
    telefono: string
    direccion: string
    sexo: string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
    reservas?: reservasUncheckedCreateNestedManyWithoutUsuariosInput
  }

  export type usuariosUpdateInput = {
    nombres?: StringFieldUpdateOperationsInput | string
    apellido_paterno?: StringFieldUpdateOperationsInput | string
    apellido_materno?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    sexo?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reservas?: reservasUpdateManyWithoutUsuariosNestedInput
    roles?: rolesUpdateOneRequiredWithoutUsuariosNestedInput
  }

  export type usuariosUncheckedUpdateInput = {
    id_usuario?: IntFieldUpdateOperationsInput | number
    id_rol?: IntFieldUpdateOperationsInput | number
    nombres?: StringFieldUpdateOperationsInput | string
    apellido_paterno?: StringFieldUpdateOperationsInput | string
    apellido_materno?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    sexo?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reservas?: reservasUncheckedUpdateManyWithoutUsuariosNestedInput
  }

  export type usuariosCreateManyInput = {
    id_usuario?: number
    id_rol: number
    nombres: string
    apellido_paterno: string
    apellido_materno: string
    username: string
    email: string
    clave: string
    telefono: string
    direccion: string
    sexo: string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
  }

  export type usuariosUpdateManyMutationInput = {
    nombres?: StringFieldUpdateOperationsInput | string
    apellido_paterno?: StringFieldUpdateOperationsInput | string
    apellido_materno?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    sexo?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usuariosUncheckedUpdateManyInput = {
    id_usuario?: IntFieldUpdateOperationsInput | number
    id_rol?: IntFieldUpdateOperationsInput | number
    nombres?: StringFieldUpdateOperationsInput | string
    apellido_paterno?: StringFieldUpdateOperationsInput | string
    apellido_materno?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    sexo?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type viajesCreateInput = {
    fecha_inicio?: Date | string | null
    fecha_fin?: Date | string | null
    tarifa: Decimal | DecimalJsLike | number | string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
    itinerarios?: itinerariosCreateNestedManyWithoutViajesInput
    reservas?: reservasCreateNestedManyWithoutViajesInput
    categorias: categoriasCreateNestedOneWithoutViajesInput
    destinos: destinosCreateNestedOneWithoutViajesInput
    hospedajes: hospedajesCreateNestedOneWithoutViajesInput
    paquetes: paquetesCreateNestedOneWithoutViajesInput
  }

  export type viajesUncheckedCreateInput = {
    id_viaje?: number
    id_destino: number
    id_categoria: number
    id_hospedaje: number
    id_paquete: number
    fecha_inicio?: Date | string | null
    fecha_fin?: Date | string | null
    tarifa: Decimal | DecimalJsLike | number | string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
    itinerarios?: itinerariosUncheckedCreateNestedManyWithoutViajesInput
    reservas?: reservasUncheckedCreateNestedManyWithoutViajesInput
  }

  export type viajesUpdateInput = {
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tarifa?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    itinerarios?: itinerariosUpdateManyWithoutViajesNestedInput
    reservas?: reservasUpdateManyWithoutViajesNestedInput
    categorias?: categoriasUpdateOneRequiredWithoutViajesNestedInput
    destinos?: destinosUpdateOneRequiredWithoutViajesNestedInput
    hospedajes?: hospedajesUpdateOneRequiredWithoutViajesNestedInput
    paquetes?: paquetesUpdateOneRequiredWithoutViajesNestedInput
  }

  export type viajesUncheckedUpdateInput = {
    id_viaje?: IntFieldUpdateOperationsInput | number
    id_destino?: IntFieldUpdateOperationsInput | number
    id_categoria?: IntFieldUpdateOperationsInput | number
    id_hospedaje?: IntFieldUpdateOperationsInput | number
    id_paquete?: IntFieldUpdateOperationsInput | number
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tarifa?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    itinerarios?: itinerariosUncheckedUpdateManyWithoutViajesNestedInput
    reservas?: reservasUncheckedUpdateManyWithoutViajesNestedInput
  }

  export type viajesCreateManyInput = {
    id_viaje?: number
    id_destino: number
    id_categoria: number
    id_hospedaje: number
    id_paquete: number
    fecha_inicio?: Date | string | null
    fecha_fin?: Date | string | null
    tarifa: Decimal | DecimalJsLike | number | string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
  }

  export type viajesUpdateManyMutationInput = {
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tarifa?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type viajesUncheckedUpdateManyInput = {
    id_viaje?: IntFieldUpdateOperationsInput | number
    id_destino?: IntFieldUpdateOperationsInput | number
    id_categoria?: IntFieldUpdateOperationsInput | number
    id_hospedaje?: IntFieldUpdateOperationsInput | number
    id_paquete?: IntFieldUpdateOperationsInput | number
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tarifa?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type itinerariosCreateInput = {
    dia: string
    hora_inicio: string
    hora_fin: string
    actividad: string
    descripcion: string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
    viajes: viajesCreateNestedOneWithoutItinerariosInput
  }

  export type itinerariosUncheckedCreateInput = {
    id_itenerario?: number
    id_viaje: number
    dia: string
    hora_inicio: string
    hora_fin: string
    actividad: string
    descripcion: string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
  }

  export type itinerariosUpdateInput = {
    dia?: StringFieldUpdateOperationsInput | string
    hora_inicio?: StringFieldUpdateOperationsInput | string
    hora_fin?: StringFieldUpdateOperationsInput | string
    actividad?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viajes?: viajesUpdateOneRequiredWithoutItinerariosNestedInput
  }

  export type itinerariosUncheckedUpdateInput = {
    id_itenerario?: IntFieldUpdateOperationsInput | number
    id_viaje?: IntFieldUpdateOperationsInput | number
    dia?: StringFieldUpdateOperationsInput | string
    hora_inicio?: StringFieldUpdateOperationsInput | string
    hora_fin?: StringFieldUpdateOperationsInput | string
    actividad?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type itinerariosCreateManyInput = {
    id_itenerario?: number
    id_viaje: number
    dia: string
    hora_inicio: string
    hora_fin: string
    actividad: string
    descripcion: string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
  }

  export type itinerariosUpdateManyMutationInput = {
    dia?: StringFieldUpdateOperationsInput | string
    hora_inicio?: StringFieldUpdateOperationsInput | string
    hora_fin?: StringFieldUpdateOperationsInput | string
    actividad?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type itinerariosUncheckedUpdateManyInput = {
    id_itenerario?: IntFieldUpdateOperationsInput | number
    id_viaje?: IntFieldUpdateOperationsInput | number
    dia?: StringFieldUpdateOperationsInput | string
    hora_inicio?: StringFieldUpdateOperationsInput | string
    hora_fin?: StringFieldUpdateOperationsInput | string
    actividad?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type PaquetesListRelationFilter = {
    every?: paquetesWhereInput
    some?: paquetesWhereInput
    none?: paquetesWhereInput
  }

  export type ViajesListRelationFilter = {
    every?: viajesWhereInput
    some?: viajesWhereInput
    none?: viajesWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type paquetesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type viajesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type categoriasCountOrderByAggregateInput = {
    id_categoria?: SortOrder
    nombre?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_modificacion?: SortOrder
  }

  export type categoriasAvgOrderByAggregateInput = {
    id_categoria?: SortOrder
  }

  export type categoriasMaxOrderByAggregateInput = {
    id_categoria?: SortOrder
    nombre?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_modificacion?: SortOrder
  }

  export type categoriasMinOrderByAggregateInput = {
    id_categoria?: SortOrder
    nombre?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_modificacion?: SortOrder
  }

  export type categoriasSumOrderByAggregateInput = {
    id_categoria?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DestinosListRelationFilter = {
    every?: destinosWhereInput
    some?: destinosWhereInput
    none?: destinosWhereInput
  }

  export type destinosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type paisesCountOrderByAggregateInput = {
    id_pais?: SortOrder
    nombre?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_modificacion?: SortOrder
  }

  export type paisesAvgOrderByAggregateInput = {
    id_pais?: SortOrder
  }

  export type paisesMaxOrderByAggregateInput = {
    id_pais?: SortOrder
    nombre?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_modificacion?: SortOrder
  }

  export type paisesMinOrderByAggregateInput = {
    id_pais?: SortOrder
    nombre?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_modificacion?: SortOrder
  }

  export type paisesSumOrderByAggregateInput = {
    id_pais?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type CategoriasRelationFilter = {
    is?: categoriasWhereInput
    isNot?: categoriasWhereInput
  }

  export type HospedajesRelationFilter = {
    is?: hospedajesWhereInput
    isNot?: hospedajesWhereInput
  }

  export type paquetesCountOrderByAggregateInput = {
    id_paquete?: SortOrder
    id_hospedaje?: SortOrder
    id_categoria?: SortOrder
    nombre?: SortOrder
    transporte?: SortOrder
    precio?: SortOrder
    estado_auditoria?: SortOrder
    fecha_modificacion?: SortOrder
    fecha_creacion?: SortOrder
  }

  export type paquetesAvgOrderByAggregateInput = {
    id_paquete?: SortOrder
    id_hospedaje?: SortOrder
    id_categoria?: SortOrder
    precio?: SortOrder
  }

  export type paquetesMaxOrderByAggregateInput = {
    id_paquete?: SortOrder
    id_hospedaje?: SortOrder
    id_categoria?: SortOrder
    nombre?: SortOrder
    transporte?: SortOrder
    precio?: SortOrder
    estado_auditoria?: SortOrder
    fecha_modificacion?: SortOrder
    fecha_creacion?: SortOrder
  }

  export type paquetesMinOrderByAggregateInput = {
    id_paquete?: SortOrder
    id_hospedaje?: SortOrder
    id_categoria?: SortOrder
    nombre?: SortOrder
    transporte?: SortOrder
    precio?: SortOrder
    estado_auditoria?: SortOrder
    fecha_modificacion?: SortOrder
    fecha_creacion?: SortOrder
  }

  export type paquetesSumOrderByAggregateInput = {
    id_paquete?: SortOrder
    id_hospedaje?: SortOrder
    id_categoria?: SortOrder
    precio?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type UsuariosListRelationFilter = {
    every?: usuariosWhereInput
    some?: usuariosWhereInput
    none?: usuariosWhereInput
  }

  export type usuariosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type rolesCountOrderByAggregateInput = {
    id_rol?: SortOrder
    nombre?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_modificacion?: SortOrder
  }

  export type rolesAvgOrderByAggregateInput = {
    id_rol?: SortOrder
  }

  export type rolesMaxOrderByAggregateInput = {
    id_rol?: SortOrder
    nombre?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_modificacion?: SortOrder
  }

  export type rolesMinOrderByAggregateInput = {
    id_rol?: SortOrder
    nombre?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_modificacion?: SortOrder
  }

  export type rolesSumOrderByAggregateInput = {
    id_rol?: SortOrder
  }

  export type PaisesRelationFilter = {
    is?: paisesWhereInput
    isNot?: paisesWhereInput
  }

  export type HospedajesListRelationFilter = {
    every?: hospedajesWhereInput
    some?: hospedajesWhereInput
    none?: hospedajesWhereInput
  }

  export type hospedajesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type destinosCountOrderByAggregateInput = {
    id_destino?: SortOrder
    id_pais?: SortOrder
    nombre?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_modificacion?: SortOrder
  }

  export type destinosAvgOrderByAggregateInput = {
    id_destino?: SortOrder
    id_pais?: SortOrder
  }

  export type destinosMaxOrderByAggregateInput = {
    id_destino?: SortOrder
    id_pais?: SortOrder
    nombre?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_modificacion?: SortOrder
  }

  export type destinosMinOrderByAggregateInput = {
    id_destino?: SortOrder
    id_pais?: SortOrder
    nombre?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_modificacion?: SortOrder
  }

  export type destinosSumOrderByAggregateInput = {
    id_destino?: SortOrder
    id_pais?: SortOrder
  }

  export type DestinosRelationFilter = {
    is?: destinosWhereInput
    isNot?: destinosWhereInput
  }

  export type hospedajesCountOrderByAggregateInput = {
    id_hospedaje?: SortOrder
    id_destino?: SortOrder
    nombre?: SortOrder
    precio?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_modificacion?: SortOrder
  }

  export type hospedajesAvgOrderByAggregateInput = {
    id_hospedaje?: SortOrder
    id_destino?: SortOrder
    precio?: SortOrder
  }

  export type hospedajesMaxOrderByAggregateInput = {
    id_hospedaje?: SortOrder
    id_destino?: SortOrder
    nombre?: SortOrder
    precio?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_modificacion?: SortOrder
  }

  export type hospedajesMinOrderByAggregateInput = {
    id_hospedaje?: SortOrder
    id_destino?: SortOrder
    nombre?: SortOrder
    precio?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_modificacion?: SortOrder
  }

  export type hospedajesSumOrderByAggregateInput = {
    id_hospedaje?: SortOrder
    id_destino?: SortOrder
    precio?: SortOrder
  }

  export type UsuariosRelationFilter = {
    is?: usuariosWhereInput
    isNot?: usuariosWhereInput
  }

  export type ViajesRelationFilter = {
    is?: viajesWhereInput
    isNot?: viajesWhereInput
  }

  export type reservasCountOrderByAggregateInput = {
    id_reserva?: SortOrder
    id_usuario?: SortOrder
    id_viaje?: SortOrder
    numero_personas?: SortOrder
    metodo_pago?: SortOrder
    pago_total?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_modificacion?: SortOrder
  }

  export type reservasAvgOrderByAggregateInput = {
    id_reserva?: SortOrder
    id_usuario?: SortOrder
    id_viaje?: SortOrder
    pago_total?: SortOrder
  }

  export type reservasMaxOrderByAggregateInput = {
    id_reserva?: SortOrder
    id_usuario?: SortOrder
    id_viaje?: SortOrder
    numero_personas?: SortOrder
    metodo_pago?: SortOrder
    pago_total?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_modificacion?: SortOrder
  }

  export type reservasMinOrderByAggregateInput = {
    id_reserva?: SortOrder
    id_usuario?: SortOrder
    id_viaje?: SortOrder
    numero_personas?: SortOrder
    metodo_pago?: SortOrder
    pago_total?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_modificacion?: SortOrder
  }

  export type reservasSumOrderByAggregateInput = {
    id_reserva?: SortOrder
    id_usuario?: SortOrder
    id_viaje?: SortOrder
    pago_total?: SortOrder
  }

  export type ReservasListRelationFilter = {
    every?: reservasWhereInput
    some?: reservasWhereInput
    none?: reservasWhereInput
  }

  export type RolesRelationFilter = {
    is?: rolesWhereInput
    isNot?: rolesWhereInput
  }

  export type reservasOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usuariosCountOrderByAggregateInput = {
    id_usuario?: SortOrder
    id_rol?: SortOrder
    nombres?: SortOrder
    apellido_paterno?: SortOrder
    apellido_materno?: SortOrder
    username?: SortOrder
    email?: SortOrder
    clave?: SortOrder
    telefono?: SortOrder
    direccion?: SortOrder
    sexo?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_modificacion?: SortOrder
  }

  export type usuariosAvgOrderByAggregateInput = {
    id_usuario?: SortOrder
    id_rol?: SortOrder
  }

  export type usuariosMaxOrderByAggregateInput = {
    id_usuario?: SortOrder
    id_rol?: SortOrder
    nombres?: SortOrder
    apellido_paterno?: SortOrder
    apellido_materno?: SortOrder
    username?: SortOrder
    email?: SortOrder
    clave?: SortOrder
    telefono?: SortOrder
    direccion?: SortOrder
    sexo?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_modificacion?: SortOrder
  }

  export type usuariosMinOrderByAggregateInput = {
    id_usuario?: SortOrder
    id_rol?: SortOrder
    nombres?: SortOrder
    apellido_paterno?: SortOrder
    apellido_materno?: SortOrder
    username?: SortOrder
    email?: SortOrder
    clave?: SortOrder
    telefono?: SortOrder
    direccion?: SortOrder
    sexo?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_modificacion?: SortOrder
  }

  export type usuariosSumOrderByAggregateInput = {
    id_usuario?: SortOrder
    id_rol?: SortOrder
  }

  export type ItinerariosListRelationFilter = {
    every?: itinerariosWhereInput
    some?: itinerariosWhereInput
    none?: itinerariosWhereInput
  }

  export type PaquetesRelationFilter = {
    is?: paquetesWhereInput
    isNot?: paquetesWhereInput
  }

  export type itinerariosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type viajesCountOrderByAggregateInput = {
    id_viaje?: SortOrder
    id_destino?: SortOrder
    id_categoria?: SortOrder
    id_hospedaje?: SortOrder
    id_paquete?: SortOrder
    fecha_inicio?: SortOrder
    fecha_fin?: SortOrder
    tarifa?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_modificacion?: SortOrder
  }

  export type viajesAvgOrderByAggregateInput = {
    id_viaje?: SortOrder
    id_destino?: SortOrder
    id_categoria?: SortOrder
    id_hospedaje?: SortOrder
    id_paquete?: SortOrder
    tarifa?: SortOrder
  }

  export type viajesMaxOrderByAggregateInput = {
    id_viaje?: SortOrder
    id_destino?: SortOrder
    id_categoria?: SortOrder
    id_hospedaje?: SortOrder
    id_paquete?: SortOrder
    fecha_inicio?: SortOrder
    fecha_fin?: SortOrder
    tarifa?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_modificacion?: SortOrder
  }

  export type viajesMinOrderByAggregateInput = {
    id_viaje?: SortOrder
    id_destino?: SortOrder
    id_categoria?: SortOrder
    id_hospedaje?: SortOrder
    id_paquete?: SortOrder
    fecha_inicio?: SortOrder
    fecha_fin?: SortOrder
    tarifa?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_modificacion?: SortOrder
  }

  export type viajesSumOrderByAggregateInput = {
    id_viaje?: SortOrder
    id_destino?: SortOrder
    id_categoria?: SortOrder
    id_hospedaje?: SortOrder
    id_paquete?: SortOrder
    tarifa?: SortOrder
  }

  export type itinerariosCountOrderByAggregateInput = {
    id_itenerario?: SortOrder
    id_viaje?: SortOrder
    dia?: SortOrder
    hora_inicio?: SortOrder
    hora_fin?: SortOrder
    actividad?: SortOrder
    descripcion?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_modificacion?: SortOrder
  }

  export type itinerariosAvgOrderByAggregateInput = {
    id_itenerario?: SortOrder
    id_viaje?: SortOrder
  }

  export type itinerariosMaxOrderByAggregateInput = {
    id_itenerario?: SortOrder
    id_viaje?: SortOrder
    dia?: SortOrder
    hora_inicio?: SortOrder
    hora_fin?: SortOrder
    actividad?: SortOrder
    descripcion?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_modificacion?: SortOrder
  }

  export type itinerariosMinOrderByAggregateInput = {
    id_itenerario?: SortOrder
    id_viaje?: SortOrder
    dia?: SortOrder
    hora_inicio?: SortOrder
    hora_fin?: SortOrder
    actividad?: SortOrder
    descripcion?: SortOrder
    estado_auditoria?: SortOrder
    fecha_creacion?: SortOrder
    fecha_modificacion?: SortOrder
  }

  export type itinerariosSumOrderByAggregateInput = {
    id_itenerario?: SortOrder
    id_viaje?: SortOrder
  }

  export type paquetesCreateNestedManyWithoutCategoriasInput = {
    create?: XOR<paquetesCreateWithoutCategoriasInput, paquetesUncheckedCreateWithoutCategoriasInput> | paquetesCreateWithoutCategoriasInput[] | paquetesUncheckedCreateWithoutCategoriasInput[]
    connectOrCreate?: paquetesCreateOrConnectWithoutCategoriasInput | paquetesCreateOrConnectWithoutCategoriasInput[]
    createMany?: paquetesCreateManyCategoriasInputEnvelope
    connect?: paquetesWhereUniqueInput | paquetesWhereUniqueInput[]
  }

  export type viajesCreateNestedManyWithoutCategoriasInput = {
    create?: XOR<viajesCreateWithoutCategoriasInput, viajesUncheckedCreateWithoutCategoriasInput> | viajesCreateWithoutCategoriasInput[] | viajesUncheckedCreateWithoutCategoriasInput[]
    connectOrCreate?: viajesCreateOrConnectWithoutCategoriasInput | viajesCreateOrConnectWithoutCategoriasInput[]
    createMany?: viajesCreateManyCategoriasInputEnvelope
    connect?: viajesWhereUniqueInput | viajesWhereUniqueInput[]
  }

  export type paquetesUncheckedCreateNestedManyWithoutCategoriasInput = {
    create?: XOR<paquetesCreateWithoutCategoriasInput, paquetesUncheckedCreateWithoutCategoriasInput> | paquetesCreateWithoutCategoriasInput[] | paquetesUncheckedCreateWithoutCategoriasInput[]
    connectOrCreate?: paquetesCreateOrConnectWithoutCategoriasInput | paquetesCreateOrConnectWithoutCategoriasInput[]
    createMany?: paquetesCreateManyCategoriasInputEnvelope
    connect?: paquetesWhereUniqueInput | paquetesWhereUniqueInput[]
  }

  export type viajesUncheckedCreateNestedManyWithoutCategoriasInput = {
    create?: XOR<viajesCreateWithoutCategoriasInput, viajesUncheckedCreateWithoutCategoriasInput> | viajesCreateWithoutCategoriasInput[] | viajesUncheckedCreateWithoutCategoriasInput[]
    connectOrCreate?: viajesCreateOrConnectWithoutCategoriasInput | viajesCreateOrConnectWithoutCategoriasInput[]
    createMany?: viajesCreateManyCategoriasInputEnvelope
    connect?: viajesWhereUniqueInput | viajesWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type paquetesUpdateManyWithoutCategoriasNestedInput = {
    create?: XOR<paquetesCreateWithoutCategoriasInput, paquetesUncheckedCreateWithoutCategoriasInput> | paquetesCreateWithoutCategoriasInput[] | paquetesUncheckedCreateWithoutCategoriasInput[]
    connectOrCreate?: paquetesCreateOrConnectWithoutCategoriasInput | paquetesCreateOrConnectWithoutCategoriasInput[]
    upsert?: paquetesUpsertWithWhereUniqueWithoutCategoriasInput | paquetesUpsertWithWhereUniqueWithoutCategoriasInput[]
    createMany?: paquetesCreateManyCategoriasInputEnvelope
    set?: paquetesWhereUniqueInput | paquetesWhereUniqueInput[]
    disconnect?: paquetesWhereUniqueInput | paquetesWhereUniqueInput[]
    delete?: paquetesWhereUniqueInput | paquetesWhereUniqueInput[]
    connect?: paquetesWhereUniqueInput | paquetesWhereUniqueInput[]
    update?: paquetesUpdateWithWhereUniqueWithoutCategoriasInput | paquetesUpdateWithWhereUniqueWithoutCategoriasInput[]
    updateMany?: paquetesUpdateManyWithWhereWithoutCategoriasInput | paquetesUpdateManyWithWhereWithoutCategoriasInput[]
    deleteMany?: paquetesScalarWhereInput | paquetesScalarWhereInput[]
  }

  export type viajesUpdateManyWithoutCategoriasNestedInput = {
    create?: XOR<viajesCreateWithoutCategoriasInput, viajesUncheckedCreateWithoutCategoriasInput> | viajesCreateWithoutCategoriasInput[] | viajesUncheckedCreateWithoutCategoriasInput[]
    connectOrCreate?: viajesCreateOrConnectWithoutCategoriasInput | viajesCreateOrConnectWithoutCategoriasInput[]
    upsert?: viajesUpsertWithWhereUniqueWithoutCategoriasInput | viajesUpsertWithWhereUniqueWithoutCategoriasInput[]
    createMany?: viajesCreateManyCategoriasInputEnvelope
    set?: viajesWhereUniqueInput | viajesWhereUniqueInput[]
    disconnect?: viajesWhereUniqueInput | viajesWhereUniqueInput[]
    delete?: viajesWhereUniqueInput | viajesWhereUniqueInput[]
    connect?: viajesWhereUniqueInput | viajesWhereUniqueInput[]
    update?: viajesUpdateWithWhereUniqueWithoutCategoriasInput | viajesUpdateWithWhereUniqueWithoutCategoriasInput[]
    updateMany?: viajesUpdateManyWithWhereWithoutCategoriasInput | viajesUpdateManyWithWhereWithoutCategoriasInput[]
    deleteMany?: viajesScalarWhereInput | viajesScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type paquetesUncheckedUpdateManyWithoutCategoriasNestedInput = {
    create?: XOR<paquetesCreateWithoutCategoriasInput, paquetesUncheckedCreateWithoutCategoriasInput> | paquetesCreateWithoutCategoriasInput[] | paquetesUncheckedCreateWithoutCategoriasInput[]
    connectOrCreate?: paquetesCreateOrConnectWithoutCategoriasInput | paquetesCreateOrConnectWithoutCategoriasInput[]
    upsert?: paquetesUpsertWithWhereUniqueWithoutCategoriasInput | paquetesUpsertWithWhereUniqueWithoutCategoriasInput[]
    createMany?: paquetesCreateManyCategoriasInputEnvelope
    set?: paquetesWhereUniqueInput | paquetesWhereUniqueInput[]
    disconnect?: paquetesWhereUniqueInput | paquetesWhereUniqueInput[]
    delete?: paquetesWhereUniqueInput | paquetesWhereUniqueInput[]
    connect?: paquetesWhereUniqueInput | paquetesWhereUniqueInput[]
    update?: paquetesUpdateWithWhereUniqueWithoutCategoriasInput | paquetesUpdateWithWhereUniqueWithoutCategoriasInput[]
    updateMany?: paquetesUpdateManyWithWhereWithoutCategoriasInput | paquetesUpdateManyWithWhereWithoutCategoriasInput[]
    deleteMany?: paquetesScalarWhereInput | paquetesScalarWhereInput[]
  }

  export type viajesUncheckedUpdateManyWithoutCategoriasNestedInput = {
    create?: XOR<viajesCreateWithoutCategoriasInput, viajesUncheckedCreateWithoutCategoriasInput> | viajesCreateWithoutCategoriasInput[] | viajesUncheckedCreateWithoutCategoriasInput[]
    connectOrCreate?: viajesCreateOrConnectWithoutCategoriasInput | viajesCreateOrConnectWithoutCategoriasInput[]
    upsert?: viajesUpsertWithWhereUniqueWithoutCategoriasInput | viajesUpsertWithWhereUniqueWithoutCategoriasInput[]
    createMany?: viajesCreateManyCategoriasInputEnvelope
    set?: viajesWhereUniqueInput | viajesWhereUniqueInput[]
    disconnect?: viajesWhereUniqueInput | viajesWhereUniqueInput[]
    delete?: viajesWhereUniqueInput | viajesWhereUniqueInput[]
    connect?: viajesWhereUniqueInput | viajesWhereUniqueInput[]
    update?: viajesUpdateWithWhereUniqueWithoutCategoriasInput | viajesUpdateWithWhereUniqueWithoutCategoriasInput[]
    updateMany?: viajesUpdateManyWithWhereWithoutCategoriasInput | viajesUpdateManyWithWhereWithoutCategoriasInput[]
    deleteMany?: viajesScalarWhereInput | viajesScalarWhereInput[]
  }

  export type destinosCreateNestedManyWithoutPaisesInput = {
    create?: XOR<destinosCreateWithoutPaisesInput, destinosUncheckedCreateWithoutPaisesInput> | destinosCreateWithoutPaisesInput[] | destinosUncheckedCreateWithoutPaisesInput[]
    connectOrCreate?: destinosCreateOrConnectWithoutPaisesInput | destinosCreateOrConnectWithoutPaisesInput[]
    createMany?: destinosCreateManyPaisesInputEnvelope
    connect?: destinosWhereUniqueInput | destinosWhereUniqueInput[]
  }

  export type destinosUncheckedCreateNestedManyWithoutPaisesInput = {
    create?: XOR<destinosCreateWithoutPaisesInput, destinosUncheckedCreateWithoutPaisesInput> | destinosCreateWithoutPaisesInput[] | destinosUncheckedCreateWithoutPaisesInput[]
    connectOrCreate?: destinosCreateOrConnectWithoutPaisesInput | destinosCreateOrConnectWithoutPaisesInput[]
    createMany?: destinosCreateManyPaisesInputEnvelope
    connect?: destinosWhereUniqueInput | destinosWhereUniqueInput[]
  }

  export type destinosUpdateManyWithoutPaisesNestedInput = {
    create?: XOR<destinosCreateWithoutPaisesInput, destinosUncheckedCreateWithoutPaisesInput> | destinosCreateWithoutPaisesInput[] | destinosUncheckedCreateWithoutPaisesInput[]
    connectOrCreate?: destinosCreateOrConnectWithoutPaisesInput | destinosCreateOrConnectWithoutPaisesInput[]
    upsert?: destinosUpsertWithWhereUniqueWithoutPaisesInput | destinosUpsertWithWhereUniqueWithoutPaisesInput[]
    createMany?: destinosCreateManyPaisesInputEnvelope
    set?: destinosWhereUniqueInput | destinosWhereUniqueInput[]
    disconnect?: destinosWhereUniqueInput | destinosWhereUniqueInput[]
    delete?: destinosWhereUniqueInput | destinosWhereUniqueInput[]
    connect?: destinosWhereUniqueInput | destinosWhereUniqueInput[]
    update?: destinosUpdateWithWhereUniqueWithoutPaisesInput | destinosUpdateWithWhereUniqueWithoutPaisesInput[]
    updateMany?: destinosUpdateManyWithWhereWithoutPaisesInput | destinosUpdateManyWithWhereWithoutPaisesInput[]
    deleteMany?: destinosScalarWhereInput | destinosScalarWhereInput[]
  }

  export type destinosUncheckedUpdateManyWithoutPaisesNestedInput = {
    create?: XOR<destinosCreateWithoutPaisesInput, destinosUncheckedCreateWithoutPaisesInput> | destinosCreateWithoutPaisesInput[] | destinosUncheckedCreateWithoutPaisesInput[]
    connectOrCreate?: destinosCreateOrConnectWithoutPaisesInput | destinosCreateOrConnectWithoutPaisesInput[]
    upsert?: destinosUpsertWithWhereUniqueWithoutPaisesInput | destinosUpsertWithWhereUniqueWithoutPaisesInput[]
    createMany?: destinosCreateManyPaisesInputEnvelope
    set?: destinosWhereUniqueInput | destinosWhereUniqueInput[]
    disconnect?: destinosWhereUniqueInput | destinosWhereUniqueInput[]
    delete?: destinosWhereUniqueInput | destinosWhereUniqueInput[]
    connect?: destinosWhereUniqueInput | destinosWhereUniqueInput[]
    update?: destinosUpdateWithWhereUniqueWithoutPaisesInput | destinosUpdateWithWhereUniqueWithoutPaisesInput[]
    updateMany?: destinosUpdateManyWithWhereWithoutPaisesInput | destinosUpdateManyWithWhereWithoutPaisesInput[]
    deleteMany?: destinosScalarWhereInput | destinosScalarWhereInput[]
  }

  export type categoriasCreateNestedOneWithoutPaquetesInput = {
    create?: XOR<categoriasCreateWithoutPaquetesInput, categoriasUncheckedCreateWithoutPaquetesInput>
    connectOrCreate?: categoriasCreateOrConnectWithoutPaquetesInput
    connect?: categoriasWhereUniqueInput
  }

  export type hospedajesCreateNestedOneWithoutPaquetesInput = {
    create?: XOR<hospedajesCreateWithoutPaquetesInput, hospedajesUncheckedCreateWithoutPaquetesInput>
    connectOrCreate?: hospedajesCreateOrConnectWithoutPaquetesInput
    connect?: hospedajesWhereUniqueInput
  }

  export type viajesCreateNestedManyWithoutPaquetesInput = {
    create?: XOR<viajesCreateWithoutPaquetesInput, viajesUncheckedCreateWithoutPaquetesInput> | viajesCreateWithoutPaquetesInput[] | viajesUncheckedCreateWithoutPaquetesInput[]
    connectOrCreate?: viajesCreateOrConnectWithoutPaquetesInput | viajesCreateOrConnectWithoutPaquetesInput[]
    createMany?: viajesCreateManyPaquetesInputEnvelope
    connect?: viajesWhereUniqueInput | viajesWhereUniqueInput[]
  }

  export type viajesUncheckedCreateNestedManyWithoutPaquetesInput = {
    create?: XOR<viajesCreateWithoutPaquetesInput, viajesUncheckedCreateWithoutPaquetesInput> | viajesCreateWithoutPaquetesInput[] | viajesUncheckedCreateWithoutPaquetesInput[]
    connectOrCreate?: viajesCreateOrConnectWithoutPaquetesInput | viajesCreateOrConnectWithoutPaquetesInput[]
    createMany?: viajesCreateManyPaquetesInputEnvelope
    connect?: viajesWhereUniqueInput | viajesWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type categoriasUpdateOneRequiredWithoutPaquetesNestedInput = {
    create?: XOR<categoriasCreateWithoutPaquetesInput, categoriasUncheckedCreateWithoutPaquetesInput>
    connectOrCreate?: categoriasCreateOrConnectWithoutPaquetesInput
    upsert?: categoriasUpsertWithoutPaquetesInput
    connect?: categoriasWhereUniqueInput
    update?: XOR<XOR<categoriasUpdateToOneWithWhereWithoutPaquetesInput, categoriasUpdateWithoutPaquetesInput>, categoriasUncheckedUpdateWithoutPaquetesInput>
  }

  export type hospedajesUpdateOneRequiredWithoutPaquetesNestedInput = {
    create?: XOR<hospedajesCreateWithoutPaquetesInput, hospedajesUncheckedCreateWithoutPaquetesInput>
    connectOrCreate?: hospedajesCreateOrConnectWithoutPaquetesInput
    upsert?: hospedajesUpsertWithoutPaquetesInput
    connect?: hospedajesWhereUniqueInput
    update?: XOR<XOR<hospedajesUpdateToOneWithWhereWithoutPaquetesInput, hospedajesUpdateWithoutPaquetesInput>, hospedajesUncheckedUpdateWithoutPaquetesInput>
  }

  export type viajesUpdateManyWithoutPaquetesNestedInput = {
    create?: XOR<viajesCreateWithoutPaquetesInput, viajesUncheckedCreateWithoutPaquetesInput> | viajesCreateWithoutPaquetesInput[] | viajesUncheckedCreateWithoutPaquetesInput[]
    connectOrCreate?: viajesCreateOrConnectWithoutPaquetesInput | viajesCreateOrConnectWithoutPaquetesInput[]
    upsert?: viajesUpsertWithWhereUniqueWithoutPaquetesInput | viajesUpsertWithWhereUniqueWithoutPaquetesInput[]
    createMany?: viajesCreateManyPaquetesInputEnvelope
    set?: viajesWhereUniqueInput | viajesWhereUniqueInput[]
    disconnect?: viajesWhereUniqueInput | viajesWhereUniqueInput[]
    delete?: viajesWhereUniqueInput | viajesWhereUniqueInput[]
    connect?: viajesWhereUniqueInput | viajesWhereUniqueInput[]
    update?: viajesUpdateWithWhereUniqueWithoutPaquetesInput | viajesUpdateWithWhereUniqueWithoutPaquetesInput[]
    updateMany?: viajesUpdateManyWithWhereWithoutPaquetesInput | viajesUpdateManyWithWhereWithoutPaquetesInput[]
    deleteMany?: viajesScalarWhereInput | viajesScalarWhereInput[]
  }

  export type viajesUncheckedUpdateManyWithoutPaquetesNestedInput = {
    create?: XOR<viajesCreateWithoutPaquetesInput, viajesUncheckedCreateWithoutPaquetesInput> | viajesCreateWithoutPaquetesInput[] | viajesUncheckedCreateWithoutPaquetesInput[]
    connectOrCreate?: viajesCreateOrConnectWithoutPaquetesInput | viajesCreateOrConnectWithoutPaquetesInput[]
    upsert?: viajesUpsertWithWhereUniqueWithoutPaquetesInput | viajesUpsertWithWhereUniqueWithoutPaquetesInput[]
    createMany?: viajesCreateManyPaquetesInputEnvelope
    set?: viajesWhereUniqueInput | viajesWhereUniqueInput[]
    disconnect?: viajesWhereUniqueInput | viajesWhereUniqueInput[]
    delete?: viajesWhereUniqueInput | viajesWhereUniqueInput[]
    connect?: viajesWhereUniqueInput | viajesWhereUniqueInput[]
    update?: viajesUpdateWithWhereUniqueWithoutPaquetesInput | viajesUpdateWithWhereUniqueWithoutPaquetesInput[]
    updateMany?: viajesUpdateManyWithWhereWithoutPaquetesInput | viajesUpdateManyWithWhereWithoutPaquetesInput[]
    deleteMany?: viajesScalarWhereInput | viajesScalarWhereInput[]
  }

  export type usuariosCreateNestedManyWithoutRolesInput = {
    create?: XOR<usuariosCreateWithoutRolesInput, usuariosUncheckedCreateWithoutRolesInput> | usuariosCreateWithoutRolesInput[] | usuariosUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: usuariosCreateOrConnectWithoutRolesInput | usuariosCreateOrConnectWithoutRolesInput[]
    createMany?: usuariosCreateManyRolesInputEnvelope
    connect?: usuariosWhereUniqueInput | usuariosWhereUniqueInput[]
  }

  export type usuariosUncheckedCreateNestedManyWithoutRolesInput = {
    create?: XOR<usuariosCreateWithoutRolesInput, usuariosUncheckedCreateWithoutRolesInput> | usuariosCreateWithoutRolesInput[] | usuariosUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: usuariosCreateOrConnectWithoutRolesInput | usuariosCreateOrConnectWithoutRolesInput[]
    createMany?: usuariosCreateManyRolesInputEnvelope
    connect?: usuariosWhereUniqueInput | usuariosWhereUniqueInput[]
  }

  export type usuariosUpdateManyWithoutRolesNestedInput = {
    create?: XOR<usuariosCreateWithoutRolesInput, usuariosUncheckedCreateWithoutRolesInput> | usuariosCreateWithoutRolesInput[] | usuariosUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: usuariosCreateOrConnectWithoutRolesInput | usuariosCreateOrConnectWithoutRolesInput[]
    upsert?: usuariosUpsertWithWhereUniqueWithoutRolesInput | usuariosUpsertWithWhereUniqueWithoutRolesInput[]
    createMany?: usuariosCreateManyRolesInputEnvelope
    set?: usuariosWhereUniqueInput | usuariosWhereUniqueInput[]
    disconnect?: usuariosWhereUniqueInput | usuariosWhereUniqueInput[]
    delete?: usuariosWhereUniqueInput | usuariosWhereUniqueInput[]
    connect?: usuariosWhereUniqueInput | usuariosWhereUniqueInput[]
    update?: usuariosUpdateWithWhereUniqueWithoutRolesInput | usuariosUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: usuariosUpdateManyWithWhereWithoutRolesInput | usuariosUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: usuariosScalarWhereInput | usuariosScalarWhereInput[]
  }

  export type usuariosUncheckedUpdateManyWithoutRolesNestedInput = {
    create?: XOR<usuariosCreateWithoutRolesInput, usuariosUncheckedCreateWithoutRolesInput> | usuariosCreateWithoutRolesInput[] | usuariosUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: usuariosCreateOrConnectWithoutRolesInput | usuariosCreateOrConnectWithoutRolesInput[]
    upsert?: usuariosUpsertWithWhereUniqueWithoutRolesInput | usuariosUpsertWithWhereUniqueWithoutRolesInput[]
    createMany?: usuariosCreateManyRolesInputEnvelope
    set?: usuariosWhereUniqueInput | usuariosWhereUniqueInput[]
    disconnect?: usuariosWhereUniqueInput | usuariosWhereUniqueInput[]
    delete?: usuariosWhereUniqueInput | usuariosWhereUniqueInput[]
    connect?: usuariosWhereUniqueInput | usuariosWhereUniqueInput[]
    update?: usuariosUpdateWithWhereUniqueWithoutRolesInput | usuariosUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: usuariosUpdateManyWithWhereWithoutRolesInput | usuariosUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: usuariosScalarWhereInput | usuariosScalarWhereInput[]
  }

  export type paisesCreateNestedOneWithoutDestinosInput = {
    create?: XOR<paisesCreateWithoutDestinosInput, paisesUncheckedCreateWithoutDestinosInput>
    connectOrCreate?: paisesCreateOrConnectWithoutDestinosInput
    connect?: paisesWhereUniqueInput
  }

  export type hospedajesCreateNestedManyWithoutDestinosInput = {
    create?: XOR<hospedajesCreateWithoutDestinosInput, hospedajesUncheckedCreateWithoutDestinosInput> | hospedajesCreateWithoutDestinosInput[] | hospedajesUncheckedCreateWithoutDestinosInput[]
    connectOrCreate?: hospedajesCreateOrConnectWithoutDestinosInput | hospedajesCreateOrConnectWithoutDestinosInput[]
    createMany?: hospedajesCreateManyDestinosInputEnvelope
    connect?: hospedajesWhereUniqueInput | hospedajesWhereUniqueInput[]
  }

  export type viajesCreateNestedManyWithoutDestinosInput = {
    create?: XOR<viajesCreateWithoutDestinosInput, viajesUncheckedCreateWithoutDestinosInput> | viajesCreateWithoutDestinosInput[] | viajesUncheckedCreateWithoutDestinosInput[]
    connectOrCreate?: viajesCreateOrConnectWithoutDestinosInput | viajesCreateOrConnectWithoutDestinosInput[]
    createMany?: viajesCreateManyDestinosInputEnvelope
    connect?: viajesWhereUniqueInput | viajesWhereUniqueInput[]
  }

  export type hospedajesUncheckedCreateNestedManyWithoutDestinosInput = {
    create?: XOR<hospedajesCreateWithoutDestinosInput, hospedajesUncheckedCreateWithoutDestinosInput> | hospedajesCreateWithoutDestinosInput[] | hospedajesUncheckedCreateWithoutDestinosInput[]
    connectOrCreate?: hospedajesCreateOrConnectWithoutDestinosInput | hospedajesCreateOrConnectWithoutDestinosInput[]
    createMany?: hospedajesCreateManyDestinosInputEnvelope
    connect?: hospedajesWhereUniqueInput | hospedajesWhereUniqueInput[]
  }

  export type viajesUncheckedCreateNestedManyWithoutDestinosInput = {
    create?: XOR<viajesCreateWithoutDestinosInput, viajesUncheckedCreateWithoutDestinosInput> | viajesCreateWithoutDestinosInput[] | viajesUncheckedCreateWithoutDestinosInput[]
    connectOrCreate?: viajesCreateOrConnectWithoutDestinosInput | viajesCreateOrConnectWithoutDestinosInput[]
    createMany?: viajesCreateManyDestinosInputEnvelope
    connect?: viajesWhereUniqueInput | viajesWhereUniqueInput[]
  }

  export type paisesUpdateOneRequiredWithoutDestinosNestedInput = {
    create?: XOR<paisesCreateWithoutDestinosInput, paisesUncheckedCreateWithoutDestinosInput>
    connectOrCreate?: paisesCreateOrConnectWithoutDestinosInput
    upsert?: paisesUpsertWithoutDestinosInput
    connect?: paisesWhereUniqueInput
    update?: XOR<XOR<paisesUpdateToOneWithWhereWithoutDestinosInput, paisesUpdateWithoutDestinosInput>, paisesUncheckedUpdateWithoutDestinosInput>
  }

  export type hospedajesUpdateManyWithoutDestinosNestedInput = {
    create?: XOR<hospedajesCreateWithoutDestinosInput, hospedajesUncheckedCreateWithoutDestinosInput> | hospedajesCreateWithoutDestinosInput[] | hospedajesUncheckedCreateWithoutDestinosInput[]
    connectOrCreate?: hospedajesCreateOrConnectWithoutDestinosInput | hospedajesCreateOrConnectWithoutDestinosInput[]
    upsert?: hospedajesUpsertWithWhereUniqueWithoutDestinosInput | hospedajesUpsertWithWhereUniqueWithoutDestinosInput[]
    createMany?: hospedajesCreateManyDestinosInputEnvelope
    set?: hospedajesWhereUniqueInput | hospedajesWhereUniqueInput[]
    disconnect?: hospedajesWhereUniqueInput | hospedajesWhereUniqueInput[]
    delete?: hospedajesWhereUniqueInput | hospedajesWhereUniqueInput[]
    connect?: hospedajesWhereUniqueInput | hospedajesWhereUniqueInput[]
    update?: hospedajesUpdateWithWhereUniqueWithoutDestinosInput | hospedajesUpdateWithWhereUniqueWithoutDestinosInput[]
    updateMany?: hospedajesUpdateManyWithWhereWithoutDestinosInput | hospedajesUpdateManyWithWhereWithoutDestinosInput[]
    deleteMany?: hospedajesScalarWhereInput | hospedajesScalarWhereInput[]
  }

  export type viajesUpdateManyWithoutDestinosNestedInput = {
    create?: XOR<viajesCreateWithoutDestinosInput, viajesUncheckedCreateWithoutDestinosInput> | viajesCreateWithoutDestinosInput[] | viajesUncheckedCreateWithoutDestinosInput[]
    connectOrCreate?: viajesCreateOrConnectWithoutDestinosInput | viajesCreateOrConnectWithoutDestinosInput[]
    upsert?: viajesUpsertWithWhereUniqueWithoutDestinosInput | viajesUpsertWithWhereUniqueWithoutDestinosInput[]
    createMany?: viajesCreateManyDestinosInputEnvelope
    set?: viajesWhereUniqueInput | viajesWhereUniqueInput[]
    disconnect?: viajesWhereUniqueInput | viajesWhereUniqueInput[]
    delete?: viajesWhereUniqueInput | viajesWhereUniqueInput[]
    connect?: viajesWhereUniqueInput | viajesWhereUniqueInput[]
    update?: viajesUpdateWithWhereUniqueWithoutDestinosInput | viajesUpdateWithWhereUniqueWithoutDestinosInput[]
    updateMany?: viajesUpdateManyWithWhereWithoutDestinosInput | viajesUpdateManyWithWhereWithoutDestinosInput[]
    deleteMany?: viajesScalarWhereInput | viajesScalarWhereInput[]
  }

  export type hospedajesUncheckedUpdateManyWithoutDestinosNestedInput = {
    create?: XOR<hospedajesCreateWithoutDestinosInput, hospedajesUncheckedCreateWithoutDestinosInput> | hospedajesCreateWithoutDestinosInput[] | hospedajesUncheckedCreateWithoutDestinosInput[]
    connectOrCreate?: hospedajesCreateOrConnectWithoutDestinosInput | hospedajesCreateOrConnectWithoutDestinosInput[]
    upsert?: hospedajesUpsertWithWhereUniqueWithoutDestinosInput | hospedajesUpsertWithWhereUniqueWithoutDestinosInput[]
    createMany?: hospedajesCreateManyDestinosInputEnvelope
    set?: hospedajesWhereUniqueInput | hospedajesWhereUniqueInput[]
    disconnect?: hospedajesWhereUniqueInput | hospedajesWhereUniqueInput[]
    delete?: hospedajesWhereUniqueInput | hospedajesWhereUniqueInput[]
    connect?: hospedajesWhereUniqueInput | hospedajesWhereUniqueInput[]
    update?: hospedajesUpdateWithWhereUniqueWithoutDestinosInput | hospedajesUpdateWithWhereUniqueWithoutDestinosInput[]
    updateMany?: hospedajesUpdateManyWithWhereWithoutDestinosInput | hospedajesUpdateManyWithWhereWithoutDestinosInput[]
    deleteMany?: hospedajesScalarWhereInput | hospedajesScalarWhereInput[]
  }

  export type viajesUncheckedUpdateManyWithoutDestinosNestedInput = {
    create?: XOR<viajesCreateWithoutDestinosInput, viajesUncheckedCreateWithoutDestinosInput> | viajesCreateWithoutDestinosInput[] | viajesUncheckedCreateWithoutDestinosInput[]
    connectOrCreate?: viajesCreateOrConnectWithoutDestinosInput | viajesCreateOrConnectWithoutDestinosInput[]
    upsert?: viajesUpsertWithWhereUniqueWithoutDestinosInput | viajesUpsertWithWhereUniqueWithoutDestinosInput[]
    createMany?: viajesCreateManyDestinosInputEnvelope
    set?: viajesWhereUniqueInput | viajesWhereUniqueInput[]
    disconnect?: viajesWhereUniqueInput | viajesWhereUniqueInput[]
    delete?: viajesWhereUniqueInput | viajesWhereUniqueInput[]
    connect?: viajesWhereUniqueInput | viajesWhereUniqueInput[]
    update?: viajesUpdateWithWhereUniqueWithoutDestinosInput | viajesUpdateWithWhereUniqueWithoutDestinosInput[]
    updateMany?: viajesUpdateManyWithWhereWithoutDestinosInput | viajesUpdateManyWithWhereWithoutDestinosInput[]
    deleteMany?: viajesScalarWhereInput | viajesScalarWhereInput[]
  }

  export type destinosCreateNestedOneWithoutHospedajesInput = {
    create?: XOR<destinosCreateWithoutHospedajesInput, destinosUncheckedCreateWithoutHospedajesInput>
    connectOrCreate?: destinosCreateOrConnectWithoutHospedajesInput
    connect?: destinosWhereUniqueInput
  }

  export type paquetesCreateNestedManyWithoutHospedajesInput = {
    create?: XOR<paquetesCreateWithoutHospedajesInput, paquetesUncheckedCreateWithoutHospedajesInput> | paquetesCreateWithoutHospedajesInput[] | paquetesUncheckedCreateWithoutHospedajesInput[]
    connectOrCreate?: paquetesCreateOrConnectWithoutHospedajesInput | paquetesCreateOrConnectWithoutHospedajesInput[]
    createMany?: paquetesCreateManyHospedajesInputEnvelope
    connect?: paquetesWhereUniqueInput | paquetesWhereUniqueInput[]
  }

  export type viajesCreateNestedManyWithoutHospedajesInput = {
    create?: XOR<viajesCreateWithoutHospedajesInput, viajesUncheckedCreateWithoutHospedajesInput> | viajesCreateWithoutHospedajesInput[] | viajesUncheckedCreateWithoutHospedajesInput[]
    connectOrCreate?: viajesCreateOrConnectWithoutHospedajesInput | viajesCreateOrConnectWithoutHospedajesInput[]
    createMany?: viajesCreateManyHospedajesInputEnvelope
    connect?: viajesWhereUniqueInput | viajesWhereUniqueInput[]
  }

  export type paquetesUncheckedCreateNestedManyWithoutHospedajesInput = {
    create?: XOR<paquetesCreateWithoutHospedajesInput, paquetesUncheckedCreateWithoutHospedajesInput> | paquetesCreateWithoutHospedajesInput[] | paquetesUncheckedCreateWithoutHospedajesInput[]
    connectOrCreate?: paquetesCreateOrConnectWithoutHospedajesInput | paquetesCreateOrConnectWithoutHospedajesInput[]
    createMany?: paquetesCreateManyHospedajesInputEnvelope
    connect?: paquetesWhereUniqueInput | paquetesWhereUniqueInput[]
  }

  export type viajesUncheckedCreateNestedManyWithoutHospedajesInput = {
    create?: XOR<viajesCreateWithoutHospedajesInput, viajesUncheckedCreateWithoutHospedajesInput> | viajesCreateWithoutHospedajesInput[] | viajesUncheckedCreateWithoutHospedajesInput[]
    connectOrCreate?: viajesCreateOrConnectWithoutHospedajesInput | viajesCreateOrConnectWithoutHospedajesInput[]
    createMany?: viajesCreateManyHospedajesInputEnvelope
    connect?: viajesWhereUniqueInput | viajesWhereUniqueInput[]
  }

  export type destinosUpdateOneRequiredWithoutHospedajesNestedInput = {
    create?: XOR<destinosCreateWithoutHospedajesInput, destinosUncheckedCreateWithoutHospedajesInput>
    connectOrCreate?: destinosCreateOrConnectWithoutHospedajesInput
    upsert?: destinosUpsertWithoutHospedajesInput
    connect?: destinosWhereUniqueInput
    update?: XOR<XOR<destinosUpdateToOneWithWhereWithoutHospedajesInput, destinosUpdateWithoutHospedajesInput>, destinosUncheckedUpdateWithoutHospedajesInput>
  }

  export type paquetesUpdateManyWithoutHospedajesNestedInput = {
    create?: XOR<paquetesCreateWithoutHospedajesInput, paquetesUncheckedCreateWithoutHospedajesInput> | paquetesCreateWithoutHospedajesInput[] | paquetesUncheckedCreateWithoutHospedajesInput[]
    connectOrCreate?: paquetesCreateOrConnectWithoutHospedajesInput | paquetesCreateOrConnectWithoutHospedajesInput[]
    upsert?: paquetesUpsertWithWhereUniqueWithoutHospedajesInput | paquetesUpsertWithWhereUniqueWithoutHospedajesInput[]
    createMany?: paquetesCreateManyHospedajesInputEnvelope
    set?: paquetesWhereUniqueInput | paquetesWhereUniqueInput[]
    disconnect?: paquetesWhereUniqueInput | paquetesWhereUniqueInput[]
    delete?: paquetesWhereUniqueInput | paquetesWhereUniqueInput[]
    connect?: paquetesWhereUniqueInput | paquetesWhereUniqueInput[]
    update?: paquetesUpdateWithWhereUniqueWithoutHospedajesInput | paquetesUpdateWithWhereUniqueWithoutHospedajesInput[]
    updateMany?: paquetesUpdateManyWithWhereWithoutHospedajesInput | paquetesUpdateManyWithWhereWithoutHospedajesInput[]
    deleteMany?: paquetesScalarWhereInput | paquetesScalarWhereInput[]
  }

  export type viajesUpdateManyWithoutHospedajesNestedInput = {
    create?: XOR<viajesCreateWithoutHospedajesInput, viajesUncheckedCreateWithoutHospedajesInput> | viajesCreateWithoutHospedajesInput[] | viajesUncheckedCreateWithoutHospedajesInput[]
    connectOrCreate?: viajesCreateOrConnectWithoutHospedajesInput | viajesCreateOrConnectWithoutHospedajesInput[]
    upsert?: viajesUpsertWithWhereUniqueWithoutHospedajesInput | viajesUpsertWithWhereUniqueWithoutHospedajesInput[]
    createMany?: viajesCreateManyHospedajesInputEnvelope
    set?: viajesWhereUniqueInput | viajesWhereUniqueInput[]
    disconnect?: viajesWhereUniqueInput | viajesWhereUniqueInput[]
    delete?: viajesWhereUniqueInput | viajesWhereUniqueInput[]
    connect?: viajesWhereUniqueInput | viajesWhereUniqueInput[]
    update?: viajesUpdateWithWhereUniqueWithoutHospedajesInput | viajesUpdateWithWhereUniqueWithoutHospedajesInput[]
    updateMany?: viajesUpdateManyWithWhereWithoutHospedajesInput | viajesUpdateManyWithWhereWithoutHospedajesInput[]
    deleteMany?: viajesScalarWhereInput | viajesScalarWhereInput[]
  }

  export type paquetesUncheckedUpdateManyWithoutHospedajesNestedInput = {
    create?: XOR<paquetesCreateWithoutHospedajesInput, paquetesUncheckedCreateWithoutHospedajesInput> | paquetesCreateWithoutHospedajesInput[] | paquetesUncheckedCreateWithoutHospedajesInput[]
    connectOrCreate?: paquetesCreateOrConnectWithoutHospedajesInput | paquetesCreateOrConnectWithoutHospedajesInput[]
    upsert?: paquetesUpsertWithWhereUniqueWithoutHospedajesInput | paquetesUpsertWithWhereUniqueWithoutHospedajesInput[]
    createMany?: paquetesCreateManyHospedajesInputEnvelope
    set?: paquetesWhereUniqueInput | paquetesWhereUniqueInput[]
    disconnect?: paquetesWhereUniqueInput | paquetesWhereUniqueInput[]
    delete?: paquetesWhereUniqueInput | paquetesWhereUniqueInput[]
    connect?: paquetesWhereUniqueInput | paquetesWhereUniqueInput[]
    update?: paquetesUpdateWithWhereUniqueWithoutHospedajesInput | paquetesUpdateWithWhereUniqueWithoutHospedajesInput[]
    updateMany?: paquetesUpdateManyWithWhereWithoutHospedajesInput | paquetesUpdateManyWithWhereWithoutHospedajesInput[]
    deleteMany?: paquetesScalarWhereInput | paquetesScalarWhereInput[]
  }

  export type viajesUncheckedUpdateManyWithoutHospedajesNestedInput = {
    create?: XOR<viajesCreateWithoutHospedajesInput, viajesUncheckedCreateWithoutHospedajesInput> | viajesCreateWithoutHospedajesInput[] | viajesUncheckedCreateWithoutHospedajesInput[]
    connectOrCreate?: viajesCreateOrConnectWithoutHospedajesInput | viajesCreateOrConnectWithoutHospedajesInput[]
    upsert?: viajesUpsertWithWhereUniqueWithoutHospedajesInput | viajesUpsertWithWhereUniqueWithoutHospedajesInput[]
    createMany?: viajesCreateManyHospedajesInputEnvelope
    set?: viajesWhereUniqueInput | viajesWhereUniqueInput[]
    disconnect?: viajesWhereUniqueInput | viajesWhereUniqueInput[]
    delete?: viajesWhereUniqueInput | viajesWhereUniqueInput[]
    connect?: viajesWhereUniqueInput | viajesWhereUniqueInput[]
    update?: viajesUpdateWithWhereUniqueWithoutHospedajesInput | viajesUpdateWithWhereUniqueWithoutHospedajesInput[]
    updateMany?: viajesUpdateManyWithWhereWithoutHospedajesInput | viajesUpdateManyWithWhereWithoutHospedajesInput[]
    deleteMany?: viajesScalarWhereInput | viajesScalarWhereInput[]
  }

  export type usuariosCreateNestedOneWithoutReservasInput = {
    create?: XOR<usuariosCreateWithoutReservasInput, usuariosUncheckedCreateWithoutReservasInput>
    connectOrCreate?: usuariosCreateOrConnectWithoutReservasInput
    connect?: usuariosWhereUniqueInput
  }

  export type viajesCreateNestedOneWithoutReservasInput = {
    create?: XOR<viajesCreateWithoutReservasInput, viajesUncheckedCreateWithoutReservasInput>
    connectOrCreate?: viajesCreateOrConnectWithoutReservasInput
    connect?: viajesWhereUniqueInput
  }

  export type usuariosUpdateOneRequiredWithoutReservasNestedInput = {
    create?: XOR<usuariosCreateWithoutReservasInput, usuariosUncheckedCreateWithoutReservasInput>
    connectOrCreate?: usuariosCreateOrConnectWithoutReservasInput
    upsert?: usuariosUpsertWithoutReservasInput
    connect?: usuariosWhereUniqueInput
    update?: XOR<XOR<usuariosUpdateToOneWithWhereWithoutReservasInput, usuariosUpdateWithoutReservasInput>, usuariosUncheckedUpdateWithoutReservasInput>
  }

  export type viajesUpdateOneRequiredWithoutReservasNestedInput = {
    create?: XOR<viajesCreateWithoutReservasInput, viajesUncheckedCreateWithoutReservasInput>
    connectOrCreate?: viajesCreateOrConnectWithoutReservasInput
    upsert?: viajesUpsertWithoutReservasInput
    connect?: viajesWhereUniqueInput
    update?: XOR<XOR<viajesUpdateToOneWithWhereWithoutReservasInput, viajesUpdateWithoutReservasInput>, viajesUncheckedUpdateWithoutReservasInput>
  }

  export type reservasCreateNestedManyWithoutUsuariosInput = {
    create?: XOR<reservasCreateWithoutUsuariosInput, reservasUncheckedCreateWithoutUsuariosInput> | reservasCreateWithoutUsuariosInput[] | reservasUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: reservasCreateOrConnectWithoutUsuariosInput | reservasCreateOrConnectWithoutUsuariosInput[]
    createMany?: reservasCreateManyUsuariosInputEnvelope
    connect?: reservasWhereUniqueInput | reservasWhereUniqueInput[]
  }

  export type rolesCreateNestedOneWithoutUsuariosInput = {
    create?: XOR<rolesCreateWithoutUsuariosInput, rolesUncheckedCreateWithoutUsuariosInput>
    connectOrCreate?: rolesCreateOrConnectWithoutUsuariosInput
    connect?: rolesWhereUniqueInput
  }

  export type reservasUncheckedCreateNestedManyWithoutUsuariosInput = {
    create?: XOR<reservasCreateWithoutUsuariosInput, reservasUncheckedCreateWithoutUsuariosInput> | reservasCreateWithoutUsuariosInput[] | reservasUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: reservasCreateOrConnectWithoutUsuariosInput | reservasCreateOrConnectWithoutUsuariosInput[]
    createMany?: reservasCreateManyUsuariosInputEnvelope
    connect?: reservasWhereUniqueInput | reservasWhereUniqueInput[]
  }

  export type reservasUpdateManyWithoutUsuariosNestedInput = {
    create?: XOR<reservasCreateWithoutUsuariosInput, reservasUncheckedCreateWithoutUsuariosInput> | reservasCreateWithoutUsuariosInput[] | reservasUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: reservasCreateOrConnectWithoutUsuariosInput | reservasCreateOrConnectWithoutUsuariosInput[]
    upsert?: reservasUpsertWithWhereUniqueWithoutUsuariosInput | reservasUpsertWithWhereUniqueWithoutUsuariosInput[]
    createMany?: reservasCreateManyUsuariosInputEnvelope
    set?: reservasWhereUniqueInput | reservasWhereUniqueInput[]
    disconnect?: reservasWhereUniqueInput | reservasWhereUniqueInput[]
    delete?: reservasWhereUniqueInput | reservasWhereUniqueInput[]
    connect?: reservasWhereUniqueInput | reservasWhereUniqueInput[]
    update?: reservasUpdateWithWhereUniqueWithoutUsuariosInput | reservasUpdateWithWhereUniqueWithoutUsuariosInput[]
    updateMany?: reservasUpdateManyWithWhereWithoutUsuariosInput | reservasUpdateManyWithWhereWithoutUsuariosInput[]
    deleteMany?: reservasScalarWhereInput | reservasScalarWhereInput[]
  }

  export type rolesUpdateOneRequiredWithoutUsuariosNestedInput = {
    create?: XOR<rolesCreateWithoutUsuariosInput, rolesUncheckedCreateWithoutUsuariosInput>
    connectOrCreate?: rolesCreateOrConnectWithoutUsuariosInput
    upsert?: rolesUpsertWithoutUsuariosInput
    connect?: rolesWhereUniqueInput
    update?: XOR<XOR<rolesUpdateToOneWithWhereWithoutUsuariosInput, rolesUpdateWithoutUsuariosInput>, rolesUncheckedUpdateWithoutUsuariosInput>
  }

  export type reservasUncheckedUpdateManyWithoutUsuariosNestedInput = {
    create?: XOR<reservasCreateWithoutUsuariosInput, reservasUncheckedCreateWithoutUsuariosInput> | reservasCreateWithoutUsuariosInput[] | reservasUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: reservasCreateOrConnectWithoutUsuariosInput | reservasCreateOrConnectWithoutUsuariosInput[]
    upsert?: reservasUpsertWithWhereUniqueWithoutUsuariosInput | reservasUpsertWithWhereUniqueWithoutUsuariosInput[]
    createMany?: reservasCreateManyUsuariosInputEnvelope
    set?: reservasWhereUniqueInput | reservasWhereUniqueInput[]
    disconnect?: reservasWhereUniqueInput | reservasWhereUniqueInput[]
    delete?: reservasWhereUniqueInput | reservasWhereUniqueInput[]
    connect?: reservasWhereUniqueInput | reservasWhereUniqueInput[]
    update?: reservasUpdateWithWhereUniqueWithoutUsuariosInput | reservasUpdateWithWhereUniqueWithoutUsuariosInput[]
    updateMany?: reservasUpdateManyWithWhereWithoutUsuariosInput | reservasUpdateManyWithWhereWithoutUsuariosInput[]
    deleteMany?: reservasScalarWhereInput | reservasScalarWhereInput[]
  }

  export type itinerariosCreateNestedManyWithoutViajesInput = {
    create?: XOR<itinerariosCreateWithoutViajesInput, itinerariosUncheckedCreateWithoutViajesInput> | itinerariosCreateWithoutViajesInput[] | itinerariosUncheckedCreateWithoutViajesInput[]
    connectOrCreate?: itinerariosCreateOrConnectWithoutViajesInput | itinerariosCreateOrConnectWithoutViajesInput[]
    createMany?: itinerariosCreateManyViajesInputEnvelope
    connect?: itinerariosWhereUniqueInput | itinerariosWhereUniqueInput[]
  }

  export type reservasCreateNestedManyWithoutViajesInput = {
    create?: XOR<reservasCreateWithoutViajesInput, reservasUncheckedCreateWithoutViajesInput> | reservasCreateWithoutViajesInput[] | reservasUncheckedCreateWithoutViajesInput[]
    connectOrCreate?: reservasCreateOrConnectWithoutViajesInput | reservasCreateOrConnectWithoutViajesInput[]
    createMany?: reservasCreateManyViajesInputEnvelope
    connect?: reservasWhereUniqueInput | reservasWhereUniqueInput[]
  }

  export type categoriasCreateNestedOneWithoutViajesInput = {
    create?: XOR<categoriasCreateWithoutViajesInput, categoriasUncheckedCreateWithoutViajesInput>
    connectOrCreate?: categoriasCreateOrConnectWithoutViajesInput
    connect?: categoriasWhereUniqueInput
  }

  export type destinosCreateNestedOneWithoutViajesInput = {
    create?: XOR<destinosCreateWithoutViajesInput, destinosUncheckedCreateWithoutViajesInput>
    connectOrCreate?: destinosCreateOrConnectWithoutViajesInput
    connect?: destinosWhereUniqueInput
  }

  export type hospedajesCreateNestedOneWithoutViajesInput = {
    create?: XOR<hospedajesCreateWithoutViajesInput, hospedajesUncheckedCreateWithoutViajesInput>
    connectOrCreate?: hospedajesCreateOrConnectWithoutViajesInput
    connect?: hospedajesWhereUniqueInput
  }

  export type paquetesCreateNestedOneWithoutViajesInput = {
    create?: XOR<paquetesCreateWithoutViajesInput, paquetesUncheckedCreateWithoutViajesInput>
    connectOrCreate?: paquetesCreateOrConnectWithoutViajesInput
    connect?: paquetesWhereUniqueInput
  }

  export type itinerariosUncheckedCreateNestedManyWithoutViajesInput = {
    create?: XOR<itinerariosCreateWithoutViajesInput, itinerariosUncheckedCreateWithoutViajesInput> | itinerariosCreateWithoutViajesInput[] | itinerariosUncheckedCreateWithoutViajesInput[]
    connectOrCreate?: itinerariosCreateOrConnectWithoutViajesInput | itinerariosCreateOrConnectWithoutViajesInput[]
    createMany?: itinerariosCreateManyViajesInputEnvelope
    connect?: itinerariosWhereUniqueInput | itinerariosWhereUniqueInput[]
  }

  export type reservasUncheckedCreateNestedManyWithoutViajesInput = {
    create?: XOR<reservasCreateWithoutViajesInput, reservasUncheckedCreateWithoutViajesInput> | reservasCreateWithoutViajesInput[] | reservasUncheckedCreateWithoutViajesInput[]
    connectOrCreate?: reservasCreateOrConnectWithoutViajesInput | reservasCreateOrConnectWithoutViajesInput[]
    createMany?: reservasCreateManyViajesInputEnvelope
    connect?: reservasWhereUniqueInput | reservasWhereUniqueInput[]
  }

  export type itinerariosUpdateManyWithoutViajesNestedInput = {
    create?: XOR<itinerariosCreateWithoutViajesInput, itinerariosUncheckedCreateWithoutViajesInput> | itinerariosCreateWithoutViajesInput[] | itinerariosUncheckedCreateWithoutViajesInput[]
    connectOrCreate?: itinerariosCreateOrConnectWithoutViajesInput | itinerariosCreateOrConnectWithoutViajesInput[]
    upsert?: itinerariosUpsertWithWhereUniqueWithoutViajesInput | itinerariosUpsertWithWhereUniqueWithoutViajesInput[]
    createMany?: itinerariosCreateManyViajesInputEnvelope
    set?: itinerariosWhereUniqueInput | itinerariosWhereUniqueInput[]
    disconnect?: itinerariosWhereUniqueInput | itinerariosWhereUniqueInput[]
    delete?: itinerariosWhereUniqueInput | itinerariosWhereUniqueInput[]
    connect?: itinerariosWhereUniqueInput | itinerariosWhereUniqueInput[]
    update?: itinerariosUpdateWithWhereUniqueWithoutViajesInput | itinerariosUpdateWithWhereUniqueWithoutViajesInput[]
    updateMany?: itinerariosUpdateManyWithWhereWithoutViajesInput | itinerariosUpdateManyWithWhereWithoutViajesInput[]
    deleteMany?: itinerariosScalarWhereInput | itinerariosScalarWhereInput[]
  }

  export type reservasUpdateManyWithoutViajesNestedInput = {
    create?: XOR<reservasCreateWithoutViajesInput, reservasUncheckedCreateWithoutViajesInput> | reservasCreateWithoutViajesInput[] | reservasUncheckedCreateWithoutViajesInput[]
    connectOrCreate?: reservasCreateOrConnectWithoutViajesInput | reservasCreateOrConnectWithoutViajesInput[]
    upsert?: reservasUpsertWithWhereUniqueWithoutViajesInput | reservasUpsertWithWhereUniqueWithoutViajesInput[]
    createMany?: reservasCreateManyViajesInputEnvelope
    set?: reservasWhereUniqueInput | reservasWhereUniqueInput[]
    disconnect?: reservasWhereUniqueInput | reservasWhereUniqueInput[]
    delete?: reservasWhereUniqueInput | reservasWhereUniqueInput[]
    connect?: reservasWhereUniqueInput | reservasWhereUniqueInput[]
    update?: reservasUpdateWithWhereUniqueWithoutViajesInput | reservasUpdateWithWhereUniqueWithoutViajesInput[]
    updateMany?: reservasUpdateManyWithWhereWithoutViajesInput | reservasUpdateManyWithWhereWithoutViajesInput[]
    deleteMany?: reservasScalarWhereInput | reservasScalarWhereInput[]
  }

  export type categoriasUpdateOneRequiredWithoutViajesNestedInput = {
    create?: XOR<categoriasCreateWithoutViajesInput, categoriasUncheckedCreateWithoutViajesInput>
    connectOrCreate?: categoriasCreateOrConnectWithoutViajesInput
    upsert?: categoriasUpsertWithoutViajesInput
    connect?: categoriasWhereUniqueInput
    update?: XOR<XOR<categoriasUpdateToOneWithWhereWithoutViajesInput, categoriasUpdateWithoutViajesInput>, categoriasUncheckedUpdateWithoutViajesInput>
  }

  export type destinosUpdateOneRequiredWithoutViajesNestedInput = {
    create?: XOR<destinosCreateWithoutViajesInput, destinosUncheckedCreateWithoutViajesInput>
    connectOrCreate?: destinosCreateOrConnectWithoutViajesInput
    upsert?: destinosUpsertWithoutViajesInput
    connect?: destinosWhereUniqueInput
    update?: XOR<XOR<destinosUpdateToOneWithWhereWithoutViajesInput, destinosUpdateWithoutViajesInput>, destinosUncheckedUpdateWithoutViajesInput>
  }

  export type hospedajesUpdateOneRequiredWithoutViajesNestedInput = {
    create?: XOR<hospedajesCreateWithoutViajesInput, hospedajesUncheckedCreateWithoutViajesInput>
    connectOrCreate?: hospedajesCreateOrConnectWithoutViajesInput
    upsert?: hospedajesUpsertWithoutViajesInput
    connect?: hospedajesWhereUniqueInput
    update?: XOR<XOR<hospedajesUpdateToOneWithWhereWithoutViajesInput, hospedajesUpdateWithoutViajesInput>, hospedajesUncheckedUpdateWithoutViajesInput>
  }

  export type paquetesUpdateOneRequiredWithoutViajesNestedInput = {
    create?: XOR<paquetesCreateWithoutViajesInput, paquetesUncheckedCreateWithoutViajesInput>
    connectOrCreate?: paquetesCreateOrConnectWithoutViajesInput
    upsert?: paquetesUpsertWithoutViajesInput
    connect?: paquetesWhereUniqueInput
    update?: XOR<XOR<paquetesUpdateToOneWithWhereWithoutViajesInput, paquetesUpdateWithoutViajesInput>, paquetesUncheckedUpdateWithoutViajesInput>
  }

  export type itinerariosUncheckedUpdateManyWithoutViajesNestedInput = {
    create?: XOR<itinerariosCreateWithoutViajesInput, itinerariosUncheckedCreateWithoutViajesInput> | itinerariosCreateWithoutViajesInput[] | itinerariosUncheckedCreateWithoutViajesInput[]
    connectOrCreate?: itinerariosCreateOrConnectWithoutViajesInput | itinerariosCreateOrConnectWithoutViajesInput[]
    upsert?: itinerariosUpsertWithWhereUniqueWithoutViajesInput | itinerariosUpsertWithWhereUniqueWithoutViajesInput[]
    createMany?: itinerariosCreateManyViajesInputEnvelope
    set?: itinerariosWhereUniqueInput | itinerariosWhereUniqueInput[]
    disconnect?: itinerariosWhereUniqueInput | itinerariosWhereUniqueInput[]
    delete?: itinerariosWhereUniqueInput | itinerariosWhereUniqueInput[]
    connect?: itinerariosWhereUniqueInput | itinerariosWhereUniqueInput[]
    update?: itinerariosUpdateWithWhereUniqueWithoutViajesInput | itinerariosUpdateWithWhereUniqueWithoutViajesInput[]
    updateMany?: itinerariosUpdateManyWithWhereWithoutViajesInput | itinerariosUpdateManyWithWhereWithoutViajesInput[]
    deleteMany?: itinerariosScalarWhereInput | itinerariosScalarWhereInput[]
  }

  export type reservasUncheckedUpdateManyWithoutViajesNestedInput = {
    create?: XOR<reservasCreateWithoutViajesInput, reservasUncheckedCreateWithoutViajesInput> | reservasCreateWithoutViajesInput[] | reservasUncheckedCreateWithoutViajesInput[]
    connectOrCreate?: reservasCreateOrConnectWithoutViajesInput | reservasCreateOrConnectWithoutViajesInput[]
    upsert?: reservasUpsertWithWhereUniqueWithoutViajesInput | reservasUpsertWithWhereUniqueWithoutViajesInput[]
    createMany?: reservasCreateManyViajesInputEnvelope
    set?: reservasWhereUniqueInput | reservasWhereUniqueInput[]
    disconnect?: reservasWhereUniqueInput | reservasWhereUniqueInput[]
    delete?: reservasWhereUniqueInput | reservasWhereUniqueInput[]
    connect?: reservasWhereUniqueInput | reservasWhereUniqueInput[]
    update?: reservasUpdateWithWhereUniqueWithoutViajesInput | reservasUpdateWithWhereUniqueWithoutViajesInput[]
    updateMany?: reservasUpdateManyWithWhereWithoutViajesInput | reservasUpdateManyWithWhereWithoutViajesInput[]
    deleteMany?: reservasScalarWhereInput | reservasScalarWhereInput[]
  }

  export type viajesCreateNestedOneWithoutItinerariosInput = {
    create?: XOR<viajesCreateWithoutItinerariosInput, viajesUncheckedCreateWithoutItinerariosInput>
    connectOrCreate?: viajesCreateOrConnectWithoutItinerariosInput
    connect?: viajesWhereUniqueInput
  }

  export type viajesUpdateOneRequiredWithoutItinerariosNestedInput = {
    create?: XOR<viajesCreateWithoutItinerariosInput, viajesUncheckedCreateWithoutItinerariosInput>
    connectOrCreate?: viajesCreateOrConnectWithoutItinerariosInput
    upsert?: viajesUpsertWithoutItinerariosInput
    connect?: viajesWhereUniqueInput
    update?: XOR<XOR<viajesUpdateToOneWithWhereWithoutItinerariosInput, viajesUpdateWithoutItinerariosInput>, viajesUncheckedUpdateWithoutItinerariosInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type paquetesCreateWithoutCategoriasInput = {
    nombre: string
    transporte: string
    precio: Decimal | DecimalJsLike | number | string
    estado_auditoria?: string
    fecha_modificacion?: Date | string
    fecha_creacion?: Date | string | null
    hospedajes: hospedajesCreateNestedOneWithoutPaquetesInput
    viajes?: viajesCreateNestedManyWithoutPaquetesInput
  }

  export type paquetesUncheckedCreateWithoutCategoriasInput = {
    id_paquete?: number
    id_hospedaje: number
    nombre: string
    transporte: string
    precio: Decimal | DecimalJsLike | number | string
    estado_auditoria?: string
    fecha_modificacion?: Date | string
    fecha_creacion?: Date | string | null
    viajes?: viajesUncheckedCreateNestedManyWithoutPaquetesInput
  }

  export type paquetesCreateOrConnectWithoutCategoriasInput = {
    where: paquetesWhereUniqueInput
    create: XOR<paquetesCreateWithoutCategoriasInput, paquetesUncheckedCreateWithoutCategoriasInput>
  }

  export type paquetesCreateManyCategoriasInputEnvelope = {
    data: paquetesCreateManyCategoriasInput | paquetesCreateManyCategoriasInput[]
    skipDuplicates?: boolean
  }

  export type viajesCreateWithoutCategoriasInput = {
    fecha_inicio?: Date | string | null
    fecha_fin?: Date | string | null
    tarifa: Decimal | DecimalJsLike | number | string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
    itinerarios?: itinerariosCreateNestedManyWithoutViajesInput
    reservas?: reservasCreateNestedManyWithoutViajesInput
    destinos: destinosCreateNestedOneWithoutViajesInput
    hospedajes: hospedajesCreateNestedOneWithoutViajesInput
    paquetes: paquetesCreateNestedOneWithoutViajesInput
  }

  export type viajesUncheckedCreateWithoutCategoriasInput = {
    id_viaje?: number
    id_destino: number
    id_hospedaje: number
    id_paquete: number
    fecha_inicio?: Date | string | null
    fecha_fin?: Date | string | null
    tarifa: Decimal | DecimalJsLike | number | string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
    itinerarios?: itinerariosUncheckedCreateNestedManyWithoutViajesInput
    reservas?: reservasUncheckedCreateNestedManyWithoutViajesInput
  }

  export type viajesCreateOrConnectWithoutCategoriasInput = {
    where: viajesWhereUniqueInput
    create: XOR<viajesCreateWithoutCategoriasInput, viajesUncheckedCreateWithoutCategoriasInput>
  }

  export type viajesCreateManyCategoriasInputEnvelope = {
    data: viajesCreateManyCategoriasInput | viajesCreateManyCategoriasInput[]
    skipDuplicates?: boolean
  }

  export type paquetesUpsertWithWhereUniqueWithoutCategoriasInput = {
    where: paquetesWhereUniqueInput
    update: XOR<paquetesUpdateWithoutCategoriasInput, paquetesUncheckedUpdateWithoutCategoriasInput>
    create: XOR<paquetesCreateWithoutCategoriasInput, paquetesUncheckedCreateWithoutCategoriasInput>
  }

  export type paquetesUpdateWithWhereUniqueWithoutCategoriasInput = {
    where: paquetesWhereUniqueInput
    data: XOR<paquetesUpdateWithoutCategoriasInput, paquetesUncheckedUpdateWithoutCategoriasInput>
  }

  export type paquetesUpdateManyWithWhereWithoutCategoriasInput = {
    where: paquetesScalarWhereInput
    data: XOR<paquetesUpdateManyMutationInput, paquetesUncheckedUpdateManyWithoutCategoriasInput>
  }

  export type paquetesScalarWhereInput = {
    AND?: paquetesScalarWhereInput | paquetesScalarWhereInput[]
    OR?: paquetesScalarWhereInput[]
    NOT?: paquetesScalarWhereInput | paquetesScalarWhereInput[]
    id_paquete?: IntFilter<"paquetes"> | number
    id_hospedaje?: IntFilter<"paquetes"> | number
    id_categoria?: IntFilter<"paquetes"> | number
    nombre?: StringFilter<"paquetes"> | string
    transporte?: StringFilter<"paquetes"> | string
    precio?: DecimalFilter<"paquetes"> | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFilter<"paquetes"> | string
    fecha_modificacion?: DateTimeFilter<"paquetes"> | Date | string
    fecha_creacion?: DateTimeNullableFilter<"paquetes"> | Date | string | null
  }

  export type viajesUpsertWithWhereUniqueWithoutCategoriasInput = {
    where: viajesWhereUniqueInput
    update: XOR<viajesUpdateWithoutCategoriasInput, viajesUncheckedUpdateWithoutCategoriasInput>
    create: XOR<viajesCreateWithoutCategoriasInput, viajesUncheckedCreateWithoutCategoriasInput>
  }

  export type viajesUpdateWithWhereUniqueWithoutCategoriasInput = {
    where: viajesWhereUniqueInput
    data: XOR<viajesUpdateWithoutCategoriasInput, viajesUncheckedUpdateWithoutCategoriasInput>
  }

  export type viajesUpdateManyWithWhereWithoutCategoriasInput = {
    where: viajesScalarWhereInput
    data: XOR<viajesUpdateManyMutationInput, viajesUncheckedUpdateManyWithoutCategoriasInput>
  }

  export type viajesScalarWhereInput = {
    AND?: viajesScalarWhereInput | viajesScalarWhereInput[]
    OR?: viajesScalarWhereInput[]
    NOT?: viajesScalarWhereInput | viajesScalarWhereInput[]
    id_viaje?: IntFilter<"viajes"> | number
    id_destino?: IntFilter<"viajes"> | number
    id_categoria?: IntFilter<"viajes"> | number
    id_hospedaje?: IntFilter<"viajes"> | number
    id_paquete?: IntFilter<"viajes"> | number
    fecha_inicio?: DateTimeNullableFilter<"viajes"> | Date | string | null
    fecha_fin?: DateTimeNullableFilter<"viajes"> | Date | string | null
    tarifa?: DecimalFilter<"viajes"> | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFilter<"viajes"> | string
    fecha_creacion?: DateTimeFilter<"viajes"> | Date | string
    fecha_modificacion?: DateTimeNullableFilter<"viajes"> | Date | string | null
  }

  export type destinosCreateWithoutPaisesInput = {
    nombre: string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
    hospedajes?: hospedajesCreateNestedManyWithoutDestinosInput
    viajes?: viajesCreateNestedManyWithoutDestinosInput
  }

  export type destinosUncheckedCreateWithoutPaisesInput = {
    id_destino?: number
    nombre: string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
    hospedajes?: hospedajesUncheckedCreateNestedManyWithoutDestinosInput
    viajes?: viajesUncheckedCreateNestedManyWithoutDestinosInput
  }

  export type destinosCreateOrConnectWithoutPaisesInput = {
    where: destinosWhereUniqueInput
    create: XOR<destinosCreateWithoutPaisesInput, destinosUncheckedCreateWithoutPaisesInput>
  }

  export type destinosCreateManyPaisesInputEnvelope = {
    data: destinosCreateManyPaisesInput | destinosCreateManyPaisesInput[]
    skipDuplicates?: boolean
  }

  export type destinosUpsertWithWhereUniqueWithoutPaisesInput = {
    where: destinosWhereUniqueInput
    update: XOR<destinosUpdateWithoutPaisesInput, destinosUncheckedUpdateWithoutPaisesInput>
    create: XOR<destinosCreateWithoutPaisesInput, destinosUncheckedCreateWithoutPaisesInput>
  }

  export type destinosUpdateWithWhereUniqueWithoutPaisesInput = {
    where: destinosWhereUniqueInput
    data: XOR<destinosUpdateWithoutPaisesInput, destinosUncheckedUpdateWithoutPaisesInput>
  }

  export type destinosUpdateManyWithWhereWithoutPaisesInput = {
    where: destinosScalarWhereInput
    data: XOR<destinosUpdateManyMutationInput, destinosUncheckedUpdateManyWithoutPaisesInput>
  }

  export type destinosScalarWhereInput = {
    AND?: destinosScalarWhereInput | destinosScalarWhereInput[]
    OR?: destinosScalarWhereInput[]
    NOT?: destinosScalarWhereInput | destinosScalarWhereInput[]
    id_destino?: IntFilter<"destinos"> | number
    id_pais?: IntFilter<"destinos"> | number
    nombre?: StringFilter<"destinos"> | string
    estado_auditoria?: StringFilter<"destinos"> | string
    fecha_creacion?: DateTimeFilter<"destinos"> | Date | string
    fecha_modificacion?: DateTimeNullableFilter<"destinos"> | Date | string | null
  }

  export type categoriasCreateWithoutPaquetesInput = {
    nombre: string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
    viajes?: viajesCreateNestedManyWithoutCategoriasInput
  }

  export type categoriasUncheckedCreateWithoutPaquetesInput = {
    id_categoria?: number
    nombre: string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
    viajes?: viajesUncheckedCreateNestedManyWithoutCategoriasInput
  }

  export type categoriasCreateOrConnectWithoutPaquetesInput = {
    where: categoriasWhereUniqueInput
    create: XOR<categoriasCreateWithoutPaquetesInput, categoriasUncheckedCreateWithoutPaquetesInput>
  }

  export type hospedajesCreateWithoutPaquetesInput = {
    nombre: string
    precio: Decimal | DecimalJsLike | number | string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
    destinos: destinosCreateNestedOneWithoutHospedajesInput
    viajes?: viajesCreateNestedManyWithoutHospedajesInput
  }

  export type hospedajesUncheckedCreateWithoutPaquetesInput = {
    id_hospedaje?: number
    id_destino: number
    nombre: string
    precio: Decimal | DecimalJsLike | number | string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
    viajes?: viajesUncheckedCreateNestedManyWithoutHospedajesInput
  }

  export type hospedajesCreateOrConnectWithoutPaquetesInput = {
    where: hospedajesWhereUniqueInput
    create: XOR<hospedajesCreateWithoutPaquetesInput, hospedajesUncheckedCreateWithoutPaquetesInput>
  }

  export type viajesCreateWithoutPaquetesInput = {
    fecha_inicio?: Date | string | null
    fecha_fin?: Date | string | null
    tarifa: Decimal | DecimalJsLike | number | string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
    itinerarios?: itinerariosCreateNestedManyWithoutViajesInput
    reservas?: reservasCreateNestedManyWithoutViajesInput
    categorias: categoriasCreateNestedOneWithoutViajesInput
    destinos: destinosCreateNestedOneWithoutViajesInput
    hospedajes: hospedajesCreateNestedOneWithoutViajesInput
  }

  export type viajesUncheckedCreateWithoutPaquetesInput = {
    id_viaje?: number
    id_destino: number
    id_categoria: number
    id_hospedaje: number
    fecha_inicio?: Date | string | null
    fecha_fin?: Date | string | null
    tarifa: Decimal | DecimalJsLike | number | string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
    itinerarios?: itinerariosUncheckedCreateNestedManyWithoutViajesInput
    reservas?: reservasUncheckedCreateNestedManyWithoutViajesInput
  }

  export type viajesCreateOrConnectWithoutPaquetesInput = {
    where: viajesWhereUniqueInput
    create: XOR<viajesCreateWithoutPaquetesInput, viajesUncheckedCreateWithoutPaquetesInput>
  }

  export type viajesCreateManyPaquetesInputEnvelope = {
    data: viajesCreateManyPaquetesInput | viajesCreateManyPaquetesInput[]
    skipDuplicates?: boolean
  }

  export type categoriasUpsertWithoutPaquetesInput = {
    update: XOR<categoriasUpdateWithoutPaquetesInput, categoriasUncheckedUpdateWithoutPaquetesInput>
    create: XOR<categoriasCreateWithoutPaquetesInput, categoriasUncheckedCreateWithoutPaquetesInput>
    where?: categoriasWhereInput
  }

  export type categoriasUpdateToOneWithWhereWithoutPaquetesInput = {
    where?: categoriasWhereInput
    data: XOR<categoriasUpdateWithoutPaquetesInput, categoriasUncheckedUpdateWithoutPaquetesInput>
  }

  export type categoriasUpdateWithoutPaquetesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viajes?: viajesUpdateManyWithoutCategoriasNestedInput
  }

  export type categoriasUncheckedUpdateWithoutPaquetesInput = {
    id_categoria?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viajes?: viajesUncheckedUpdateManyWithoutCategoriasNestedInput
  }

  export type hospedajesUpsertWithoutPaquetesInput = {
    update: XOR<hospedajesUpdateWithoutPaquetesInput, hospedajesUncheckedUpdateWithoutPaquetesInput>
    create: XOR<hospedajesCreateWithoutPaquetesInput, hospedajesUncheckedCreateWithoutPaquetesInput>
    where?: hospedajesWhereInput
  }

  export type hospedajesUpdateToOneWithWhereWithoutPaquetesInput = {
    where?: hospedajesWhereInput
    data: XOR<hospedajesUpdateWithoutPaquetesInput, hospedajesUncheckedUpdateWithoutPaquetesInput>
  }

  export type hospedajesUpdateWithoutPaquetesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    destinos?: destinosUpdateOneRequiredWithoutHospedajesNestedInput
    viajes?: viajesUpdateManyWithoutHospedajesNestedInput
  }

  export type hospedajesUncheckedUpdateWithoutPaquetesInput = {
    id_hospedaje?: IntFieldUpdateOperationsInput | number
    id_destino?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viajes?: viajesUncheckedUpdateManyWithoutHospedajesNestedInput
  }

  export type viajesUpsertWithWhereUniqueWithoutPaquetesInput = {
    where: viajesWhereUniqueInput
    update: XOR<viajesUpdateWithoutPaquetesInput, viajesUncheckedUpdateWithoutPaquetesInput>
    create: XOR<viajesCreateWithoutPaquetesInput, viajesUncheckedCreateWithoutPaquetesInput>
  }

  export type viajesUpdateWithWhereUniqueWithoutPaquetesInput = {
    where: viajesWhereUniqueInput
    data: XOR<viajesUpdateWithoutPaquetesInput, viajesUncheckedUpdateWithoutPaquetesInput>
  }

  export type viajesUpdateManyWithWhereWithoutPaquetesInput = {
    where: viajesScalarWhereInput
    data: XOR<viajesUpdateManyMutationInput, viajesUncheckedUpdateManyWithoutPaquetesInput>
  }

  export type usuariosCreateWithoutRolesInput = {
    nombres: string
    apellido_paterno: string
    apellido_materno: string
    username: string
    email: string
    clave: string
    telefono: string
    direccion: string
    sexo: string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
    reservas?: reservasCreateNestedManyWithoutUsuariosInput
  }

  export type usuariosUncheckedCreateWithoutRolesInput = {
    id_usuario?: number
    nombres: string
    apellido_paterno: string
    apellido_materno: string
    username: string
    email: string
    clave: string
    telefono: string
    direccion: string
    sexo: string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
    reservas?: reservasUncheckedCreateNestedManyWithoutUsuariosInput
  }

  export type usuariosCreateOrConnectWithoutRolesInput = {
    where: usuariosWhereUniqueInput
    create: XOR<usuariosCreateWithoutRolesInput, usuariosUncheckedCreateWithoutRolesInput>
  }

  export type usuariosCreateManyRolesInputEnvelope = {
    data: usuariosCreateManyRolesInput | usuariosCreateManyRolesInput[]
    skipDuplicates?: boolean
  }

  export type usuariosUpsertWithWhereUniqueWithoutRolesInput = {
    where: usuariosWhereUniqueInput
    update: XOR<usuariosUpdateWithoutRolesInput, usuariosUncheckedUpdateWithoutRolesInput>
    create: XOR<usuariosCreateWithoutRolesInput, usuariosUncheckedCreateWithoutRolesInput>
  }

  export type usuariosUpdateWithWhereUniqueWithoutRolesInput = {
    where: usuariosWhereUniqueInput
    data: XOR<usuariosUpdateWithoutRolesInput, usuariosUncheckedUpdateWithoutRolesInput>
  }

  export type usuariosUpdateManyWithWhereWithoutRolesInput = {
    where: usuariosScalarWhereInput
    data: XOR<usuariosUpdateManyMutationInput, usuariosUncheckedUpdateManyWithoutRolesInput>
  }

  export type usuariosScalarWhereInput = {
    AND?: usuariosScalarWhereInput | usuariosScalarWhereInput[]
    OR?: usuariosScalarWhereInput[]
    NOT?: usuariosScalarWhereInput | usuariosScalarWhereInput[]
    id_usuario?: IntFilter<"usuarios"> | number
    id_rol?: IntFilter<"usuarios"> | number
    nombres?: StringFilter<"usuarios"> | string
    apellido_paterno?: StringFilter<"usuarios"> | string
    apellido_materno?: StringFilter<"usuarios"> | string
    username?: StringFilter<"usuarios"> | string
    email?: StringFilter<"usuarios"> | string
    clave?: StringFilter<"usuarios"> | string
    telefono?: StringFilter<"usuarios"> | string
    direccion?: StringFilter<"usuarios"> | string
    sexo?: StringFilter<"usuarios"> | string
    estado_auditoria?: StringFilter<"usuarios"> | string
    fecha_creacion?: DateTimeFilter<"usuarios"> | Date | string
    fecha_modificacion?: DateTimeNullableFilter<"usuarios"> | Date | string | null
  }

  export type paisesCreateWithoutDestinosInput = {
    nombre: string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
  }

  export type paisesUncheckedCreateWithoutDestinosInput = {
    id_pais?: number
    nombre: string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
  }

  export type paisesCreateOrConnectWithoutDestinosInput = {
    where: paisesWhereUniqueInput
    create: XOR<paisesCreateWithoutDestinosInput, paisesUncheckedCreateWithoutDestinosInput>
  }

  export type hospedajesCreateWithoutDestinosInput = {
    nombre: string
    precio: Decimal | DecimalJsLike | number | string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
    paquetes?: paquetesCreateNestedManyWithoutHospedajesInput
    viajes?: viajesCreateNestedManyWithoutHospedajesInput
  }

  export type hospedajesUncheckedCreateWithoutDestinosInput = {
    id_hospedaje?: number
    nombre: string
    precio: Decimal | DecimalJsLike | number | string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
    paquetes?: paquetesUncheckedCreateNestedManyWithoutHospedajesInput
    viajes?: viajesUncheckedCreateNestedManyWithoutHospedajesInput
  }

  export type hospedajesCreateOrConnectWithoutDestinosInput = {
    where: hospedajesWhereUniqueInput
    create: XOR<hospedajesCreateWithoutDestinosInput, hospedajesUncheckedCreateWithoutDestinosInput>
  }

  export type hospedajesCreateManyDestinosInputEnvelope = {
    data: hospedajesCreateManyDestinosInput | hospedajesCreateManyDestinosInput[]
    skipDuplicates?: boolean
  }

  export type viajesCreateWithoutDestinosInput = {
    fecha_inicio?: Date | string | null
    fecha_fin?: Date | string | null
    tarifa: Decimal | DecimalJsLike | number | string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
    itinerarios?: itinerariosCreateNestedManyWithoutViajesInput
    reservas?: reservasCreateNestedManyWithoutViajesInput
    categorias: categoriasCreateNestedOneWithoutViajesInput
    hospedajes: hospedajesCreateNestedOneWithoutViajesInput
    paquetes: paquetesCreateNestedOneWithoutViajesInput
  }

  export type viajesUncheckedCreateWithoutDestinosInput = {
    id_viaje?: number
    id_categoria: number
    id_hospedaje: number
    id_paquete: number
    fecha_inicio?: Date | string | null
    fecha_fin?: Date | string | null
    tarifa: Decimal | DecimalJsLike | number | string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
    itinerarios?: itinerariosUncheckedCreateNestedManyWithoutViajesInput
    reservas?: reservasUncheckedCreateNestedManyWithoutViajesInput
  }

  export type viajesCreateOrConnectWithoutDestinosInput = {
    where: viajesWhereUniqueInput
    create: XOR<viajesCreateWithoutDestinosInput, viajesUncheckedCreateWithoutDestinosInput>
  }

  export type viajesCreateManyDestinosInputEnvelope = {
    data: viajesCreateManyDestinosInput | viajesCreateManyDestinosInput[]
    skipDuplicates?: boolean
  }

  export type paisesUpsertWithoutDestinosInput = {
    update: XOR<paisesUpdateWithoutDestinosInput, paisesUncheckedUpdateWithoutDestinosInput>
    create: XOR<paisesCreateWithoutDestinosInput, paisesUncheckedCreateWithoutDestinosInput>
    where?: paisesWhereInput
  }

  export type paisesUpdateToOneWithWhereWithoutDestinosInput = {
    where?: paisesWhereInput
    data: XOR<paisesUpdateWithoutDestinosInput, paisesUncheckedUpdateWithoutDestinosInput>
  }

  export type paisesUpdateWithoutDestinosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type paisesUncheckedUpdateWithoutDestinosInput = {
    id_pais?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type hospedajesUpsertWithWhereUniqueWithoutDestinosInput = {
    where: hospedajesWhereUniqueInput
    update: XOR<hospedajesUpdateWithoutDestinosInput, hospedajesUncheckedUpdateWithoutDestinosInput>
    create: XOR<hospedajesCreateWithoutDestinosInput, hospedajesUncheckedCreateWithoutDestinosInput>
  }

  export type hospedajesUpdateWithWhereUniqueWithoutDestinosInput = {
    where: hospedajesWhereUniqueInput
    data: XOR<hospedajesUpdateWithoutDestinosInput, hospedajesUncheckedUpdateWithoutDestinosInput>
  }

  export type hospedajesUpdateManyWithWhereWithoutDestinosInput = {
    where: hospedajesScalarWhereInput
    data: XOR<hospedajesUpdateManyMutationInput, hospedajesUncheckedUpdateManyWithoutDestinosInput>
  }

  export type hospedajesScalarWhereInput = {
    AND?: hospedajesScalarWhereInput | hospedajesScalarWhereInput[]
    OR?: hospedajesScalarWhereInput[]
    NOT?: hospedajesScalarWhereInput | hospedajesScalarWhereInput[]
    id_hospedaje?: IntFilter<"hospedajes"> | number
    id_destino?: IntFilter<"hospedajes"> | number
    nombre?: StringFilter<"hospedajes"> | string
    precio?: DecimalFilter<"hospedajes"> | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFilter<"hospedajes"> | string
    fecha_creacion?: DateTimeFilter<"hospedajes"> | Date | string
    fecha_modificacion?: DateTimeNullableFilter<"hospedajes"> | Date | string | null
  }

  export type viajesUpsertWithWhereUniqueWithoutDestinosInput = {
    where: viajesWhereUniqueInput
    update: XOR<viajesUpdateWithoutDestinosInput, viajesUncheckedUpdateWithoutDestinosInput>
    create: XOR<viajesCreateWithoutDestinosInput, viajesUncheckedCreateWithoutDestinosInput>
  }

  export type viajesUpdateWithWhereUniqueWithoutDestinosInput = {
    where: viajesWhereUniqueInput
    data: XOR<viajesUpdateWithoutDestinosInput, viajesUncheckedUpdateWithoutDestinosInput>
  }

  export type viajesUpdateManyWithWhereWithoutDestinosInput = {
    where: viajesScalarWhereInput
    data: XOR<viajesUpdateManyMutationInput, viajesUncheckedUpdateManyWithoutDestinosInput>
  }

  export type destinosCreateWithoutHospedajesInput = {
    nombre: string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
    paises: paisesCreateNestedOneWithoutDestinosInput
    viajes?: viajesCreateNestedManyWithoutDestinosInput
  }

  export type destinosUncheckedCreateWithoutHospedajesInput = {
    id_destino?: number
    id_pais: number
    nombre: string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
    viajes?: viajesUncheckedCreateNestedManyWithoutDestinosInput
  }

  export type destinosCreateOrConnectWithoutHospedajesInput = {
    where: destinosWhereUniqueInput
    create: XOR<destinosCreateWithoutHospedajesInput, destinosUncheckedCreateWithoutHospedajesInput>
  }

  export type paquetesCreateWithoutHospedajesInput = {
    nombre: string
    transporte: string
    precio: Decimal | DecimalJsLike | number | string
    estado_auditoria?: string
    fecha_modificacion?: Date | string
    fecha_creacion?: Date | string | null
    categorias: categoriasCreateNestedOneWithoutPaquetesInput
    viajes?: viajesCreateNestedManyWithoutPaquetesInput
  }

  export type paquetesUncheckedCreateWithoutHospedajesInput = {
    id_paquete?: number
    id_categoria: number
    nombre: string
    transporte: string
    precio: Decimal | DecimalJsLike | number | string
    estado_auditoria?: string
    fecha_modificacion?: Date | string
    fecha_creacion?: Date | string | null
    viajes?: viajesUncheckedCreateNestedManyWithoutPaquetesInput
  }

  export type paquetesCreateOrConnectWithoutHospedajesInput = {
    where: paquetesWhereUniqueInput
    create: XOR<paquetesCreateWithoutHospedajesInput, paquetesUncheckedCreateWithoutHospedajesInput>
  }

  export type paquetesCreateManyHospedajesInputEnvelope = {
    data: paquetesCreateManyHospedajesInput | paquetesCreateManyHospedajesInput[]
    skipDuplicates?: boolean
  }

  export type viajesCreateWithoutHospedajesInput = {
    fecha_inicio?: Date | string | null
    fecha_fin?: Date | string | null
    tarifa: Decimal | DecimalJsLike | number | string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
    itinerarios?: itinerariosCreateNestedManyWithoutViajesInput
    reservas?: reservasCreateNestedManyWithoutViajesInput
    categorias: categoriasCreateNestedOneWithoutViajesInput
    destinos: destinosCreateNestedOneWithoutViajesInput
    paquetes: paquetesCreateNestedOneWithoutViajesInput
  }

  export type viajesUncheckedCreateWithoutHospedajesInput = {
    id_viaje?: number
    id_destino: number
    id_categoria: number
    id_paquete: number
    fecha_inicio?: Date | string | null
    fecha_fin?: Date | string | null
    tarifa: Decimal | DecimalJsLike | number | string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
    itinerarios?: itinerariosUncheckedCreateNestedManyWithoutViajesInput
    reservas?: reservasUncheckedCreateNestedManyWithoutViajesInput
  }

  export type viajesCreateOrConnectWithoutHospedajesInput = {
    where: viajesWhereUniqueInput
    create: XOR<viajesCreateWithoutHospedajesInput, viajesUncheckedCreateWithoutHospedajesInput>
  }

  export type viajesCreateManyHospedajesInputEnvelope = {
    data: viajesCreateManyHospedajesInput | viajesCreateManyHospedajesInput[]
    skipDuplicates?: boolean
  }

  export type destinosUpsertWithoutHospedajesInput = {
    update: XOR<destinosUpdateWithoutHospedajesInput, destinosUncheckedUpdateWithoutHospedajesInput>
    create: XOR<destinosCreateWithoutHospedajesInput, destinosUncheckedCreateWithoutHospedajesInput>
    where?: destinosWhereInput
  }

  export type destinosUpdateToOneWithWhereWithoutHospedajesInput = {
    where?: destinosWhereInput
    data: XOR<destinosUpdateWithoutHospedajesInput, destinosUncheckedUpdateWithoutHospedajesInput>
  }

  export type destinosUpdateWithoutHospedajesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paises?: paisesUpdateOneRequiredWithoutDestinosNestedInput
    viajes?: viajesUpdateManyWithoutDestinosNestedInput
  }

  export type destinosUncheckedUpdateWithoutHospedajesInput = {
    id_destino?: IntFieldUpdateOperationsInput | number
    id_pais?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viajes?: viajesUncheckedUpdateManyWithoutDestinosNestedInput
  }

  export type paquetesUpsertWithWhereUniqueWithoutHospedajesInput = {
    where: paquetesWhereUniqueInput
    update: XOR<paquetesUpdateWithoutHospedajesInput, paquetesUncheckedUpdateWithoutHospedajesInput>
    create: XOR<paquetesCreateWithoutHospedajesInput, paquetesUncheckedCreateWithoutHospedajesInput>
  }

  export type paquetesUpdateWithWhereUniqueWithoutHospedajesInput = {
    where: paquetesWhereUniqueInput
    data: XOR<paquetesUpdateWithoutHospedajesInput, paquetesUncheckedUpdateWithoutHospedajesInput>
  }

  export type paquetesUpdateManyWithWhereWithoutHospedajesInput = {
    where: paquetesScalarWhereInput
    data: XOR<paquetesUpdateManyMutationInput, paquetesUncheckedUpdateManyWithoutHospedajesInput>
  }

  export type viajesUpsertWithWhereUniqueWithoutHospedajesInput = {
    where: viajesWhereUniqueInput
    update: XOR<viajesUpdateWithoutHospedajesInput, viajesUncheckedUpdateWithoutHospedajesInput>
    create: XOR<viajesCreateWithoutHospedajesInput, viajesUncheckedCreateWithoutHospedajesInput>
  }

  export type viajesUpdateWithWhereUniqueWithoutHospedajesInput = {
    where: viajesWhereUniqueInput
    data: XOR<viajesUpdateWithoutHospedajesInput, viajesUncheckedUpdateWithoutHospedajesInput>
  }

  export type viajesUpdateManyWithWhereWithoutHospedajesInput = {
    where: viajesScalarWhereInput
    data: XOR<viajesUpdateManyMutationInput, viajesUncheckedUpdateManyWithoutHospedajesInput>
  }

  export type usuariosCreateWithoutReservasInput = {
    nombres: string
    apellido_paterno: string
    apellido_materno: string
    username: string
    email: string
    clave: string
    telefono: string
    direccion: string
    sexo: string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
    roles: rolesCreateNestedOneWithoutUsuariosInput
  }

  export type usuariosUncheckedCreateWithoutReservasInput = {
    id_usuario?: number
    id_rol: number
    nombres: string
    apellido_paterno: string
    apellido_materno: string
    username: string
    email: string
    clave: string
    telefono: string
    direccion: string
    sexo: string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
  }

  export type usuariosCreateOrConnectWithoutReservasInput = {
    where: usuariosWhereUniqueInput
    create: XOR<usuariosCreateWithoutReservasInput, usuariosUncheckedCreateWithoutReservasInput>
  }

  export type viajesCreateWithoutReservasInput = {
    fecha_inicio?: Date | string | null
    fecha_fin?: Date | string | null
    tarifa: Decimal | DecimalJsLike | number | string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
    itinerarios?: itinerariosCreateNestedManyWithoutViajesInput
    categorias: categoriasCreateNestedOneWithoutViajesInput
    destinos: destinosCreateNestedOneWithoutViajesInput
    hospedajes: hospedajesCreateNestedOneWithoutViajesInput
    paquetes: paquetesCreateNestedOneWithoutViajesInput
  }

  export type viajesUncheckedCreateWithoutReservasInput = {
    id_viaje?: number
    id_destino: number
    id_categoria: number
    id_hospedaje: number
    id_paquete: number
    fecha_inicio?: Date | string | null
    fecha_fin?: Date | string | null
    tarifa: Decimal | DecimalJsLike | number | string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
    itinerarios?: itinerariosUncheckedCreateNestedManyWithoutViajesInput
  }

  export type viajesCreateOrConnectWithoutReservasInput = {
    where: viajesWhereUniqueInput
    create: XOR<viajesCreateWithoutReservasInput, viajesUncheckedCreateWithoutReservasInput>
  }

  export type usuariosUpsertWithoutReservasInput = {
    update: XOR<usuariosUpdateWithoutReservasInput, usuariosUncheckedUpdateWithoutReservasInput>
    create: XOR<usuariosCreateWithoutReservasInput, usuariosUncheckedCreateWithoutReservasInput>
    where?: usuariosWhereInput
  }

  export type usuariosUpdateToOneWithWhereWithoutReservasInput = {
    where?: usuariosWhereInput
    data: XOR<usuariosUpdateWithoutReservasInput, usuariosUncheckedUpdateWithoutReservasInput>
  }

  export type usuariosUpdateWithoutReservasInput = {
    nombres?: StringFieldUpdateOperationsInput | string
    apellido_paterno?: StringFieldUpdateOperationsInput | string
    apellido_materno?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    sexo?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roles?: rolesUpdateOneRequiredWithoutUsuariosNestedInput
  }

  export type usuariosUncheckedUpdateWithoutReservasInput = {
    id_usuario?: IntFieldUpdateOperationsInput | number
    id_rol?: IntFieldUpdateOperationsInput | number
    nombres?: StringFieldUpdateOperationsInput | string
    apellido_paterno?: StringFieldUpdateOperationsInput | string
    apellido_materno?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    sexo?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type viajesUpsertWithoutReservasInput = {
    update: XOR<viajesUpdateWithoutReservasInput, viajesUncheckedUpdateWithoutReservasInput>
    create: XOR<viajesCreateWithoutReservasInput, viajesUncheckedCreateWithoutReservasInput>
    where?: viajesWhereInput
  }

  export type viajesUpdateToOneWithWhereWithoutReservasInput = {
    where?: viajesWhereInput
    data: XOR<viajesUpdateWithoutReservasInput, viajesUncheckedUpdateWithoutReservasInput>
  }

  export type viajesUpdateWithoutReservasInput = {
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tarifa?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    itinerarios?: itinerariosUpdateManyWithoutViajesNestedInput
    categorias?: categoriasUpdateOneRequiredWithoutViajesNestedInput
    destinos?: destinosUpdateOneRequiredWithoutViajesNestedInput
    hospedajes?: hospedajesUpdateOneRequiredWithoutViajesNestedInput
    paquetes?: paquetesUpdateOneRequiredWithoutViajesNestedInput
  }

  export type viajesUncheckedUpdateWithoutReservasInput = {
    id_viaje?: IntFieldUpdateOperationsInput | number
    id_destino?: IntFieldUpdateOperationsInput | number
    id_categoria?: IntFieldUpdateOperationsInput | number
    id_hospedaje?: IntFieldUpdateOperationsInput | number
    id_paquete?: IntFieldUpdateOperationsInput | number
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tarifa?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    itinerarios?: itinerariosUncheckedUpdateManyWithoutViajesNestedInput
  }

  export type reservasCreateWithoutUsuariosInput = {
    numero_personas: string
    metodo_pago: string
    pago_total: Decimal | DecimalJsLike | number | string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
    viajes: viajesCreateNestedOneWithoutReservasInput
  }

  export type reservasUncheckedCreateWithoutUsuariosInput = {
    id_reserva?: number
    id_viaje: number
    numero_personas: string
    metodo_pago: string
    pago_total: Decimal | DecimalJsLike | number | string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
  }

  export type reservasCreateOrConnectWithoutUsuariosInput = {
    where: reservasWhereUniqueInput
    create: XOR<reservasCreateWithoutUsuariosInput, reservasUncheckedCreateWithoutUsuariosInput>
  }

  export type reservasCreateManyUsuariosInputEnvelope = {
    data: reservasCreateManyUsuariosInput | reservasCreateManyUsuariosInput[]
    skipDuplicates?: boolean
  }

  export type rolesCreateWithoutUsuariosInput = {
    nombre: string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
  }

  export type rolesUncheckedCreateWithoutUsuariosInput = {
    id_rol?: number
    nombre: string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
  }

  export type rolesCreateOrConnectWithoutUsuariosInput = {
    where: rolesWhereUniqueInput
    create: XOR<rolesCreateWithoutUsuariosInput, rolesUncheckedCreateWithoutUsuariosInput>
  }

  export type reservasUpsertWithWhereUniqueWithoutUsuariosInput = {
    where: reservasWhereUniqueInput
    update: XOR<reservasUpdateWithoutUsuariosInput, reservasUncheckedUpdateWithoutUsuariosInput>
    create: XOR<reservasCreateWithoutUsuariosInput, reservasUncheckedCreateWithoutUsuariosInput>
  }

  export type reservasUpdateWithWhereUniqueWithoutUsuariosInput = {
    where: reservasWhereUniqueInput
    data: XOR<reservasUpdateWithoutUsuariosInput, reservasUncheckedUpdateWithoutUsuariosInput>
  }

  export type reservasUpdateManyWithWhereWithoutUsuariosInput = {
    where: reservasScalarWhereInput
    data: XOR<reservasUpdateManyMutationInput, reservasUncheckedUpdateManyWithoutUsuariosInput>
  }

  export type reservasScalarWhereInput = {
    AND?: reservasScalarWhereInput | reservasScalarWhereInput[]
    OR?: reservasScalarWhereInput[]
    NOT?: reservasScalarWhereInput | reservasScalarWhereInput[]
    id_reserva?: IntFilter<"reservas"> | number
    id_usuario?: IntFilter<"reservas"> | number
    id_viaje?: IntFilter<"reservas"> | number
    numero_personas?: StringFilter<"reservas"> | string
    metodo_pago?: StringFilter<"reservas"> | string
    pago_total?: DecimalFilter<"reservas"> | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFilter<"reservas"> | string
    fecha_creacion?: DateTimeFilter<"reservas"> | Date | string
    fecha_modificacion?: DateTimeNullableFilter<"reservas"> | Date | string | null
  }

  export type rolesUpsertWithoutUsuariosInput = {
    update: XOR<rolesUpdateWithoutUsuariosInput, rolesUncheckedUpdateWithoutUsuariosInput>
    create: XOR<rolesCreateWithoutUsuariosInput, rolesUncheckedCreateWithoutUsuariosInput>
    where?: rolesWhereInput
  }

  export type rolesUpdateToOneWithWhereWithoutUsuariosInput = {
    where?: rolesWhereInput
    data: XOR<rolesUpdateWithoutUsuariosInput, rolesUncheckedUpdateWithoutUsuariosInput>
  }

  export type rolesUpdateWithoutUsuariosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type rolesUncheckedUpdateWithoutUsuariosInput = {
    id_rol?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type itinerariosCreateWithoutViajesInput = {
    dia: string
    hora_inicio: string
    hora_fin: string
    actividad: string
    descripcion: string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
  }

  export type itinerariosUncheckedCreateWithoutViajesInput = {
    id_itenerario?: number
    dia: string
    hora_inicio: string
    hora_fin: string
    actividad: string
    descripcion: string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
  }

  export type itinerariosCreateOrConnectWithoutViajesInput = {
    where: itinerariosWhereUniqueInput
    create: XOR<itinerariosCreateWithoutViajesInput, itinerariosUncheckedCreateWithoutViajesInput>
  }

  export type itinerariosCreateManyViajesInputEnvelope = {
    data: itinerariosCreateManyViajesInput | itinerariosCreateManyViajesInput[]
    skipDuplicates?: boolean
  }

  export type reservasCreateWithoutViajesInput = {
    numero_personas: string
    metodo_pago: string
    pago_total: Decimal | DecimalJsLike | number | string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
    usuarios: usuariosCreateNestedOneWithoutReservasInput
  }

  export type reservasUncheckedCreateWithoutViajesInput = {
    id_reserva?: number
    id_usuario: number
    numero_personas: string
    metodo_pago: string
    pago_total: Decimal | DecimalJsLike | number | string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
  }

  export type reservasCreateOrConnectWithoutViajesInput = {
    where: reservasWhereUniqueInput
    create: XOR<reservasCreateWithoutViajesInput, reservasUncheckedCreateWithoutViajesInput>
  }

  export type reservasCreateManyViajesInputEnvelope = {
    data: reservasCreateManyViajesInput | reservasCreateManyViajesInput[]
    skipDuplicates?: boolean
  }

  export type categoriasCreateWithoutViajesInput = {
    nombre: string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
    paquetes?: paquetesCreateNestedManyWithoutCategoriasInput
  }

  export type categoriasUncheckedCreateWithoutViajesInput = {
    id_categoria?: number
    nombre: string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
    paquetes?: paquetesUncheckedCreateNestedManyWithoutCategoriasInput
  }

  export type categoriasCreateOrConnectWithoutViajesInput = {
    where: categoriasWhereUniqueInput
    create: XOR<categoriasCreateWithoutViajesInput, categoriasUncheckedCreateWithoutViajesInput>
  }

  export type destinosCreateWithoutViajesInput = {
    nombre: string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
    paises: paisesCreateNestedOneWithoutDestinosInput
    hospedajes?: hospedajesCreateNestedManyWithoutDestinosInput
  }

  export type destinosUncheckedCreateWithoutViajesInput = {
    id_destino?: number
    id_pais: number
    nombre: string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
    hospedajes?: hospedajesUncheckedCreateNestedManyWithoutDestinosInput
  }

  export type destinosCreateOrConnectWithoutViajesInput = {
    where: destinosWhereUniqueInput
    create: XOR<destinosCreateWithoutViajesInput, destinosUncheckedCreateWithoutViajesInput>
  }

  export type hospedajesCreateWithoutViajesInput = {
    nombre: string
    precio: Decimal | DecimalJsLike | number | string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
    destinos: destinosCreateNestedOneWithoutHospedajesInput
    paquetes?: paquetesCreateNestedManyWithoutHospedajesInput
  }

  export type hospedajesUncheckedCreateWithoutViajesInput = {
    id_hospedaje?: number
    id_destino: number
    nombre: string
    precio: Decimal | DecimalJsLike | number | string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
    paquetes?: paquetesUncheckedCreateNestedManyWithoutHospedajesInput
  }

  export type hospedajesCreateOrConnectWithoutViajesInput = {
    where: hospedajesWhereUniqueInput
    create: XOR<hospedajesCreateWithoutViajesInput, hospedajesUncheckedCreateWithoutViajesInput>
  }

  export type paquetesCreateWithoutViajesInput = {
    nombre: string
    transporte: string
    precio: Decimal | DecimalJsLike | number | string
    estado_auditoria?: string
    fecha_modificacion?: Date | string
    fecha_creacion?: Date | string | null
    categorias: categoriasCreateNestedOneWithoutPaquetesInput
    hospedajes: hospedajesCreateNestedOneWithoutPaquetesInput
  }

  export type paquetesUncheckedCreateWithoutViajesInput = {
    id_paquete?: number
    id_hospedaje: number
    id_categoria: number
    nombre: string
    transporte: string
    precio: Decimal | DecimalJsLike | number | string
    estado_auditoria?: string
    fecha_modificacion?: Date | string
    fecha_creacion?: Date | string | null
  }

  export type paquetesCreateOrConnectWithoutViajesInput = {
    where: paquetesWhereUniqueInput
    create: XOR<paquetesCreateWithoutViajesInput, paquetesUncheckedCreateWithoutViajesInput>
  }

  export type itinerariosUpsertWithWhereUniqueWithoutViajesInput = {
    where: itinerariosWhereUniqueInput
    update: XOR<itinerariosUpdateWithoutViajesInput, itinerariosUncheckedUpdateWithoutViajesInput>
    create: XOR<itinerariosCreateWithoutViajesInput, itinerariosUncheckedCreateWithoutViajesInput>
  }

  export type itinerariosUpdateWithWhereUniqueWithoutViajesInput = {
    where: itinerariosWhereUniqueInput
    data: XOR<itinerariosUpdateWithoutViajesInput, itinerariosUncheckedUpdateWithoutViajesInput>
  }

  export type itinerariosUpdateManyWithWhereWithoutViajesInput = {
    where: itinerariosScalarWhereInput
    data: XOR<itinerariosUpdateManyMutationInput, itinerariosUncheckedUpdateManyWithoutViajesInput>
  }

  export type itinerariosScalarWhereInput = {
    AND?: itinerariosScalarWhereInput | itinerariosScalarWhereInput[]
    OR?: itinerariosScalarWhereInput[]
    NOT?: itinerariosScalarWhereInput | itinerariosScalarWhereInput[]
    id_itenerario?: IntFilter<"itinerarios"> | number
    id_viaje?: IntFilter<"itinerarios"> | number
    dia?: StringFilter<"itinerarios"> | string
    hora_inicio?: StringFilter<"itinerarios"> | string
    hora_fin?: StringFilter<"itinerarios"> | string
    actividad?: StringFilter<"itinerarios"> | string
    descripcion?: StringFilter<"itinerarios"> | string
    estado_auditoria?: StringFilter<"itinerarios"> | string
    fecha_creacion?: DateTimeFilter<"itinerarios"> | Date | string
    fecha_modificacion?: DateTimeNullableFilter<"itinerarios"> | Date | string | null
  }

  export type reservasUpsertWithWhereUniqueWithoutViajesInput = {
    where: reservasWhereUniqueInput
    update: XOR<reservasUpdateWithoutViajesInput, reservasUncheckedUpdateWithoutViajesInput>
    create: XOR<reservasCreateWithoutViajesInput, reservasUncheckedCreateWithoutViajesInput>
  }

  export type reservasUpdateWithWhereUniqueWithoutViajesInput = {
    where: reservasWhereUniqueInput
    data: XOR<reservasUpdateWithoutViajesInput, reservasUncheckedUpdateWithoutViajesInput>
  }

  export type reservasUpdateManyWithWhereWithoutViajesInput = {
    where: reservasScalarWhereInput
    data: XOR<reservasUpdateManyMutationInput, reservasUncheckedUpdateManyWithoutViajesInput>
  }

  export type categoriasUpsertWithoutViajesInput = {
    update: XOR<categoriasUpdateWithoutViajesInput, categoriasUncheckedUpdateWithoutViajesInput>
    create: XOR<categoriasCreateWithoutViajesInput, categoriasUncheckedCreateWithoutViajesInput>
    where?: categoriasWhereInput
  }

  export type categoriasUpdateToOneWithWhereWithoutViajesInput = {
    where?: categoriasWhereInput
    data: XOR<categoriasUpdateWithoutViajesInput, categoriasUncheckedUpdateWithoutViajesInput>
  }

  export type categoriasUpdateWithoutViajesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paquetes?: paquetesUpdateManyWithoutCategoriasNestedInput
  }

  export type categoriasUncheckedUpdateWithoutViajesInput = {
    id_categoria?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paquetes?: paquetesUncheckedUpdateManyWithoutCategoriasNestedInput
  }

  export type destinosUpsertWithoutViajesInput = {
    update: XOR<destinosUpdateWithoutViajesInput, destinosUncheckedUpdateWithoutViajesInput>
    create: XOR<destinosCreateWithoutViajesInput, destinosUncheckedCreateWithoutViajesInput>
    where?: destinosWhereInput
  }

  export type destinosUpdateToOneWithWhereWithoutViajesInput = {
    where?: destinosWhereInput
    data: XOR<destinosUpdateWithoutViajesInput, destinosUncheckedUpdateWithoutViajesInput>
  }

  export type destinosUpdateWithoutViajesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paises?: paisesUpdateOneRequiredWithoutDestinosNestedInput
    hospedajes?: hospedajesUpdateManyWithoutDestinosNestedInput
  }

  export type destinosUncheckedUpdateWithoutViajesInput = {
    id_destino?: IntFieldUpdateOperationsInput | number
    id_pais?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hospedajes?: hospedajesUncheckedUpdateManyWithoutDestinosNestedInput
  }

  export type hospedajesUpsertWithoutViajesInput = {
    update: XOR<hospedajesUpdateWithoutViajesInput, hospedajesUncheckedUpdateWithoutViajesInput>
    create: XOR<hospedajesCreateWithoutViajesInput, hospedajesUncheckedCreateWithoutViajesInput>
    where?: hospedajesWhereInput
  }

  export type hospedajesUpdateToOneWithWhereWithoutViajesInput = {
    where?: hospedajesWhereInput
    data: XOR<hospedajesUpdateWithoutViajesInput, hospedajesUncheckedUpdateWithoutViajesInput>
  }

  export type hospedajesUpdateWithoutViajesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    destinos?: destinosUpdateOneRequiredWithoutHospedajesNestedInput
    paquetes?: paquetesUpdateManyWithoutHospedajesNestedInput
  }

  export type hospedajesUncheckedUpdateWithoutViajesInput = {
    id_hospedaje?: IntFieldUpdateOperationsInput | number
    id_destino?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paquetes?: paquetesUncheckedUpdateManyWithoutHospedajesNestedInput
  }

  export type paquetesUpsertWithoutViajesInput = {
    update: XOR<paquetesUpdateWithoutViajesInput, paquetesUncheckedUpdateWithoutViajesInput>
    create: XOR<paquetesCreateWithoutViajesInput, paquetesUncheckedCreateWithoutViajesInput>
    where?: paquetesWhereInput
  }

  export type paquetesUpdateToOneWithWhereWithoutViajesInput = {
    where?: paquetesWhereInput
    data: XOR<paquetesUpdateWithoutViajesInput, paquetesUncheckedUpdateWithoutViajesInput>
  }

  export type paquetesUpdateWithoutViajesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    transporte?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_modificacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categorias?: categoriasUpdateOneRequiredWithoutPaquetesNestedInput
    hospedajes?: hospedajesUpdateOneRequiredWithoutPaquetesNestedInput
  }

  export type paquetesUncheckedUpdateWithoutViajesInput = {
    id_paquete?: IntFieldUpdateOperationsInput | number
    id_hospedaje?: IntFieldUpdateOperationsInput | number
    id_categoria?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    transporte?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_modificacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type viajesCreateWithoutItinerariosInput = {
    fecha_inicio?: Date | string | null
    fecha_fin?: Date | string | null
    tarifa: Decimal | DecimalJsLike | number | string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
    reservas?: reservasCreateNestedManyWithoutViajesInput
    categorias: categoriasCreateNestedOneWithoutViajesInput
    destinos: destinosCreateNestedOneWithoutViajesInput
    hospedajes: hospedajesCreateNestedOneWithoutViajesInput
    paquetes: paquetesCreateNestedOneWithoutViajesInput
  }

  export type viajesUncheckedCreateWithoutItinerariosInput = {
    id_viaje?: number
    id_destino: number
    id_categoria: number
    id_hospedaje: number
    id_paquete: number
    fecha_inicio?: Date | string | null
    fecha_fin?: Date | string | null
    tarifa: Decimal | DecimalJsLike | number | string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
    reservas?: reservasUncheckedCreateNestedManyWithoutViajesInput
  }

  export type viajesCreateOrConnectWithoutItinerariosInput = {
    where: viajesWhereUniqueInput
    create: XOR<viajesCreateWithoutItinerariosInput, viajesUncheckedCreateWithoutItinerariosInput>
  }

  export type viajesUpsertWithoutItinerariosInput = {
    update: XOR<viajesUpdateWithoutItinerariosInput, viajesUncheckedUpdateWithoutItinerariosInput>
    create: XOR<viajesCreateWithoutItinerariosInput, viajesUncheckedCreateWithoutItinerariosInput>
    where?: viajesWhereInput
  }

  export type viajesUpdateToOneWithWhereWithoutItinerariosInput = {
    where?: viajesWhereInput
    data: XOR<viajesUpdateWithoutItinerariosInput, viajesUncheckedUpdateWithoutItinerariosInput>
  }

  export type viajesUpdateWithoutItinerariosInput = {
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tarifa?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reservas?: reservasUpdateManyWithoutViajesNestedInput
    categorias?: categoriasUpdateOneRequiredWithoutViajesNestedInput
    destinos?: destinosUpdateOneRequiredWithoutViajesNestedInput
    hospedajes?: hospedajesUpdateOneRequiredWithoutViajesNestedInput
    paquetes?: paquetesUpdateOneRequiredWithoutViajesNestedInput
  }

  export type viajesUncheckedUpdateWithoutItinerariosInput = {
    id_viaje?: IntFieldUpdateOperationsInput | number
    id_destino?: IntFieldUpdateOperationsInput | number
    id_categoria?: IntFieldUpdateOperationsInput | number
    id_hospedaje?: IntFieldUpdateOperationsInput | number
    id_paquete?: IntFieldUpdateOperationsInput | number
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tarifa?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reservas?: reservasUncheckedUpdateManyWithoutViajesNestedInput
  }

  export type paquetesCreateManyCategoriasInput = {
    id_paquete?: number
    id_hospedaje: number
    nombre: string
    transporte: string
    precio: Decimal | DecimalJsLike | number | string
    estado_auditoria?: string
    fecha_modificacion?: Date | string
    fecha_creacion?: Date | string | null
  }

  export type viajesCreateManyCategoriasInput = {
    id_viaje?: number
    id_destino: number
    id_hospedaje: number
    id_paquete: number
    fecha_inicio?: Date | string | null
    fecha_fin?: Date | string | null
    tarifa: Decimal | DecimalJsLike | number | string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
  }

  export type paquetesUpdateWithoutCategoriasInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    transporte?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_modificacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hospedajes?: hospedajesUpdateOneRequiredWithoutPaquetesNestedInput
    viajes?: viajesUpdateManyWithoutPaquetesNestedInput
  }

  export type paquetesUncheckedUpdateWithoutCategoriasInput = {
    id_paquete?: IntFieldUpdateOperationsInput | number
    id_hospedaje?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    transporte?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_modificacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viajes?: viajesUncheckedUpdateManyWithoutPaquetesNestedInput
  }

  export type paquetesUncheckedUpdateManyWithoutCategoriasInput = {
    id_paquete?: IntFieldUpdateOperationsInput | number
    id_hospedaje?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    transporte?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_modificacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type viajesUpdateWithoutCategoriasInput = {
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tarifa?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    itinerarios?: itinerariosUpdateManyWithoutViajesNestedInput
    reservas?: reservasUpdateManyWithoutViajesNestedInput
    destinos?: destinosUpdateOneRequiredWithoutViajesNestedInput
    hospedajes?: hospedajesUpdateOneRequiredWithoutViajesNestedInput
    paquetes?: paquetesUpdateOneRequiredWithoutViajesNestedInput
  }

  export type viajesUncheckedUpdateWithoutCategoriasInput = {
    id_viaje?: IntFieldUpdateOperationsInput | number
    id_destino?: IntFieldUpdateOperationsInput | number
    id_hospedaje?: IntFieldUpdateOperationsInput | number
    id_paquete?: IntFieldUpdateOperationsInput | number
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tarifa?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    itinerarios?: itinerariosUncheckedUpdateManyWithoutViajesNestedInput
    reservas?: reservasUncheckedUpdateManyWithoutViajesNestedInput
  }

  export type viajesUncheckedUpdateManyWithoutCategoriasInput = {
    id_viaje?: IntFieldUpdateOperationsInput | number
    id_destino?: IntFieldUpdateOperationsInput | number
    id_hospedaje?: IntFieldUpdateOperationsInput | number
    id_paquete?: IntFieldUpdateOperationsInput | number
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tarifa?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type destinosCreateManyPaisesInput = {
    id_destino?: number
    nombre: string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
  }

  export type destinosUpdateWithoutPaisesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hospedajes?: hospedajesUpdateManyWithoutDestinosNestedInput
    viajes?: viajesUpdateManyWithoutDestinosNestedInput
  }

  export type destinosUncheckedUpdateWithoutPaisesInput = {
    id_destino?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hospedajes?: hospedajesUncheckedUpdateManyWithoutDestinosNestedInput
    viajes?: viajesUncheckedUpdateManyWithoutDestinosNestedInput
  }

  export type destinosUncheckedUpdateManyWithoutPaisesInput = {
    id_destino?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type viajesCreateManyPaquetesInput = {
    id_viaje?: number
    id_destino: number
    id_categoria: number
    id_hospedaje: number
    fecha_inicio?: Date | string | null
    fecha_fin?: Date | string | null
    tarifa: Decimal | DecimalJsLike | number | string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
  }

  export type viajesUpdateWithoutPaquetesInput = {
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tarifa?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    itinerarios?: itinerariosUpdateManyWithoutViajesNestedInput
    reservas?: reservasUpdateManyWithoutViajesNestedInput
    categorias?: categoriasUpdateOneRequiredWithoutViajesNestedInput
    destinos?: destinosUpdateOneRequiredWithoutViajesNestedInput
    hospedajes?: hospedajesUpdateOneRequiredWithoutViajesNestedInput
  }

  export type viajesUncheckedUpdateWithoutPaquetesInput = {
    id_viaje?: IntFieldUpdateOperationsInput | number
    id_destino?: IntFieldUpdateOperationsInput | number
    id_categoria?: IntFieldUpdateOperationsInput | number
    id_hospedaje?: IntFieldUpdateOperationsInput | number
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tarifa?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    itinerarios?: itinerariosUncheckedUpdateManyWithoutViajesNestedInput
    reservas?: reservasUncheckedUpdateManyWithoutViajesNestedInput
  }

  export type viajesUncheckedUpdateManyWithoutPaquetesInput = {
    id_viaje?: IntFieldUpdateOperationsInput | number
    id_destino?: IntFieldUpdateOperationsInput | number
    id_categoria?: IntFieldUpdateOperationsInput | number
    id_hospedaje?: IntFieldUpdateOperationsInput | number
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tarifa?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usuariosCreateManyRolesInput = {
    id_usuario?: number
    nombres: string
    apellido_paterno: string
    apellido_materno: string
    username: string
    email: string
    clave: string
    telefono: string
    direccion: string
    sexo: string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
  }

  export type usuariosUpdateWithoutRolesInput = {
    nombres?: StringFieldUpdateOperationsInput | string
    apellido_paterno?: StringFieldUpdateOperationsInput | string
    apellido_materno?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    sexo?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reservas?: reservasUpdateManyWithoutUsuariosNestedInput
  }

  export type usuariosUncheckedUpdateWithoutRolesInput = {
    id_usuario?: IntFieldUpdateOperationsInput | number
    nombres?: StringFieldUpdateOperationsInput | string
    apellido_paterno?: StringFieldUpdateOperationsInput | string
    apellido_materno?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    sexo?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reservas?: reservasUncheckedUpdateManyWithoutUsuariosNestedInput
  }

  export type usuariosUncheckedUpdateManyWithoutRolesInput = {
    id_usuario?: IntFieldUpdateOperationsInput | number
    nombres?: StringFieldUpdateOperationsInput | string
    apellido_paterno?: StringFieldUpdateOperationsInput | string
    apellido_materno?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    sexo?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type hospedajesCreateManyDestinosInput = {
    id_hospedaje?: number
    nombre: string
    precio: Decimal | DecimalJsLike | number | string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
  }

  export type viajesCreateManyDestinosInput = {
    id_viaje?: number
    id_categoria: number
    id_hospedaje: number
    id_paquete: number
    fecha_inicio?: Date | string | null
    fecha_fin?: Date | string | null
    tarifa: Decimal | DecimalJsLike | number | string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
  }

  export type hospedajesUpdateWithoutDestinosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paquetes?: paquetesUpdateManyWithoutHospedajesNestedInput
    viajes?: viajesUpdateManyWithoutHospedajesNestedInput
  }

  export type hospedajesUncheckedUpdateWithoutDestinosInput = {
    id_hospedaje?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paquetes?: paquetesUncheckedUpdateManyWithoutHospedajesNestedInput
    viajes?: viajesUncheckedUpdateManyWithoutHospedajesNestedInput
  }

  export type hospedajesUncheckedUpdateManyWithoutDestinosInput = {
    id_hospedaje?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type viajesUpdateWithoutDestinosInput = {
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tarifa?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    itinerarios?: itinerariosUpdateManyWithoutViajesNestedInput
    reservas?: reservasUpdateManyWithoutViajesNestedInput
    categorias?: categoriasUpdateOneRequiredWithoutViajesNestedInput
    hospedajes?: hospedajesUpdateOneRequiredWithoutViajesNestedInput
    paquetes?: paquetesUpdateOneRequiredWithoutViajesNestedInput
  }

  export type viajesUncheckedUpdateWithoutDestinosInput = {
    id_viaje?: IntFieldUpdateOperationsInput | number
    id_categoria?: IntFieldUpdateOperationsInput | number
    id_hospedaje?: IntFieldUpdateOperationsInput | number
    id_paquete?: IntFieldUpdateOperationsInput | number
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tarifa?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    itinerarios?: itinerariosUncheckedUpdateManyWithoutViajesNestedInput
    reservas?: reservasUncheckedUpdateManyWithoutViajesNestedInput
  }

  export type viajesUncheckedUpdateManyWithoutDestinosInput = {
    id_viaje?: IntFieldUpdateOperationsInput | number
    id_categoria?: IntFieldUpdateOperationsInput | number
    id_hospedaje?: IntFieldUpdateOperationsInput | number
    id_paquete?: IntFieldUpdateOperationsInput | number
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tarifa?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type paquetesCreateManyHospedajesInput = {
    id_paquete?: number
    id_categoria: number
    nombre: string
    transporte: string
    precio: Decimal | DecimalJsLike | number | string
    estado_auditoria?: string
    fecha_modificacion?: Date | string
    fecha_creacion?: Date | string | null
  }

  export type viajesCreateManyHospedajesInput = {
    id_viaje?: number
    id_destino: number
    id_categoria: number
    id_paquete: number
    fecha_inicio?: Date | string | null
    fecha_fin?: Date | string | null
    tarifa: Decimal | DecimalJsLike | number | string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
  }

  export type paquetesUpdateWithoutHospedajesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    transporte?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_modificacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categorias?: categoriasUpdateOneRequiredWithoutPaquetesNestedInput
    viajes?: viajesUpdateManyWithoutPaquetesNestedInput
  }

  export type paquetesUncheckedUpdateWithoutHospedajesInput = {
    id_paquete?: IntFieldUpdateOperationsInput | number
    id_categoria?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    transporte?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_modificacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viajes?: viajesUncheckedUpdateManyWithoutPaquetesNestedInput
  }

  export type paquetesUncheckedUpdateManyWithoutHospedajesInput = {
    id_paquete?: IntFieldUpdateOperationsInput | number
    id_categoria?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    transporte?: StringFieldUpdateOperationsInput | string
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_modificacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_creacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type viajesUpdateWithoutHospedajesInput = {
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tarifa?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    itinerarios?: itinerariosUpdateManyWithoutViajesNestedInput
    reservas?: reservasUpdateManyWithoutViajesNestedInput
    categorias?: categoriasUpdateOneRequiredWithoutViajesNestedInput
    destinos?: destinosUpdateOneRequiredWithoutViajesNestedInput
    paquetes?: paquetesUpdateOneRequiredWithoutViajesNestedInput
  }

  export type viajesUncheckedUpdateWithoutHospedajesInput = {
    id_viaje?: IntFieldUpdateOperationsInput | number
    id_destino?: IntFieldUpdateOperationsInput | number
    id_categoria?: IntFieldUpdateOperationsInput | number
    id_paquete?: IntFieldUpdateOperationsInput | number
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tarifa?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    itinerarios?: itinerariosUncheckedUpdateManyWithoutViajesNestedInput
    reservas?: reservasUncheckedUpdateManyWithoutViajesNestedInput
  }

  export type viajesUncheckedUpdateManyWithoutHospedajesInput = {
    id_viaje?: IntFieldUpdateOperationsInput | number
    id_destino?: IntFieldUpdateOperationsInput | number
    id_categoria?: IntFieldUpdateOperationsInput | number
    id_paquete?: IntFieldUpdateOperationsInput | number
    fecha_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tarifa?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type reservasCreateManyUsuariosInput = {
    id_reserva?: number
    id_viaje: number
    numero_personas: string
    metodo_pago: string
    pago_total: Decimal | DecimalJsLike | number | string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
  }

  export type reservasUpdateWithoutUsuariosInput = {
    numero_personas?: StringFieldUpdateOperationsInput | string
    metodo_pago?: StringFieldUpdateOperationsInput | string
    pago_total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viajes?: viajesUpdateOneRequiredWithoutReservasNestedInput
  }

  export type reservasUncheckedUpdateWithoutUsuariosInput = {
    id_reserva?: IntFieldUpdateOperationsInput | number
    id_viaje?: IntFieldUpdateOperationsInput | number
    numero_personas?: StringFieldUpdateOperationsInput | string
    metodo_pago?: StringFieldUpdateOperationsInput | string
    pago_total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type reservasUncheckedUpdateManyWithoutUsuariosInput = {
    id_reserva?: IntFieldUpdateOperationsInput | number
    id_viaje?: IntFieldUpdateOperationsInput | number
    numero_personas?: StringFieldUpdateOperationsInput | string
    metodo_pago?: StringFieldUpdateOperationsInput | string
    pago_total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type itinerariosCreateManyViajesInput = {
    id_itenerario?: number
    dia: string
    hora_inicio: string
    hora_fin: string
    actividad: string
    descripcion: string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
  }

  export type reservasCreateManyViajesInput = {
    id_reserva?: number
    id_usuario: number
    numero_personas: string
    metodo_pago: string
    pago_total: Decimal | DecimalJsLike | number | string
    estado_auditoria?: string
    fecha_creacion?: Date | string
    fecha_modificacion?: Date | string | null
  }

  export type itinerariosUpdateWithoutViajesInput = {
    dia?: StringFieldUpdateOperationsInput | string
    hora_inicio?: StringFieldUpdateOperationsInput | string
    hora_fin?: StringFieldUpdateOperationsInput | string
    actividad?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type itinerariosUncheckedUpdateWithoutViajesInput = {
    id_itenerario?: IntFieldUpdateOperationsInput | number
    dia?: StringFieldUpdateOperationsInput | string
    hora_inicio?: StringFieldUpdateOperationsInput | string
    hora_fin?: StringFieldUpdateOperationsInput | string
    actividad?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type itinerariosUncheckedUpdateManyWithoutViajesInput = {
    id_itenerario?: IntFieldUpdateOperationsInput | number
    dia?: StringFieldUpdateOperationsInput | string
    hora_inicio?: StringFieldUpdateOperationsInput | string
    hora_fin?: StringFieldUpdateOperationsInput | string
    actividad?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type reservasUpdateWithoutViajesInput = {
    numero_personas?: StringFieldUpdateOperationsInput | string
    metodo_pago?: StringFieldUpdateOperationsInput | string
    pago_total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usuarios?: usuariosUpdateOneRequiredWithoutReservasNestedInput
  }

  export type reservasUncheckedUpdateWithoutViajesInput = {
    id_reserva?: IntFieldUpdateOperationsInput | number
    id_usuario?: IntFieldUpdateOperationsInput | number
    numero_personas?: StringFieldUpdateOperationsInput | string
    metodo_pago?: StringFieldUpdateOperationsInput | string
    pago_total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type reservasUncheckedUpdateManyWithoutViajesInput = {
    id_reserva?: IntFieldUpdateOperationsInput | number
    id_usuario?: IntFieldUpdateOperationsInput | number
    numero_personas?: StringFieldUpdateOperationsInput | string
    metodo_pago?: StringFieldUpdateOperationsInput | string
    pago_total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estado_auditoria?: StringFieldUpdateOperationsInput | string
    fecha_creacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use CategoriasCountOutputTypeDefaultArgs instead
     */
    export type CategoriasCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoriasCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaisesCountOutputTypeDefaultArgs instead
     */
    export type PaisesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaisesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaquetesCountOutputTypeDefaultArgs instead
     */
    export type PaquetesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaquetesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RolesCountOutputTypeDefaultArgs instead
     */
    export type RolesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RolesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DestinosCountOutputTypeDefaultArgs instead
     */
    export type DestinosCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DestinosCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HospedajesCountOutputTypeDefaultArgs instead
     */
    export type HospedajesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HospedajesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsuariosCountOutputTypeDefaultArgs instead
     */
    export type UsuariosCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsuariosCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ViajesCountOutputTypeDefaultArgs instead
     */
    export type ViajesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ViajesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use categoriasDefaultArgs instead
     */
    export type categoriasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = categoriasDefaultArgs<ExtArgs>
    /**
     * @deprecated Use paisesDefaultArgs instead
     */
    export type paisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = paisesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use paquetesDefaultArgs instead
     */
    export type paquetesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = paquetesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use rolesDefaultArgs instead
     */
    export type rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = rolesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use destinosDefaultArgs instead
     */
    export type destinosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = destinosDefaultArgs<ExtArgs>
    /**
     * @deprecated Use hospedajesDefaultArgs instead
     */
    export type hospedajesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = hospedajesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use reservasDefaultArgs instead
     */
    export type reservasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = reservasDefaultArgs<ExtArgs>
    /**
     * @deprecated Use usuariosDefaultArgs instead
     */
    export type usuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = usuariosDefaultArgs<ExtArgs>
    /**
     * @deprecated Use viajesDefaultArgs instead
     */
    export type viajesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = viajesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use itinerariosDefaultArgs instead
     */
    export type itinerariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = itinerariosDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}